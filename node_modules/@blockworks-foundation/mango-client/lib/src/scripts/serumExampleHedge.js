"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web3_js_1 = require("@solana/web3.js");
const fs_1 = __importDefault(require("fs"));
const bn_js_1 = require("bn.js");
const serum_1 = require("@project-serum/serum");
const lodash_1 = require("lodash");
const ws_1 = __importDefault(require("ws"));
const utils_1 = require("../utils/utils");
const client_1 = require("../client");
const layout_1 = require("../layout");
const config_1 = require("../config");
const instruction_1 = require("../instruction");
const PerpEventQueue_1 = __importDefault(require("../PerpEventQueue"));
const perf_hooks_1 = require("perf_hooks");
const MangoAccount_1 = __importDefault(require("../MangoAccount"));
const mango_risk_check_1 = require("mango_risk_check");
// KEYPAIR=~/.config/solana/id.json MANGO_GROUP=devnet.2 MANGO_ACCOUNT=BFLAGijqDyRnK93scRizT8YSotrvdxhdJyWYZch6yMMW SYMBOL=SOL PERPS_FILLS_FEED=ws://api.mngo.cloud:2082 npx ts-node serumExampleHedge.ts
const main = () => __awaiter(void 0, void 0, void 0, function* () {
    const { MANGO_GROUP, KEYPAIR, MANGO_ACCOUNT, SYMBOL, PERPS_FILLS_FEED } = process.env;
    const config = config_1.Config.ids();
    if (!MANGO_GROUP) {
        console.log('Attach a MANGO_GROUP env variable.');
        return;
    }
    const mangoGroupConfig = config.getGroupWithName(MANGO_GROUP);
    if (!mangoGroupConfig) {
        console.log(`Couldn't find group by name ${MANGO_GROUP}`);
        return;
    }
    const [token, perpMarketConfig, spotMarketConfig] = [
        (0, config_1.getTokenBySymbol)(mangoGroupConfig, SYMBOL),
        (0, config_1.getPerpMarketByBaseSymbol)(mangoGroupConfig, SYMBOL),
        (0, config_1.getSpotMarketByBaseSymbol)(mangoGroupConfig, SYMBOL)
    ];
    if (!token || !perpMarketConfig || !spotMarketConfig) {
        console.log(`token, perpMarketConfig or spotMarketConfig by symbol ${SYMBOL} not found`);
        return;
    }
    const connection = new web3_js_1.Connection(config.cluster_urls[mangoGroupConfig.cluster], 'processed');
    // ^ See https://docs.solana.com/developing/clients/jsonrpc-api#configuring-state-commitment
    // to learn more about each state commitment i.e processed, confirmed and finalized.
    const mangoClient = new client_1.MangoClient(connection, mangoGroupConfig.mangoProgramId);
    console.log('Loading Mango group...');
    const mangoGroup = yield mangoClient.getMangoGroup(mangoGroupConfig.publicKey);
    console.log(`Loaded! ${(perf_hooks_1.performance.now() / 1e3).toFixed(2)}s`);
    console.log('Loading mangoCache, rootBanks, perpMarket and spotMarket...');
    const [mangoCache, rootBanks, perpMarket, spotMarket] = yield Promise.all([
        mangoGroup.loadCache(connection),
        mangoGroup.loadRootBanks(connection),
        mangoGroup.loadPerpMarket(connection, perpMarketConfig.marketIndex, perpMarketConfig.baseDecimals, perpMarketConfig.quoteDecimals),
        serum_1.Market.load(connection, spotMarketConfig.publicKey, undefined, mangoGroupConfig.serumProgramId)
    ]);
    console.log(`Loaded! ${(perf_hooks_1.performance.now() / 1e3).toFixed(2)}s`);
    console.log('Loading meta...');
    const payer = web3_js_1.Keypair.fromSecretKey(new Uint8Array(JSON.parse(fs_1.default.readFileSync(KEYPAIR, 'utf-8'))));
    const mangoAccountPk = new web3_js_1.PublicKey(MANGO_ACCOUNT);
    const spotOpenOrdersPks = (yield mangoClient.getMangoAccount(mangoAccountPk, mangoGroup.dexProgramId)).spotOpenOrders;
    function monitor() {
        return __awaiter(this, void 0, void 0, function* () {
            const [mangoAccountRaw, perpEventQueueRaw, ...spotOpenOrdersAccountsRaw] = yield (0, utils_1.getMultipleAccounts)(connection, [
                mangoAccountPk,
                perpMarketConfig.eventsKey,
                ...spotOpenOrdersPks.filter(spotOpenOrderAccount => !spotOpenOrderAccount.equals(utils_1.zeroKey))
            ]);
            const slot = mangoAccountRaw.context.slot;
            const mangoAccount = new MangoAccount_1.default(mangoAccountPk, layout_1.MangoAccountLayout.decode(mangoAccountRaw.accountInfo.data));
            mangoAccount.spotOpenOrdersAccounts = spotOpenOrdersPks.map((openOrderPk) => {
                if (openOrderPk.equals(utils_1.zeroKey)) {
                    return undefined;
                }
                const account = spotOpenOrdersAccountsRaw.find((a) => a.publicKey.equals(openOrderPk));
                return account
                    ? serum_1.OpenOrders.fromAccountInfo(openOrderPk, account.accountInfo, mangoGroup.dexProgramId)
                    : undefined;
            });
            const perpEventQueue = new PerpEventQueue_1.default(layout_1.PerpEventQueueLayout.decode(perpEventQueueRaw.accountInfo.data));
            const recentBlockHash = yield connection.getLatestBlockhash('finalized');
            // ^ Solana transactions require a recent block hash passed as metadata in order to be signed.
            // Instead of fetching this before dispatching every transaction (which would delay it by a
            // few milliseconds) we poll for this regularly in the background.
            const recentBlockTime = yield connection.getBlockTime(yield connection.getSlot('finalized'));
            return [slot, mangoAccount, perpEventQueue, recentBlockHash, recentBlockTime];
        });
    }
    let [slot, mangoAccount, perpEventQueue, recentBlockHash, recentBlockTime] = yield monitor();
    console.log(`Loaded! ${(perf_hooks_1.performance.now() / 1e3).toFixed(2)}s`);
    // ^ This will be used to as reference for time in force orders later on.
    // It is important to use cluster time, like above, and not local time.
    setInterval(() => __awaiter(void 0, void 0, void 0, function* () {
        [
            slot,
            mangoAccount,
            perpEventQueue,
            recentBlockHash,
            recentBlockTime
        ] = yield monitor();
    }), 5000);
    /*

    To interact with the (Serum) DEX, a given user must create an OpenOrders
    account. This account stores the following:
    - How much of the base and quote currency (in the SOL/USDC pair, SOL
      would be base currency and USDC would be quote) that user has locked
      in open orders or is settleable
    - A list of open orders for that user on that market

    */
    yield mangoClient.ensureOpenOrdersAccount(mangoAccount, mangoGroup, payer, spotMarket, spotMarketConfig);
    console.log('Loading risk checker...');
    // The risk checker prevents long/short exposure & open orders from exceeding specific thresholds
    // https://github.com/Is0tope/mango_risk_check/blob/master/js/examples/example.ts
    const riskChecker = new mango_risk_check_1.MangoRiskCheck({
        connection: connection,
        mangoAccount: mangoAccount,
        mangoClient: mangoClient,
        mangoGroup: mangoGroup,
        owner: payer
    });
    try {
        yield riskChecker.initializeRiskAccount(perpMarketConfig);
    }
    catch (error) {
        console.log(error);
    }
    try {
        yield Promise.all([
            riskChecker.setMaxOpenOrders(perpMarketConfig, 2),
            riskChecker.setMaxLongExposure(perpMarketConfig, perpMarket, 5),
            riskChecker.setMaxShortExposure(perpMarketConfig, perpMarket, 5),
            riskChecker.setViolationBehaviour(perpMarketConfig, mango_risk_check_1.ViolationBehaviour.CancelIncreasingOrders)
        ]);
    }
    catch (error) {
        console.log(error);
    }
    console.log('Loaded!');
    const tokenIndex = mangoGroup.getTokenIndex(token.mintKey);
    let [tokenPrice, tokenPriceLastUpdated] = [
        mangoGroup.cachePriceToUi(mangoCache.getPrice(tokenIndex), tokenIndex),
        new Date()
        // ^ The "last updated" timestamp for the cached token oracle price is
        // logged to check whether it hasn't updated in too long of a while
    ];
    mangoGroup.onCacheChange(connection, (mangoCache) => {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        [tokenPrice, tokenPriceLastUpdated] = [
            mangoGroup.cachePriceToUi(mangoCache.getPrice(tokenIndex), tokenIndex),
            new Date()
        ];
    });
    let recentFills = [];
    function listenToFills() {
        const ws = new ws_1.default(PERPS_FILLS_FEED);
        ws.onopen = event => {
            console.log('Fills feed connection is open!');
        };
        ws.onmessage = (message) => __awaiter(this, void 0, void 0, function* () {
            const data = JSON.parse(message.data.toString());
            // eslint-disable-next-line no-prototype-builtins
            const isSnapshot = data.hasOwnProperty('events');
            const parseEvent = (event) => layout_1.PerpEventLayout.decode(Buffer.from(event, 'base64'));
            if (isSnapshot) {
                return;
            }
            else {
                if (data.market.split('-')[0] !== SYMBOL) {
                    return;
                }
                const event = parseEvent(data.event);
                const fill = perpMarket.parseFillEvent(event.fill);
                if (!(fill.maker.equals(mangoAccountPk))) {
                    return;
                }
                const takerBase = perpMarket.baseLotsToNumber(mangoAccount.perpAccounts[perpMarketConfig.marketIndex].takerBase);
                const basePosition = perpMarket.baseLotsToNumber(mangoAccount.perpAccounts[perpMarketConfig.marketIndex].basePosition);
                const unprocessedFills = perpEventQueue.getUnconsumedEvents()
                    .filter(event => event.fill !== undefined)
                    .map(event => perpMarket.parseFillEvent(event.fill))
                    .filter(fill => fill.maker.equals(mangoAccount.publicKey));
                const queuedBasePosition = unprocessedFills
                    .reduce((accumulator, fill) => {
                    switch (fill.takerSide) {
                        case "buy":
                            return accumulator - fill.quantity;
                        case "sell":
                            return accumulator + fill.quantity;
                    }
                }, basePosition + takerBase);
                recentFills = [...recentFills, Object.assign(Object.assign({}, fill), { slot: data.slot })].filter(fill => fill.slot > slot);
                const completeBasePosition = queuedBasePosition + recentFills.reduce((accumulator, fill) => {
                    switch (fill.takerSide) {
                        case "buy":
                            return accumulator - fill.quantity;
                        case "sell":
                            return accumulator + fill.quantity;
                    }
                }, 0);
                console.log(unprocessedFills, recentFills, data.slot, slot, data.slot - slot, basePosition, takerBase, queuedBasePosition, completeBasePosition);
            }
        });
        ws.onclose = function (event) {
            console.log('Fills feed connection is closed. Reconnecting...', event.reason);
            listenToFills();
        };
        ws.onerror = (event) => {
            console.log(event);
            ws.close();
        };
    }
    listenToFills();
    const quote = () => __awaiter(void 0, void 0, void 0, function* () {
        // const spread = tokenPrice! * 0.0005
        const spread = 0.0005;
        const [bidPriceUi, bidSizeUi] = [tokenPrice - spread, 0.1];
        const [askPriceUi, askSizeUi] = [tokenPrice + spread, 0.1];
        const [bidPrice, bidSize] = perpMarket.uiToNativePriceQuantity(bidPriceUi, bidSizeUi);
        const [askPrice, askSize] = perpMarket.uiToNativePriceQuantity(askPriceUi, askSizeUi);
        const tx = new web3_js_1.Transaction({
            recentBlockhash: recentBlockHash.blockhash,
            feePayer: payer.publicKey
        });
        const timestamp = new bn_js_1.BN(Date.now());
        // Use different order IDs for both sides of the quote - inconsistent state
        // issues on the program side might happen if we tried to cancel order by ID
        // otherwise.
        const [bidId, askId] = [timestamp.add(new bn_js_1.BN(1)), timestamp];
        // ^ When using Time in Force orders, it's important to use *cluster time*
        // as it might drift from actual UNIX time every once and then, effectively
        // being different to what you'd get using Date.now().
        if (recentBlockTime === null) {
            console.log('Failed to fetch block time');
            return;
        }
        const expiryTimestamp = new bn_js_1.BN(recentBlockTime + 120);
        tx.add((0, instruction_1.makeCancelAllPerpOrdersInstruction)(mangoGroupConfig.mangoProgramId, mangoGroupConfig.publicKey, mangoAccount.publicKey, payer.publicKey, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, new bn_js_1.BN(4)), (0, instruction_1.makePlacePerpOrder2Instruction)(mangoGroupConfig.mangoProgramId, mangoGroupConfig.publicKey, mangoAccount.publicKey, payer.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, perpMarket.eventQueue, mangoAccount.getOpenOrdersKeysInBasket(), new bn_js_1.BN(bidPrice), new bn_js_1.BN(bidSize), utils_1.I64_MAX_BN, bidId, 'buy', new bn_js_1.BN(255), 'postOnlySlide', false, undefined, expiryTimestamp), (0, instruction_1.makePlacePerpOrder2Instruction)(mangoGroupConfig.mangoProgramId, mangoGroupConfig.publicKey, mangoAccount.publicKey, payer.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, perpMarket.eventQueue, mangoAccount.getOpenOrdersKeysInBasket(), new bn_js_1.BN(askPrice), new bn_js_1.BN(askSize), utils_1.I64_MAX_BN, askId, 'sell', new bn_js_1.BN(255), 'postOnlySlide', false, undefined, expiryTimestamp), riskChecker.makeCheckRiskInstruction(perpMarketConfig, perpMarket));
        tx.sign(payer);
        try {
            const response = yield mangoClient.sendSignedTransaction({
                signedTransaction: tx,
                signedAtBlock: recentBlockHash,
            });
            console.log('quote::response', response);
        }
        catch (error) {
            console.log('quote::error', error);
        }
    });
    console.log('First quoting in ' + (perf_hooks_1.performance.now() / 1e3).toFixed(2) + 's!');
    quote();
    setInterval(quote, 1500);
});
function createSpotOrder2Instruction(mangoClient, mangoGroup, mangoAccount, spotMarket, owner, side, price, size, orderType, 
// @ts-ignore
clientOrderId, useMsrmVault) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (!owner.publicKey) {
            return;
        }
        const limitPrice = spotMarket.priceNumberToLots(price);
        const maxBaseQuantity = spotMarket.baseSizeNumberToLots(size);
        // TODO implement srm vault fee discount
        // const feeTier = getFeeTier(0, nativeToUi(mangoGroup.nativeSrm || 0, SRM_DECIMALS));
        const feeTier = (0, serum_1.getFeeTier)(0, (0, utils_1.nativeToUi)(0, 0));
        const rates = (0, serum_1.getFeeRates)(feeTier);
        const maxQuoteQuantity = new bn_js_1.BN(spotMarket['_decoded'].quoteLotSize.toNumber() * (1 + rates.taker)).mul(spotMarket
            .baseSizeNumberToLots(size)
            .mul(spotMarket.priceNumberToLots(price)));
        if (maxBaseQuantity.lte(utils_1.ZERO_BN)) {
            throw new Error('size too small');
        }
        if (limitPrice.lte(utils_1.ZERO_BN)) {
            throw new Error('invalid price');
        }
        const selfTradeBehavior = 'decrementTake';
        const spotMarketIndex = mangoGroup.getSpotMarketIndex(spotMarket.publicKey);
        if (!mangoGroup.rootBankAccounts.filter((a) => !!a).length) {
            yield mangoGroup.loadRootBanks(mangoClient.connection);
        }
        let feeVault;
        if (useMsrmVault) {
            feeVault = mangoGroup.msrmVault;
        }
        else if (useMsrmVault === false) {
            feeVault = mangoGroup.srmVault;
        }
        else {
            const totalMsrm = yield mangoClient.connection.getTokenAccountBalance(mangoGroup.msrmVault);
            feeVault =
                ((_a = totalMsrm === null || totalMsrm === void 0 ? void 0 : totalMsrm.value) === null || _a === void 0 ? void 0 : _a.uiAmount) && totalMsrm.value.uiAmount > 0
                    ? mangoGroup.msrmVault
                    : mangoGroup.srmVault;
        }
        const baseRootBank = mangoGroup.rootBankAccounts[spotMarketIndex];
        const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];
        const quoteRootBank = mangoGroup.rootBankAccounts[layout_1.QUOTE_INDEX];
        const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];
        if (!baseRootBank || !baseNodeBank || !quoteRootBank || !quoteNodeBank) {
            throw new Error('Invalid or missing banks');
        }
        // Only pass in open orders if in margin basket or current market index, and
        // the only writable account should be OpenOrders for current market index
        const openOrdersKeys = (0, lodash_1.zip)(mangoAccount.spotOpenOrdersAccounts, (0, lodash_1.range)(0, mangoAccount.spotOpenOrdersAccounts.length))
            .filter(([openOrdersAccount, index]) => mangoAccount.inMarginBasket[index] || index == spotMarketIndex)
            .map(([openOrdersAccount, index]) => ({
            pubkey: openOrdersAccount.publicKey,
            isWritable: index == spotMarketIndex
        }));
        const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([
            spotMarket.publicKey.toBuffer(),
            spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8),
        ], spotMarket.programId);
        const placeOrderInstruction = (0, instruction_1.makePlaceSpotOrder2Instruction)(mangoClient.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoGroup.mangoCache, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, spotMarket['_decoded'].requestQueue, spotMarket['_decoded'].eventQueue, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, baseRootBank.publicKey, baseNodeBank.publicKey, baseNodeBank.vault, quoteRootBank.publicKey, quoteNodeBank.publicKey, quoteNodeBank.vault, mangoGroup.signerKey, dexSigner, feeVault, openOrdersKeys, side, limitPrice, maxBaseQuantity, maxQuoteQuantity, selfTradeBehavior, orderType, clientOrderId !== null && clientOrderId !== void 0 ? clientOrderId : new bn_js_1.BN(Date.now()));
        return placeOrderInstruction;
    });
}
main();
//# sourceMappingURL=serumExampleHedge.js.map