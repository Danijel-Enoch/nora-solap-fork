"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTokenAmountsFromLiquidity = exports.estimateLiquidityFromTokenAmounts = exports.toTokenAmount = void 0;
const anchor_1 = require("@project-serum/anchor");
const spl_token_1 = require("@solana/spl-token");
const decimal_js_1 = __importDefault(require("decimal.js"));
const _1 = require(".");
function toTokenAmount(a, b) {
    return {
        tokenA: new spl_token_1.u64(a.toString()),
        tokenB: new spl_token_1.u64(b.toString()),
    };
}
exports.toTokenAmount = toTokenAmount;
/**
 * Estimate the liquidity amount required to increase/decrease liquidity.
 *
 * // TODO: At the top end of the price range, tick calcuation is off therefore the results can be off
 *
 * @param currTick - Whirlpool's current tick index (aka price)
 * @param lowerTick - Position lower tick index
 * @param upperTick - Position upper tick index
 * @param tokenAmount - The desired amount of tokens to deposit/withdraw
 * @returns An estimated amount of liquidity needed to deposit/withdraw the desired amount of tokens.
 */
function estimateLiquidityFromTokenAmounts(currTick, lowerTick, upperTick, tokenAmount) {
    if (upperTick < lowerTick) {
        throw new Error("upper tick cannot be lower than the lower tick");
    }
    const currSqrtPrice = (0, _1.tickIndexToSqrtPriceX64)(currTick);
    const lowerSqrtPrice = (0, _1.tickIndexToSqrtPriceX64)(lowerTick);
    const upperSqrtPrice = (0, _1.tickIndexToSqrtPriceX64)(upperTick);
    if (currTick >= upperTick) {
        return estLiquidityForTokenB(upperSqrtPrice, lowerSqrtPrice, tokenAmount.tokenB);
    }
    else if (currTick < lowerTick) {
        return estLiquidityForTokenA(lowerSqrtPrice, upperSqrtPrice, tokenAmount.tokenA);
    }
    else {
        const estLiquidityAmountA = estLiquidityForTokenA(currSqrtPrice, upperSqrtPrice, tokenAmount.tokenA);
        const estLiquidityAmountB = estLiquidityForTokenB(currSqrtPrice, lowerSqrtPrice, tokenAmount.tokenB);
        return anchor_1.BN.min(estLiquidityAmountA, estLiquidityAmountB);
    }
}
exports.estimateLiquidityFromTokenAmounts = estimateLiquidityFromTokenAmounts;
function getTokenAmountsFromLiquidity(liquidity, currentPrice, lowerPrice, upperPrice, round_up) {
    const _liquidity = new decimal_js_1.default(liquidity.toString());
    const _currentPrice = new decimal_js_1.default(currentPrice.toString());
    const _lowerPrice = new decimal_js_1.default(lowerPrice.toString());
    const _upperPrice = new decimal_js_1.default(upperPrice.toString());
    let tokenA, tokenB;
    if (currentPrice.lt(lowerPrice)) {
        // x = L * (pb - pa) / (pa * pb)
        tokenA = (0, _1.toX64_Decimal)(_liquidity)
            .mul(_upperPrice.sub(_lowerPrice))
            .div(_lowerPrice.mul(_upperPrice));
        tokenB = new decimal_js_1.default(0);
    }
    else if (currentPrice.lt(upperPrice)) {
        // x = L * (pb - p) / (p * pb)
        // y = L * (p - pa)
        tokenA = (0, _1.toX64_Decimal)(_liquidity)
            .mul(_upperPrice.sub(_currentPrice))
            .div(_currentPrice.mul(_upperPrice));
        tokenB = (0, _1.fromX64_Decimal)(_liquidity.mul(_currentPrice.sub(_lowerPrice)));
    }
    else {
        // y = L * (pb - pa)
        tokenA = new decimal_js_1.default(0);
        tokenB = (0, _1.fromX64_Decimal)(_liquidity.mul(_upperPrice.sub(_lowerPrice)));
    }
    // TODO: round up
    if (round_up) {
        return {
            tokenA: new spl_token_1.u64(tokenA.ceil().toString()),
            tokenB: new spl_token_1.u64(tokenB.ceil().toString()),
        };
    }
    else {
        return {
            tokenA: new spl_token_1.u64(tokenA.floor().toString()),
            tokenB: new spl_token_1.u64(tokenB.floor().toString()),
        };
    }
}
exports.getTokenAmountsFromLiquidity = getTokenAmountsFromLiquidity;
// Convert this function based on Delta A = Delta L * (1/sqrt(lower) - 1/sqrt(upper))
function estLiquidityForTokenA(sqrtPrice1, sqrtPrice2, tokenAmount) {
    const lowerSqrtPriceX64 = anchor_1.BN.min(sqrtPrice1, sqrtPrice2);
    const upperSqrtPriceX64 = anchor_1.BN.max(sqrtPrice1, sqrtPrice2);
    const num = (0, _1.fromX64_BN)(tokenAmount.mul(upperSqrtPriceX64).mul(lowerSqrtPriceX64));
    const dem = upperSqrtPriceX64.sub(lowerSqrtPriceX64);
    return num.div(dem);
}
// Convert this function based on Delta B = Delta L * (sqrt_price(upper) - sqrt_price(lower))
function estLiquidityForTokenB(sqrtPrice1, sqrtPrice2, tokenAmount) {
    const lowerSqrtPriceX64 = anchor_1.BN.min(sqrtPrice1, sqrtPrice2);
    const upperSqrtPriceX64 = anchor_1.BN.max(sqrtPrice1, sqrtPrice2);
    const delta = upperSqrtPriceX64.sub(lowerSqrtPriceX64);
    return (0, _1.toX64_BN)(tokenAmount).div(delta);
}
