{"version":3,"file":"PendingTransaction.js","sourceRoot":"","sources":["../../../src/transaction/PendingTransaction.ts"],"names":[],"mappings":"AAMA,OAAO,YAAY,MAAM,eAAe,CAAC;AAGzC,OAAO,EAAE,kBAAkB,EAAE,MAAM,gBAAgB,CAAC;AAgBpD;;GAEG;AACH,MAAM,OAAO,kBAAkB;IAG7B,YACW,UAAsB,EACtB,SAA+B;QAD/B,eAAU,GAAV,UAAU,CAAY;QACtB,cAAS,GAAT,SAAS,CAAsB;QAJlC,aAAQ,GAA8B,IAAI,CAAC;IAKhD,CAAC;IAEJ;;;;OAIG;IACH,IAAI,OAAO;QACT,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,IAAI,CAAC,EACT,UAAU,GAAG,WAAW,EACxB,YAAY,GAAG,KAAK,EACpB,GAAG,SAAS,KACc,EAAE;QAC5B,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,OAAO,IAAI,CAAC,QAAQ,CAAC;SACtB;QACD,IAAI,YAAY,EAAE;YAChB,MAAM,IAAI,CAAC,0BAA0B,CAAC,UAAU,CAAC,CAAC;YAClD,OAAO,MAAM,IAAI,CAAC,cAAc,CAAC,EAAE,UAAU,EAAE,CAAC,CAAC;SAClD;QACD,OAAO,MAAM,IAAI,CAAC,cAAc,CAAC,EAAE,UAAU,EAAE,GAAG,SAAS,EAAE,CAAC,CAAC;IACjE,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,cAAc,CAAC,EACnB,UAAU,GAAG,WAAW,EACxB,GAAG,SAAS,KAIV,EAAE;QACJ,MAAM,OAAO,GAAG,MAAM,YAAY,CAChC,KAAK,EAAE,KAAK,EAAE,EAAE;YACd,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,SAAS,EAAE;gBAClE,UAAU;aACX,CAAC,CAAC;YACH,IAAI,CAAC,MAAM,EAAE;gBACX,KAAK,CAAC,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC,CAAC;gBAC/C,OAAO;aACR;YACD,OAAO,IAAI,kBAAkB,CAAC,IAAI,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;QACxD,CAAC,EACD;YACE,OAAO,EAAE,CAAC;YACV,UAAU,EAAE,GAAG;YACf,GAAG,SAAS;SACb,CACF,CAAC;QACF,IAAI,CAAC,OAAO,EAAE;YACZ,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;SACvD;QACD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,0BAA0B,CAC9B,aAAuB,WAAW;QAElC,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,kBAAkB,CACxD,IAAI,CAAC,SAAS,EACd,UAAU,CACX,CAAC;QACF,IAAI,KAAK,CAAC,GAAG,EAAE;YACb,MAAM,KAAK,CAAC,GAAG,CAAC;SACjB;QACD,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB,CAAC;IAED;;;;OAIG;IACH,0BAA0B,CAAC,UAAmB,cAAc;QAC1D,OAAO,kCAAkC,IAAI,CAAC,SAAS,YAAY,OAAO,EAAE,CAAC;IAC/E,CAAC;CACF","sourcesContent":["import type {\n  Cluster,\n  Connection,\n  Finality,\n  TransactionSignature,\n} from \"@solana/web3.js\";\nimport promiseRetry from \"promise-retry\";\nimport type { OperationOptions } from \"retry\";\n\nimport { TransactionReceipt } from \"../transaction\";\n\n/**\n * Options for awaiting a transaction confirmation.\n */\nexport interface TransactionWaitOptions extends OperationOptions {\n  /**\n   * Commitment of the transaction. Defaults to `confirmed`.\n   */\n  readonly commitment?: Finality;\n  /**\n   * Whether or not to use websockets for awaiting confirmation. Defaults to `false`.\n   */\n  readonly useWebsocket?: boolean;\n}\n\n/**\n * Transaction which may or may not be confirmed.\n */\nexport class PendingTransaction {\n  private _receipt: TransactionReceipt | null = null;\n\n  constructor(\n    readonly connection: Connection,\n    readonly signature: TransactionSignature\n  ) {}\n\n  /**\n   * Gets the transaction receipt, if it has already been fetched.\n   *\n   * You probably want the async version of this function, `wait`.\n   */\n  get receipt(): TransactionReceipt | null {\n    return this._receipt;\n  }\n\n  /**\n   * Waits for the confirmation of the transaction, via polling.\n   * @returns\n   */\n  async wait({\n    commitment = \"confirmed\",\n    useWebsocket = false,\n    ...retryOpts\n  }: TransactionWaitOptions = {}): Promise<TransactionReceipt> {\n    if (this._receipt) {\n      return this._receipt;\n    }\n    if (useWebsocket) {\n      await this.awaitSignatureConfirmation(commitment);\n      return await this.pollForReceipt({ commitment });\n    }\n    return await this.pollForReceipt({ commitment, ...retryOpts });\n  }\n\n  /**\n   * Fetches the TransactionReceipt via polling.\n   * @returns\n   */\n  async pollForReceipt({\n    commitment = \"confirmed\",\n    ...retryOpts\n  }: Omit<\n    TransactionWaitOptions,\n    \"useWebsocket\"\n  > = {}): Promise<TransactionReceipt> {\n    const receipt = await promiseRetry(\n      async (retry) => {\n        const result = await this.connection.getTransaction(this.signature, {\n          commitment,\n        });\n        if (!result) {\n          retry(new Error(\"Error fetching transaction\"));\n          return;\n        }\n        return new TransactionReceipt(this.signature, result);\n      },\n      {\n        retries: 5,\n        minTimeout: 500,\n        ...retryOpts,\n      }\n    );\n    if (!receipt) {\n      throw new Error(\"transaction could not be confirmed\");\n    }\n    this._receipt = receipt;\n    return receipt;\n  }\n\n  /**\n   * Awaits the confirmation of the transaction, via onSignature subscription.\n   * @returns\n   */\n  async awaitSignatureConfirmation(\n    commitment: Finality = \"confirmed\"\n  ): Promise<TransactionSignature> {\n    const { value } = await this.connection.confirmTransaction(\n      this.signature,\n      commitment\n    );\n    if (value.err) {\n      throw value.err;\n    }\n    return this.signature;\n  }\n\n  /**\n   * Generates a link to view this {@link PendingTransaction} on the official Solana explorer.\n   * @param network\n   * @returns\n   */\n  generateSolanaExplorerLink(cluster: Cluster = \"mainnet-beta\"): string {\n    return `https://explorer.solana.com/tx/${this.signature}?cluster=${cluster}`;\n  }\n}\n"]}