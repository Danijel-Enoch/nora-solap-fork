{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/transaction/utils.ts"],"names":[],"mappings":"AAKA,OAAO,EAAE,SAAS,EAAE,WAAW,EAAE,MAAM,iBAAiB,CAAC;AAWzD;;GAEG;AACH,MAAM,CAAC,MAAM,qBAAqB,GAChC,8CAA8C,CAAC;AAEjD;;;;;;;GAOG;AACH,MAAM,CAAC,MAAM,uBAAuB,GAAG,CACrC,OAAgB,EAChB,GAA6B,EAChB,EAAE;IACf,MAAM,EAAE,GAAG,IAAI,WAAW,EAAE,CAAC;IAC7B,EAAE,CAAC,eAAe,GAAG,qBAAqB,CAAC;IAE3C,6CAA6C;IAC7C,EAAE,CAAC,QAAQ;QACT,OAAO,KAAK,QAAQ;YAClB,CAAC,CAAC,IAAI,SAAS,CAAC,8CAA8C,CAAC;YAC/D,CAAC,CAAC,IAAI,SAAS,CAAC,8CAA8C,CAAC,CAAC;IACpE,EAAE,CAAC,YAAY,GAAG,GAAG,CAAC;IACtB,OAAO,EAAE,CAAC;AACZ,CAAC,CAAC;AAEF;;;;GAIG;AACH,MAAM,CAAC,MAAM,0BAA0B,GAAG,CAAC,EAAe,EAAU,EAAE,CACpE,EAAE;KACC,SAAS,CAAC;IACT,oBAAoB,EAAE,KAAK;IAC3B,gBAAgB,EAAE,KAAK;CACxB,CAAC;KACD,QAAQ,CAAC,QAAQ,CAAC,CAAC;AAExB;;;;GAIG;AACH,MAAM,CAAC,MAAM,6BAA6B,GAAG,CAC3C,OAAgB,EAChB,QAAgB,EACR,EAAE;IACV,OAAO,WACL,OAAO,KAAK,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,OAAO,GAC9C,kCAAkC,kBAAkB,CAAC,QAAQ,CAAC,EAAE,CAAC;AACnE,CAAC,CAAC;AAEF;;;;;GAKG;AACH,MAAM,CAAC,MAAM,4BAA4B,GAAG,CAC1C,OAAgB,EAChB,EAAe,EACP,EAAE;IACV,OAAO,6BAA6B,CAAC,OAAO,EAAE,0BAA0B,CAAC,EAAE,CAAC,CAAC,CAAC;AAChF,CAAC,CAAC","sourcesContent":["import type {\n  AccountMeta,\n  Cluster,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { PublicKey, Transaction } from \"@solana/web3.js\";\n\n/**\n * Instruction that can be serialized to JSON.\n */\nexport interface SerializableInstruction {\n  programId: string;\n  keys: (Omit<AccountMeta, \"pubkey\"> & { publicKey: string })[];\n  data: string;\n}\n\n/**\n * Stub of a recent blockhash that can be used to simulate transactions.\n */\nexport const RECENT_BLOCKHASH_STUB =\n  \"GfVcyD4kkTrj4bKc7WA9sZCin9JDbdT4Zkd3EittNR1W\";\n\n/**\n * Builds a transaction with a fake `recentBlockhash` and `feePayer` for the purpose\n * of simulating a sequence of instructions.\n *\n * @param cluster\n * @param ixs\n * @returns\n */\nexport const buildStubbedTransaction = (\n  cluster: Cluster,\n  ixs: TransactionInstruction[]\n): Transaction => {\n  const tx = new Transaction();\n  tx.recentBlockhash = RECENT_BLOCKHASH_STUB;\n\n  // random keys that always have money in them\n  tx.feePayer =\n    cluster === \"devnet\"\n      ? new PublicKey(\"A2jaCHPzD6346348JoEym2KFGX9A7uRBw6AhCdX7gTWP\")\n      : new PublicKey(\"9u9iZBWqGsp5hXBxkVZtBTuLSGNAG9gEQLgpuVw39ASg\");\n  tx.instructions = ixs;\n  return tx;\n};\n\n/**\n * Serializes a {@link Transaction} to base64 format without checking signatures.\n * @param tx\n * @returns\n */\nexport const serializeToBase64Unchecked = (tx: Transaction): string =>\n  tx\n    .serialize({\n      requireAllSignatures: false,\n      verifySignatures: false,\n    })\n    .toString(\"base64\");\n\n/**\n * Generates a link for inspecting the contents of a transaction.\n *\n * @returns URL\n */\nexport const generateInspectLinkFromBase64 = (\n  cluster: Cluster,\n  base64TX: string\n): string => {\n  return `https://${\n    cluster === \"mainnet-beta\" ? \"\" : `${cluster}.`\n  }anchor.so/tx/inspector?message=${encodeURIComponent(base64TX)}`;\n};\n\n/**\n * Generates a link for inspecting the contents of a transaction, not checking for\n * or requiring valid signatures.\n *\n * @returns URL\n */\nexport const generateUncheckedInspectLink = (\n  cluster: Cluster,\n  tx: Transaction\n): string => {\n  return generateInspectLinkFromBase64(cluster, serializeToBase64Unchecked(tx));\n};\n"]}