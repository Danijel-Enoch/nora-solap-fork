{"version":3,"file":"broadcaster.js","sourceRoot":"","sources":["../../src/broadcaster.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  Blockhash,\n  Commitment,\n  ConfirmOptions,\n  Connection,\n  RpcResponseAndContext,\n  SendOptions,\n  SimulatedTransactionResponse,\n  Transaction,\n} from \"@solana/web3.js\";\n\nimport { firstAggregateError } from \"./error\";\nimport type { Broadcaster } from \"./interfaces\";\nimport { DEFAULT_PROVIDER_OPTIONS } from \"./provider\";\nimport { PendingTransaction } from \"./transaction\";\nimport { suppressConsoleErrorAsync } from \"./utils\";\nimport { simulateTransactionWithCommitment } from \"./utils/simulateTransactionWithCommitment\";\n\nexport interface BroadcastOptions extends ConfirmOptions {\n  /**\n   * Prints the transaction logs as emitted by @solana/web3.js. Defaults to true.\n   */\n  printLogs?: boolean;\n}\n\n/**\n * Broadcasts transactions to a single connection.\n */\nexport class SingleConnectionBroadcaster implements Broadcaster {\n  constructor(\n    readonly sendConnection: Connection,\n    readonly opts: ConfirmOptions = DEFAULT_PROVIDER_OPTIONS\n  ) {}\n\n  /**\n   * @inheritdoc\n   */\n  async getRecentBlockhash(\n    commitment: Commitment = this.opts.commitment ?? \"confirmed\"\n  ): Promise<Blockhash> {\n    const result = await this.sendConnection.getLatestBlockhash(commitment);\n    return result.blockhash;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async broadcast(\n    tx: Transaction,\n    { printLogs = true, ...opts }: BroadcastOptions = this.opts\n  ): Promise<PendingTransaction> {\n    if (tx.signatures.length === 0) {\n      throw new Error(\"Transaction must be signed before broadcasting.\");\n    }\n    const rawTx = tx.serialize();\n\n    if (printLogs) {\n      return new PendingTransaction(\n        this.sendConnection,\n        await this.sendConnection.sendRawTransaction(rawTx, opts)\n      );\n    }\n\n    return await suppressConsoleErrorAsync(async () => {\n      // hide the logs of TX errors if printLogs = false\n      return new PendingTransaction(\n        this.sendConnection,\n        await this.sendConnection.sendRawTransaction(rawTx, opts)\n      );\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async simulate(\n    tx: Transaction,\n    {\n      commitment = this.opts.preflightCommitment ?? \"confirmed\",\n      verifySigners = true,\n    }: {\n      commitment?: Commitment;\n      verifySigners?: boolean;\n    } = {\n      commitment: this.opts.preflightCommitment ?? \"confirmed\",\n      verifySigners: true,\n    }\n  ): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n    if (verifySigners && tx.signatures.length === 0) {\n      throw new Error(\"Transaction must be signed before simulating.\");\n    }\n    return await simulateTransactionWithCommitment(\n      this.sendConnection,\n      tx,\n      commitment\n    );\n  }\n}\n\n/**\n * Broadcasts transactions to multiple connections simultaneously.\n */\nexport class MultipleConnectionBroadcaster implements Broadcaster {\n  constructor(\n    readonly connections: readonly Connection[],\n    readonly opts: ConfirmOptions = DEFAULT_PROVIDER_OPTIONS\n  ) {}\n\n  async getRecentBlockhash(\n    commitment: Commitment = this.opts.preflightCommitment ?? \"confirmed\"\n  ): Promise<Blockhash> {\n    try {\n      const result = await Promise.any(\n        this.connections.map((conn) => conn.getLatestBlockhash(commitment))\n      );\n      return result.blockhash;\n    } catch (e) {\n      if (e instanceof AggregateError) {\n        throw firstAggregateError(e);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  private async _sendRawTransaction(\n    encoded: Buffer,\n    options?: SendOptions\n  ): Promise<PendingTransaction> {\n    try {\n      return await Promise.any(\n        this.connections.map(async (connection) => {\n          return new PendingTransaction(\n            connection,\n            await connection.sendRawTransaction(encoded, options)\n          );\n        })\n      );\n    } catch (e) {\n      if (e instanceof AggregateError) {\n        throw firstAggregateError(e);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Broadcasts a signed transaction.\n   *\n   * @param tx\n   * @param confirm\n   * @param opts\n   * @returns\n   */\n  async broadcast(\n    tx: Transaction,\n    { printLogs = true, ...opts }: BroadcastOptions = this.opts\n  ): Promise<PendingTransaction> {\n    if (tx.signatures.length === 0) {\n      throw new Error(\"Transaction must be signed before broadcasting.\");\n    }\n    const rawTx = tx.serialize();\n\n    if (printLogs) {\n      return await this._sendRawTransaction(rawTx, opts);\n    }\n\n    return await suppressConsoleErrorAsync(async () => {\n      // hide the logs of TX errors if printLogs = false\n      return await this._sendRawTransaction(rawTx, opts);\n    });\n  }\n\n  /**\n   * Simulates a transaction with a commitment.\n   * @param tx\n   * @param commitment\n   * @returns\n   */\n  async simulate(\n    tx: Transaction,\n    {\n      commitment = this.opts.preflightCommitment ?? \"confirmed\",\n      verifySigners = true,\n    }: {\n      commitment?: Commitment;\n      verifySigners?: boolean;\n    } = {\n      commitment: this.opts.preflightCommitment ?? \"confirmed\",\n      verifySigners: true,\n    }\n  ): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n    if (verifySigners && tx.signatures.length === 0) {\n      throw new Error(\"Transaction must be signed before simulating.\");\n    }\n    try {\n      return await Promise.any(\n        this.connections.map(async (connection) => {\n          return await simulateTransactionWithCommitment(\n            connection,\n            tx,\n            commitment\n          );\n        })\n      );\n    } catch (e) {\n      if (e instanceof AggregateError) {\n        throw firstAggregateError(e);\n      } else {\n        throw e;\n      }\n    }\n  }\n}\n"]}