"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingTransaction = void 0;
const tslib_1 = require("tslib");
const promise_retry_1 = tslib_1.__importDefault(require("promise-retry"));
const transaction_1 = require("../transaction");
/**
 * Transaction which may or may not be confirmed.
 */
class PendingTransaction {
    constructor(connection, signature) {
        this.connection = connection;
        this.signature = signature;
        this._receipt = null;
    }
    /**
     * Gets the transaction receipt, if it has already been fetched.
     *
     * You probably want the async version of this function, `wait`.
     */
    get receipt() {
        return this._receipt;
    }
    /**
     * Waits for the confirmation of the transaction, via polling.
     * @returns
     */
    async wait({ commitment = "confirmed", useWebsocket = false, ...retryOpts } = {}) {
        if (this._receipt) {
            return this._receipt;
        }
        if (useWebsocket) {
            await this.awaitSignatureConfirmation(commitment);
            return await this.pollForReceipt({ commitment });
        }
        return await this.pollForReceipt({ commitment, ...retryOpts });
    }
    /**
     * Fetches the TransactionReceipt via polling.
     * @returns
     */
    async pollForReceipt({ commitment = "confirmed", ...retryOpts } = {}) {
        const receipt = await (0, promise_retry_1.default)(async (retry) => {
            const result = await this.connection.getTransaction(this.signature, {
                commitment,
            });
            if (!result) {
                retry(new Error("Error fetching transaction"));
                return;
            }
            return new transaction_1.TransactionReceipt(this.signature, result);
        }, {
            retries: 5,
            minTimeout: 500,
            ...retryOpts,
        });
        if (!receipt) {
            throw new Error("transaction could not be confirmed");
        }
        this._receipt = receipt;
        return receipt;
    }
    /**
     * Awaits the confirmation of the transaction, via onSignature subscription.
     * @returns
     */
    async awaitSignatureConfirmation(commitment = "confirmed") {
        const { value } = await this.connection.confirmTransaction(this.signature, commitment);
        if (value.err) {
            throw value.err;
        }
        return this.signature;
    }
    /**
     * Generates a link to view this {@link PendingTransaction} on the official Solana explorer.
     * @param network
     * @returns
     */
    generateSolanaExplorerLink(cluster = "mainnet-beta") {
        return `https://explorer.solana.com/tx/${this.signature}?cluster=${cluster}`;
    }
}
exports.PendingTransaction = PendingTransaction;
//# sourceMappingURL=PendingTransaction.js.map