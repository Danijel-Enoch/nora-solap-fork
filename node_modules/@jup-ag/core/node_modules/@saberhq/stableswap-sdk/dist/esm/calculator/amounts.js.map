{"version":3,"file":"amounts.js","sourceRoot":"","sources":["../../../src/calculator/amounts.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Token } from \"@saberhq/token-utils\";\nimport { Fraction, ONE, TokenAmount, ZERO } from \"@saberhq/token-utils\";\nimport JSBI from \"jsbi\";\nimport mapValues from \"lodash.mapvalues\";\n\nimport type { IExchangeInfo } from \"../entities/exchange\";\nimport type { Fees } from \"../state/fees\";\nimport { computeD, computeY } from \"./curve\";\n\n/**\n * Calculates the current virtual price of the exchange.\n * @param exchange\n * @returns\n */\nexport const calculateVirtualPrice = (\n  exchange: IExchangeInfo\n): Fraction | null => {\n  const amount = exchange.lpTotalSupply;\n  if (amount === undefined || amount.equalTo(0)) {\n    // pool has no tokens\n    return null;\n  }\n  const price = new Fraction(\n    computeD(\n      exchange.ampFactor,\n      exchange.reserves[0].amount.raw,\n      exchange.reserves[1].amount.raw\n    ),\n    amount.raw\n  );\n  return price;\n};\n\n/**\n * Calculates the estimated output amount of a swap.\n * @param exchange\n * @param fromAmount\n * @returns\n */\nexport const calculateEstimatedSwapOutputAmount = (\n  exchange: IExchangeInfo,\n  fromAmount: TokenAmount\n): {\n  [K in\n    | \"outputAmountBeforeFees\"\n    | \"outputAmount\"\n    | \"fee\"\n    | \"lpFee\"\n    | \"adminFee\"]: TokenAmount;\n} => {\n  const [fromReserves, toReserves] = fromAmount.token.equals(\n    exchange.reserves[0].amount.token\n  )\n    ? [exchange.reserves[0], exchange.reserves[1]]\n    : [exchange.reserves[1], exchange.reserves[0]];\n\n  if (fromAmount.equalTo(0)) {\n    const zero = new TokenAmount(toReserves.amount.token, ZERO);\n    return {\n      outputAmountBeforeFees: zero,\n      outputAmount: zero,\n      fee: zero,\n      lpFee: zero,\n      adminFee: zero,\n    };\n  }\n\n  const amp = exchange.ampFactor;\n\n  const amountBeforeFees = JSBI.subtract(\n    toReserves.amount.raw,\n    computeY(\n      amp,\n      JSBI.add(fromReserves.amount.raw, fromAmount.raw),\n      computeD(amp, fromReserves.amount.raw, toReserves.amount.raw)\n    )\n  );\n\n  const outputAmountBeforeFees = new TokenAmount(\n    toReserves.amount.token,\n    amountBeforeFees\n  );\n\n  const fee = new TokenAmount(\n    toReserves.amount.token,\n    exchange.fees.trade.asFraction.multiply(amountBeforeFees).toFixed(0)\n  );\n\n  const adminFee = new TokenAmount(\n    toReserves.amount.token,\n    exchange.fees.adminTrade.asFraction.multiply(fee.raw).toFixed(0)\n  );\n  const lpFee = fee.subtract(adminFee);\n\n  const outputAmount = new TokenAmount(\n    toReserves.amount.token,\n    JSBI.subtract(amountBeforeFees, fee.raw)\n  );\n\n  return {\n    outputAmountBeforeFees,\n    outputAmount,\n    fee: fee,\n    lpFee,\n    adminFee,\n  };\n};\n\nconst N_COINS = JSBI.BigInt(2);\n\nexport interface IWithdrawOneResult {\n  withdrawAmount: TokenAmount;\n  withdrawAmountBeforeFees: TokenAmount;\n  swapFee: TokenAmount;\n  withdrawFee: TokenAmount;\n  lpSwapFee: TokenAmount;\n  lpWithdrawFee: TokenAmount;\n  adminSwapFee: TokenAmount;\n  adminWithdrawFee: TokenAmount;\n}\n\n/**\n * Calculates the amount of tokens withdrawn if only withdrawing one token.\n * @returns\n */\nexport const calculateEstimatedWithdrawOneAmount = ({\n  exchange,\n  poolTokenAmount,\n  withdrawToken,\n}: {\n  exchange: IExchangeInfo;\n  poolTokenAmount: TokenAmount;\n  withdrawToken: Token;\n}): IWithdrawOneResult => {\n  if (poolTokenAmount.equalTo(0)) {\n    // final quantities\n    const quantities = {\n      withdrawAmount: ZERO,\n      withdrawAmountBeforeFees: ZERO,\n      swapFee: ZERO,\n      withdrawFee: ZERO,\n      lpSwapFee: ZERO,\n      lpWithdrawFee: ZERO,\n      adminSwapFee: ZERO,\n      adminWithdrawFee: ZERO,\n    };\n    return mapValues(quantities, (q) => new TokenAmount(withdrawToken, q));\n  }\n\n  const { ampFactor, fees } = exchange;\n\n  const [baseReserves, quoteReserves] = [\n    exchange.reserves.find((r) => r.amount.token.equals(withdrawToken))?.amount\n      .raw ?? ZERO,\n    exchange.reserves.find((r) => !r.amount.token.equals(withdrawToken))?.amount\n      .raw ?? ZERO,\n  ];\n\n  const d_0 = computeD(ampFactor, baseReserves, quoteReserves);\n  const d_1 = JSBI.subtract(\n    d_0,\n    JSBI.divide(\n      JSBI.multiply(poolTokenAmount.raw, d_0),\n      exchange.lpTotalSupply.raw\n    )\n  );\n\n  const new_y = computeY(ampFactor, quoteReserves, d_1);\n\n  // expected_base_amount = swap_base_amount * d_1 / d_0 - new_y;\n  const expected_base_amount = JSBI.subtract(\n    JSBI.divide(JSBI.multiply(baseReserves, d_1), d_0),\n    new_y\n  );\n  // expected_quote_amount = swap_quote_amount - swap_quote_amount * d_1 / d_0;\n  const expected_quote_amount = JSBI.subtract(\n    quoteReserves,\n    JSBI.divide(JSBI.multiply(quoteReserves, d_1), d_0)\n  );\n  // new_base_amount = swap_base_amount - expected_base_amount * fee / fee_denominator;\n  const new_base_amount = new Fraction(baseReserves.toString(), 1).subtract(\n    normalizedTradeFee(fees, N_COINS, expected_base_amount)\n  );\n  // new_quote_amount = swap_quote_amount - expected_quote_amount * fee / fee_denominator;\n  const new_quote_amount = new Fraction(quoteReserves.toString(), 1).subtract(\n    normalizedTradeFee(fees, N_COINS, expected_quote_amount)\n  );\n  const dy = new_base_amount.subtract(\n    computeY(\n      ampFactor,\n      JSBI.BigInt(new_quote_amount.toFixed(0)),\n      d_1\n    ).toString()\n  );\n  const dy_0 = JSBI.subtract(baseReserves, new_y);\n\n  // lp fees\n  const swapFee = new Fraction(dy_0.toString(), 1).subtract(dy);\n  const withdrawFee = dy.multiply(fees.withdraw.asFraction);\n\n  // admin fees\n  const adminSwapFee = swapFee.multiply(fees.adminTrade.asFraction);\n  const adminWithdrawFee = withdrawFee.multiply(fees.adminWithdraw.asFraction);\n\n  // final LP fees\n  const lpSwapFee = swapFee.subtract(adminSwapFee);\n  const lpWithdrawFee = withdrawFee.subtract(adminWithdrawFee);\n\n  // final withdraw amount\n  const withdrawAmount = dy.subtract(withdrawFee).subtract(swapFee);\n\n  // final quantities\n  const quantities = {\n    withdrawAmount,\n    withdrawAmountBeforeFees: dy,\n    swapFee,\n    withdrawFee,\n    lpSwapFee,\n    lpWithdrawFee,\n    adminSwapFee,\n    adminWithdrawFee,\n  };\n\n  return mapValues(\n    quantities,\n    (q) => new TokenAmount(withdrawToken, q.toFixed(0))\n  );\n};\n\n/**\n * Compute normalized fee for symmetric/asymmetric deposits/withdraws\n */\nexport const normalizedTradeFee = (\n  { trade }: Fees,\n  n_coins: JSBI,\n  amount: JSBI\n): Fraction => {\n  const adjustedTradeFee = new Fraction(\n    n_coins,\n    JSBI.multiply(JSBI.subtract(n_coins, ONE), JSBI.BigInt(4))\n  );\n  return new Fraction(amount, 1).multiply(trade).multiply(adjustedTradeFee);\n};\n\nexport const calculateEstimatedWithdrawAmount = ({\n  poolTokenAmount,\n  reserves,\n  fees,\n  lpTotalSupply,\n}: {\n  /**\n   * Amount of pool tokens to withdraw\n   */\n  poolTokenAmount: TokenAmount;\n} & Pick<IExchangeInfo, \"reserves\" | \"lpTotalSupply\" | \"fees\">): {\n  withdrawAmounts: readonly [TokenAmount, TokenAmount];\n  withdrawAmountsBeforeFees: readonly [TokenAmount, TokenAmount];\n  fees: readonly [TokenAmount, TokenAmount];\n} => {\n  if (lpTotalSupply.equalTo(0)) {\n    const zero = reserves.map((r) => new TokenAmount(r.amount.token, ZERO)) as [\n      TokenAmount,\n      TokenAmount\n    ];\n    return {\n      withdrawAmounts: zero,\n      withdrawAmountsBeforeFees: zero,\n      fees: zero,\n    };\n  }\n\n  const share = poolTokenAmount.divide(lpTotalSupply);\n\n  const withdrawAmounts = reserves.map(({ amount }) => {\n    const baseAmount = share.multiply(amount.raw);\n    const fee = baseAmount.multiply(fees.withdraw.asFraction);\n    return [\n      new TokenAmount(\n        amount.token,\n        JSBI.BigInt(baseAmount.subtract(fee).toFixed(0))\n      ),\n      {\n        beforeFees: JSBI.BigInt(baseAmount.toFixed(0)),\n        fee: JSBI.BigInt(fee.toFixed(0)),\n      },\n    ];\n  }) as [\n    [TokenAmount, { beforeFees: JSBI; fee: JSBI }],\n    [TokenAmount, { beforeFees: JSBI; fee: JSBI }]\n  ];\n\n  return {\n    withdrawAmountsBeforeFees: withdrawAmounts.map(\n      ([amt, { beforeFees }]) => new TokenAmount(amt.token, beforeFees)\n    ) as [TokenAmount, TokenAmount],\n    withdrawAmounts: [withdrawAmounts[0][0], withdrawAmounts[1][0]],\n    fees: withdrawAmounts.map(\n      ([amt, { fee }]) => new TokenAmount(amt.token, fee)\n    ) as [TokenAmount, TokenAmount],\n  };\n};\n\n/**\n * Calculate the estimated amount of LP tokens minted after a deposit.\n * @param exchange\n * @param depositAmountA\n * @param depositAmountB\n * @returns\n */\nexport const calculateEstimatedMintAmount = (\n  exchange: IExchangeInfo,\n  depositAmountA: JSBI,\n  depositAmountB: JSBI\n): {\n  mintAmountBeforeFees: TokenAmount;\n  mintAmount: TokenAmount;\n  fees: TokenAmount;\n} => {\n  if (JSBI.equal(depositAmountA, ZERO) && JSBI.equal(depositAmountB, ZERO)) {\n    const zero = new TokenAmount(exchange.lpTotalSupply.token, ZERO);\n    return {\n      mintAmountBeforeFees: zero,\n      mintAmount: zero,\n      fees: zero,\n    };\n  }\n\n  const amp = exchange.ampFactor;\n  const [reserveA, reserveB] = exchange.reserves;\n  const d0 = computeD(amp, reserveA.amount.raw, reserveB.amount.raw);\n\n  const d1 = computeD(\n    amp,\n    JSBI.add(reserveA.amount.raw, depositAmountA),\n    JSBI.add(reserveB.amount.raw, depositAmountB)\n  );\n  if (JSBI.lessThan(d1, d0)) {\n    throw new Error(\"New D cannot be less than previous D\");\n  }\n\n  const oldBalances = exchange.reserves.map((r) => r.amount.raw) as [\n    JSBI,\n    JSBI\n  ];\n  const newBalances = [\n    JSBI.add(reserveA.amount.raw, depositAmountA),\n    JSBI.add(reserveB.amount.raw, depositAmountB),\n  ] as const;\n  const adjustedBalances = newBalances.map((newBalance, i) => {\n    const oldBalance = oldBalances[i] as JSBI;\n    const idealBalance = new Fraction(d1, d0).multiply(oldBalance);\n    const difference = idealBalance.subtract(newBalance);\n    const diffAbs = difference.greaterThan(0)\n      ? difference\n      : difference.multiply(-1);\n    const fee = normalizedTradeFee(\n      exchange.fees,\n      N_COINS,\n      JSBI.BigInt(diffAbs.toFixed(0))\n    );\n    return JSBI.subtract(newBalance, JSBI.BigInt(fee.toFixed(0)));\n  }) as [JSBI, JSBI];\n  const d2 = computeD(amp, adjustedBalances[0], adjustedBalances[1]);\n\n  const lpSupply = exchange.lpTotalSupply;\n  const mintAmountRaw = JSBI.divide(\n    JSBI.multiply(lpSupply.raw, JSBI.subtract(d2, d0)),\n    d0\n  );\n\n  const mintAmount = new TokenAmount(\n    exchange.lpTotalSupply.token,\n    mintAmountRaw\n  );\n\n  const mintAmountRawBeforeFees = JSBI.divide(\n    JSBI.multiply(lpSupply.raw, JSBI.subtract(d1, d0)),\n    d0\n  );\n\n  const fees = new TokenAmount(\n    exchange.lpTotalSupply.token,\n    JSBI.subtract(mintAmountRawBeforeFees, mintAmountRaw)\n  );\n  const mintAmountBeforeFees = new TokenAmount(\n    exchange.lpTotalSupply.token,\n    mintAmountRawBeforeFees\n  );\n\n  return {\n    mintAmount,\n    mintAmountBeforeFees,\n    fees,\n  };\n};\n"]}