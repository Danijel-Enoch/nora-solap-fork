{"version":3,"file":"events.js","sourceRoot":"","sources":["../../src/events.ts"],"names":[],"mappings":";;;AAAA,sDAA2C;AAU3C,MAAM,SAAS,GAAG,CAAC,GAAY,EAAmB,EAAE,CAClD,CAAC,GAAG,IAAI,GAAG,KAAK,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,iBAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC;AAE1E,MAAM,aAAa,GAAG,CAAC,IAAY,EAAE,GAAW,EAAmB,EAAE;IACnE,MAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAC5D,OAAO,MAAM,CAAC,OAAO,CAAC;QACpB,IAAI;QACJ,YAAY,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QACjC,YAAY,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QACjC,eAAe,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QACpC,GAAG,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACzB,CAAC;SACC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;SACtB,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAoB,CAAC;AAC1E,CAAC,CAAC;AAEF;;;;GAIG;AACI,MAAM,cAAc,GAAG,CAC5B,WAA6B,EACD,EAAE;IAC9B,IAAI,CAAC,WAAW,EAAE;QAChB,OAAO,EAAE,CAAC;KACX;IACD,OAAO,WAAW,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,UAAU,EAAE,CAAC,EAAE,EAAE;QAC/C,MAAM,OAAO,GAAG,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QACnC,OAAO,UAAU,CAAC,UAAU,CAAC,sBAAsB,CAAC,IAAI,OAAO;YAC7D,CAAC,CAAC;gBACE,GAAG,GAAG;gBACN,aAAa,CACX,UAAU,CAAC,KAAK,CAAC,sBAAsB,CAAC,MAAM,CAAC,EAC/C,OAAO,CACR;aACF;YACH,CAAC,CAAC,GAAG,CAAC;IACV,CAAC,EAAE,EAAuB,CAAC,CAAC;AAC9B,CAAC,CAAC;AAlBW,QAAA,cAAc,kBAkBzB","sourcesContent":["import { u64 } from \"@saberhq/token-utils\";\n\nexport interface StableSwapEvent {\n  type: string;\n  tokenAAmount?: u64;\n  tokenBAmount?: u64;\n  poolTokenAmount?: u64;\n  fee?: u64;\n}\n\nconst parseUint = (str?: string): u64 | undefined =>\n  !str || str === \"0x0\" ? undefined : new u64(str.slice(\"0x\".length), 16);\n\nconst parseEventRaw = (type: string, msg: string): StableSwapEvent => {\n  const parts = msg.slice(\"Program log: \".length).split(\", \");\n  return Object.entries({\n    type,\n    tokenAAmount: parseUint(parts[1]),\n    tokenBAmount: parseUint(parts[2]),\n    poolTokenAmount: parseUint(parts[3]),\n    fee: parseUint(parts[4]),\n  })\n    .filter(([, v]) => !!v)\n    .reduce((acc, [k, v]) => ({ ...acc, [k]: v }), {}) as StableSwapEvent;\n};\n\n/**\n * Parses the log message to return the StableSwap info about the transaction.\n * @param logMessages\n * @returns\n */\nexport const parseEventLogs = (\n  logMessages?: string[] | null\n): readonly StableSwapEvent[] => {\n  if (!logMessages) {\n    return [];\n  }\n  return logMessages.reduce((acc, logMessage, i) => {\n    const nextLog = logMessages[i + 1];\n    return logMessage.startsWith(\"Program log: Event: \") && nextLog\n      ? [\n          ...acc,\n          parseEventRaw(\n            logMessage.slice(\"Program log: Event: \".length),\n            nextLog\n          ),\n        ]\n      : acc;\n  }, [] as StableSwapEvent[]);\n};\n"]}