{"version":3,"file":"initialize.js","sourceRoot":"","sources":["../../../src/util/initialize.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Provider } from \"@saberhq/solana-contrib\";\nimport { TransactionEnvelope } from \"@saberhq/solana-contrib\";\nimport {\n  createInitMintInstructions,\n  createTokenAccount,\n  getOrCreateATA,\n  SPLToken,\n  TOKEN_PROGRAM_ID,\n  u64,\n} from \"@saberhq/token-utils\";\nimport type {\n  Signer,\n  TransactionInstruction,\n  TransactionSignature,\n} from \"@solana/web3.js\";\nimport { Keypair, PublicKey, SystemProgram } from \"@solana/web3.js\";\n\nimport { SWAP_PROGRAM_ID, ZERO_TS } from \"../constants\";\nimport type {\n  InitializeSwapInstruction,\n  SwapTokenInfo,\n} from \"../instructions/swap\";\nimport { initializeSwapInstruction as createInitializeStableSwapInstruction } from \"../instructions/swap\";\nimport { findSwapAuthorityKey, StableSwap } from \"../stable-swap\";\nimport { ZERO_FEES } from \"../state/fees\";\nimport { StableSwapLayout } from \"../state/layout\";\nimport type { TransactionInstructions } from \"./instructions\";\nimport {\n  createMutableTransactionInstructions,\n  mergeInstructions,\n} from \"./instructions\";\n\nexport type ISeedPoolAccountsFn = (args: {\n  tokenAAccount: PublicKey;\n  tokenBAccount: PublicKey;\n}) => TransactionInstructions;\n\n/**\n * Arguments used to initialize a new swap.\n */\nexport interface InitializeNewStableSwapArgs\n  extends Pick<\n    InitializeSwapInstruction,\n    \"adminAccount\" | \"ampFactor\" | \"fees\"\n  > {\n  provider: Provider;\n  swapProgramID: PublicKey;\n\n  tokenAMint: PublicKey;\n  tokenBMint: PublicKey;\n\n  /**\n   * The owner of the account for the initial LP tokens to go to.\n   * Defaults to the admin account.\n   */\n  initialLiquidityProvider?: PublicKey;\n  /**\n   * If true, create an associated account for the initial LP.\n   */\n  useAssociatedAccountForInitialLP?: boolean;\n\n  /**\n   * The signer for the pool's account. If unspecified, a new one is generated.\n   */\n  swapAccountSigner?: Signer;\n  /**\n   * The mint for the pool token. If unspecified, a new one is generated.\n   */\n  poolTokenMintSigner?: Signer;\n\n  /**\n   * Instructions to seed the pool accounts.\n   */\n  seedPoolAccounts: ISeedPoolAccountsFn;\n}\n\n/**\n * Initializes a new StableSwap pool with a payer and stableSwapAccount.\n *\n * If you want to use a non-filesystem wallet as a payer, you'll want to generate\n * this transaction using StableSwap.createInitializeStableSwapTransaction\n * then sign it using the wallet directly.\n */\nexport const initializeStableSwap = async (\n  provider: Provider,\n  stableSwapAccount: Signer,\n  initializeSwapInstruction: InitializeSwapInstruction\n): Promise<StableSwap> => {\n  if (\n    !stableSwapAccount.publicKey.equals(\n      initializeSwapInstruction.config.swapAccount\n    )\n  ) {\n    throw new Error(\"stable swap public key\");\n  }\n\n  const { instructions } = await createInitializeStableSwapInstructionsRaw({\n    provider,\n    initializeSwapInstruction,\n  });\n  const tx = new TransactionEnvelope(provider, instructions.slice());\n\n  console.log(\"createAccount and InitializeSwap\");\n  const txSig = (await tx.confirm()).signature;\n  console.log(`TxSig: ${txSig}`);\n\n  return loadSwapFromInitializeArgs(initializeSwapInstruction);\n};\n\n/**\n * Creates a new instance of StableSwap from create args.\n * @param connection\n * @param initializeArgs\n * @returns\n */\nexport const loadSwapFromInitializeArgs = (\n  initializeArgs: InitializeSwapInstruction\n): StableSwap =>\n  new StableSwap(initializeArgs.config, {\n    isInitialized: true,\n    nonce: initializeArgs.nonce,\n    futureAdminDeadline: ZERO_TS,\n    futureAdminAccount: PublicKey.default,\n    adminAccount: initializeArgs.adminAccount,\n\n    tokenA: initializeArgs.tokenA,\n    tokenB: initializeArgs.tokenB,\n\n    poolTokenMint: initializeArgs.poolTokenMint,\n    initialAmpFactor: new u64(initializeArgs.ampFactor),\n    isPaused: initializeArgs.isPaused ?? false,\n    targetAmpFactor: new u64(initializeArgs.ampFactor),\n    startRampTimestamp: ZERO_TS,\n    stopRampTimestamp: ZERO_TS,\n    fees: initializeArgs.fees ?? ZERO_FEES,\n  });\n\n/**\n * Creates a set of instructions to create a new StableSwap instance.\n *\n * After calling this, you must sign this transaction with the accounts:\n * - payer -- Account that holds the SOL to seed the account.\n * - args.config.stableSwapAccount -- This account is used once then its key is no longer relevant\n * - all returned signers\n */\nexport const createInitializeStableSwapInstructions = async ({\n  provider,\n  swapProgramID = SWAP_PROGRAM_ID,\n  adminAccount,\n  tokenAMint,\n  tokenBMint,\n  ampFactor,\n  fees,\n\n  initialLiquidityProvider = adminAccount,\n  useAssociatedAccountForInitialLP,\n  swapAccountSigner = Keypair.generate(),\n  poolTokenMintSigner = Keypair.generate(),\n  seedPoolAccounts,\n}: InitializeNewStableSwapArgs): Promise<{\n  initializeArgs: InitializeSwapInstruction;\n  /**\n   * Lamports needed to be rent exempt.\n   */\n  balanceNeeded: number;\n\n  instructions: {\n    /**\n     * Create accounts for the LP token\n     */\n    createLPTokenMint: TransactionInstructions;\n    /**\n     * Create LP token account for the initial LP\n     */\n    createInitialLPTokenAccount: TransactionInstructions;\n    /**\n     * Create accounts for swap token A\n     */\n    createSwapTokenAAccounts: TransactionInstructions;\n    /**\n     * Create accounts for swap token B\n     */\n    createSwapTokenBAccounts: TransactionInstructions;\n    /**\n     * Seed the accounts for the pool\n     */\n    seedPoolAccounts: TransactionInstructions;\n    /**\n     * Initialize the swap\n     */\n    initializeSwap: TransactionInstructions;\n  };\n}> => {\n  const instructions = {\n    createLPTokenMint: new TransactionEnvelope(provider, []),\n    createInitialLPTokenAccount: new TransactionEnvelope(provider, []),\n    createSwapTokenAAccounts: new TransactionEnvelope(provider, []),\n    createSwapTokenBAccounts: new TransactionEnvelope(provider, []),\n    seedPoolAccounts: createMutableTransactionInstructions(),\n    initializeSwap: createMutableTransactionInstructions(),\n  };\n\n  // Create swap account if not specified\n  const swapAccount = swapAccountSigner.publicKey;\n  instructions.initializeSwap.signers.push(swapAccountSigner);\n\n  // Create authority and nonce\n  const [authority, nonce] = await findSwapAuthorityKey(\n    swapAccount,\n    swapProgramID\n  );\n\n  // Create LP token mint\n  const { decimals } = await new SPLToken(\n    provider.connection,\n    tokenAMint,\n    TOKEN_PROGRAM_ID,\n    Keypair.generate()\n  ).getMintInfo();\n  const mintBalanceNeeded = await SPLToken.getMinBalanceRentForExemptMint(\n    provider.connection\n  );\n  instructions.createLPTokenMint = await createInitMintInstructions({\n    provider,\n    mintKP: poolTokenMintSigner,\n    mintAuthority: authority,\n    decimals,\n  });\n  const poolTokenMint = poolTokenMintSigner.publicKey;\n\n  // Create initial LP token account\n  let initialLPAccount: PublicKey | undefined = undefined;\n  if (useAssociatedAccountForInitialLP) {\n    const lpAccount = await getOrCreateATA({\n      provider,\n      mint: poolTokenMint,\n      owner: initialLiquidityProvider,\n      payer: provider.wallet.publicKey,\n    });\n    initialLPAccount = lpAccount.address;\n\n    if (lpAccount.instruction) {\n      instructions.createInitialLPTokenAccount = new TransactionEnvelope(\n        provider,\n        [lpAccount.instruction]\n      );\n    }\n  } else {\n    const { key: unassociatedInitialLPAccount, tx: initialLPInstructions } =\n      await createTokenAccount({\n        provider,\n        mint: poolTokenMint,\n        owner: initialLiquidityProvider,\n        payer: provider.wallet.publicKey,\n      });\n    initialLPAccount = unassociatedInitialLPAccount;\n    instructions.createInitialLPTokenAccount = initialLPInstructions;\n  }\n\n  // Create Swap Token A account\n  const { info: tokenA, instructions: tokenAInstructions } =\n    await initializeSwapTokenInfo({\n      provider,\n      mint: tokenAMint,\n      authority,\n      admin: adminAccount,\n    });\n  mergeInstructions(instructions.createSwapTokenAAccounts, tokenAInstructions);\n\n  // Create Swap Token B account\n  const { info: tokenB, instructions: tokenBInstructions } =\n    await initializeSwapTokenInfo({\n      provider,\n      mint: tokenBMint,\n      authority,\n      admin: adminAccount,\n    });\n  mergeInstructions(instructions.createSwapTokenBAccounts, tokenBInstructions);\n\n  // Seed the swap's Token A and token B accounts with tokens\n  // On testnet, this is usually a mint.\n  // On mainnet, this is usually a token transfer.\n  const seedPoolAccountsResult = seedPoolAccounts({\n    tokenAAccount: tokenA.reserve,\n    tokenBAccount: tokenB.reserve,\n  });\n  mergeInstructions(instructions.seedPoolAccounts, seedPoolAccountsResult);\n\n  const initializeSwapInstruction: InitializeSwapInstruction = {\n    config: {\n      swapAccount: swapAccount,\n      authority,\n      swapProgramID,\n      tokenProgramID: TOKEN_PROGRAM_ID,\n    },\n\n    adminAccount,\n    tokenA,\n    tokenB,\n\n    poolTokenMint,\n    destinationPoolTokenAccount: initialLPAccount,\n    nonce,\n    ampFactor,\n    fees,\n  };\n  const {\n    balanceNeeded: swapBalanceNeeded,\n    instructions: initializeStableSwapInstructions,\n  } = await createInitializeStableSwapInstructionsRaw({\n    provider,\n    initializeSwapInstruction,\n  });\n  mergeInstructions(instructions.initializeSwap, {\n    instructions: initializeStableSwapInstructions,\n    signers: [],\n  });\n\n  return {\n    initializeArgs: initializeSwapInstruction,\n    balanceNeeded: mintBalanceNeeded + swapBalanceNeeded,\n    instructions,\n  };\n};\n\nconst initializeSwapTokenInfo = async ({\n  provider,\n  mint,\n  authority,\n  admin,\n}: {\n  provider: Provider;\n  mint: PublicKey;\n  authority: PublicKey;\n  admin: PublicKey;\n}): Promise<{\n  info: SwapTokenInfo;\n  instructions: TransactionInstructions;\n}> => {\n  // Create Swap Token Account\n  const { key: tokenAccount, tx: createSwapTokenAccountInstructions } =\n    await createTokenAccount({\n      provider,\n      mint,\n      owner: authority,\n      payer: provider.wallet.publicKey,\n    });\n\n  // Create Admin Fee Account\n  const { key: adminFeeAccount, tx: createAdminFeeAccountInstructions } =\n    await createTokenAccount({\n      provider,\n      mint,\n      owner: admin,\n      payer: provider.wallet.publicKey,\n    });\n\n  return {\n    info: {\n      mint,\n      reserve: tokenAccount,\n      adminFeeAccount: adminFeeAccount,\n    },\n    instructions: createSwapTokenAccountInstructions.combine(\n      createAdminFeeAccountInstructions\n    ),\n  };\n};\n\n/**\n * Creates an unsigned InitializeSwap transaction.\n *\n * After calling this, you must sign this transaction with the accounts:\n * - payer -- Account that holds the SOL to seed the account.\n * - args.config.stableSwapAccount -- This account is used once then its key is no longer relevant\n */\nexport const createInitializeStableSwapInstructionsRaw = async ({\n  provider,\n  initializeSwapInstruction,\n}: {\n  provider: Provider;\n  initializeSwapInstruction: InitializeSwapInstruction;\n}): Promise<{\n  balanceNeeded: number;\n  instructions: readonly TransactionInstruction[];\n}> => {\n  // Allocate memory for the account\n  const balanceNeeded = await StableSwap.getMinBalanceRentForExemptStableSwap(\n    provider.connection\n  );\n  return {\n    balanceNeeded,\n    instructions: [\n      SystemProgram.createAccount({\n        fromPubkey: provider.wallet.publicKey,\n        newAccountPubkey: initializeSwapInstruction.config.swapAccount,\n        lamports: balanceNeeded,\n        space: StableSwapLayout.span,\n        programId: initializeSwapInstruction.config.swapProgramID,\n      }),\n      createInitializeStableSwapInstruction(initializeSwapInstruction),\n    ],\n  };\n};\n\n/**\n * Deploys a new StableSwap pool.\n */\nexport const deployNewSwap = async ({\n  enableLogging = false,\n  ...args\n}: Omit<InitializeNewStableSwapArgs, \"connection\"> & {\n  provider: Provider;\n  enableLogging?: boolean;\n}): Promise<{\n  swap: StableSwap;\n  initializeArgs: InitializeSwapInstruction;\n  txSigs: {\n    setupAccounts1: TransactionSignature;\n    setupAccounts2: TransactionSignature;\n    initializeSwap: TransactionSignature;\n  };\n}> => {\n  const result = await createInitializeNewSwapTx(args);\n  const { txs } = result;\n\n  const { signature: setupAccounts1 } = await txs.setupAccounts1.confirm();\n  if (enableLogging) {\n    console.log(`Set up accounts pt 1: ${setupAccounts1}`);\n  }\n  const { signature: setupAccounts2 } = await txs.setupAccounts2.confirm();\n  if (enableLogging) {\n    console.log(`Set up accounts pt 2: ${setupAccounts2}`);\n  }\n  const { signature: initializeSwap } = await txs.initializeSwap.confirm();\n  if (enableLogging) {\n    console.log(`Initialize swap: ${initializeSwap}`);\n  }\n\n  return {\n    ...result,\n    txSigs: {\n      setupAccounts1,\n      setupAccounts2,\n      initializeSwap,\n    },\n  };\n};\n\n/**\n * Creates the transactions for creating a new swap.\n *\n * This is split into two transactions: setup and initialize, to ensure we are under the size limit.\n */\nexport const createInitializeNewSwapTx = async (\n  args: InitializeNewStableSwapArgs\n): Promise<{\n  swap: StableSwap;\n  initializeArgs: InitializeSwapInstruction;\n  txs: {\n    setupAccounts1: TransactionEnvelope;\n    setupAccounts2: TransactionEnvelope;\n    initializeSwap: TransactionEnvelope;\n  };\n}> => {\n  const { provider } = args;\n  const { instructions, initializeArgs } =\n    await createInitializeStableSwapInstructions({\n      ...args,\n    });\n\n  const setupAccounts1 = (\n    [\n      \"createLPTokenMint\",\n      \"createSwapTokenAAccounts\",\n      \"createSwapTokenBAccounts\",\n    ] as const\n  )\n    .map((method) => {\n      return new TransactionEnvelope(\n        provider,\n        instructions[method].instructions.slice(),\n        instructions[method].signers.slice()\n      );\n    })\n    .reduce((acc, tx) => acc.combine(tx));\n\n  const setupAccounts2 = (\n    [\"createInitialLPTokenAccount\", \"seedPoolAccounts\"] as const\n  )\n    .map((method) => {\n      return new TransactionEnvelope(\n        provider,\n        instructions[method].instructions.slice(),\n        instructions[method].signers.slice()\n      );\n    })\n    .reduce((acc, tx) => acc.combine(tx));\n\n  const initializeSwap = new TransactionEnvelope(\n    provider,\n    instructions.initializeSwap.instructions.slice(),\n    instructions.initializeSwap.signers.slice()\n  );\n\n  const newSwap = loadSwapFromInitializeArgs(initializeArgs);\n  return {\n    swap: newSwap,\n    initializeArgs,\n    txs: {\n      setupAccounts1,\n      setupAccounts2,\n      initializeSwap,\n    },\n  };\n};\n"]}