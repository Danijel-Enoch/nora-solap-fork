"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("react"),t=require("@jup-ag/core");function r(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var o=r(e);const n={INITIALIZE_ERROR:"INITIALIZE_ERROR",ROUTES_ERROR:"ROUTES_ERROR"},u=e.createContext(null);Object.defineProperty(exports,"JUPITER_ERRORS",{enumerable:!0,get:function(){return t.JUPITER_ERRORS}}),Object.defineProperty(exports,"MARKETS_URL",{enumerable:!0,get:function(){return t.MARKETS_URL}}),Object.defineProperty(exports,"TOKEN_LIST_URL",{enumerable:!0,get:function(){return t.TOKEN_LIST_URL}}),Object.defineProperty(exports,"getRouteInfoUniqueId",{enumerable:!0,get:function(){return t.getRouteInfoUniqueId}}),exports.Errors=n,exports.JupiterProvider=({connection:r,cluster:i,userPublicKey:c,children:s,platformFeeAndAccounts:a,quoteMintToReferrer:l,routeCacheDuration:f,marketUrl:R,restrictIntermediateTokens:p,onlyDirectRoutes:d})=>{const[E,T]=e.useState(),[I,m]=e.useState(),M=(e.useEffect(()=>{(async()=>{try{var e=await t.Jupiter.load({connection:r,cluster:i,user:c,platformFeeAndAccounts:a,routeCacheDuration:f,quoteMintToReferrer:l,marketUrl:R,restrictIntermediateTokens:p});T(e)}catch(e){throw console.error(e),m(n.INITIALIZE_ERROR),e}})()},[r,i,p]),e.useEffect(()=>{E&&c&&E.setUserPublicKey(c)},[E,c]),e.useMemo(()=>{let e=new Map;return e=E?E.getRouteMap(d):e},[E,d])),h=e.useMemo(()=>Array.from(M.keys()),[M]);return o.default.createElement(u.Provider,{value:{jupiter:E,allTokenMints:h,connection:r,cluster:i,routeMap:M,error:I,setError:m,routeCacheDuration:f,onlyDirectRoutes:d}},s)},exports.useJupiter=({amount:t,inputMint:r,outputMint:i,slippage:c,debounceTime:s=250})=>{const a=e.useContext(u),[l,f]=e.useState(!1),[R,p]=e.useState(),[d,E]=e.useState(0),T=e.useRef(d),[I,m,M]=function(t,r){const[n,o]=e.useState(t);return e.useEffect(()=>{const e=setTimeout(()=>{o(t)},r);return()=>{clearTimeout(e)}},[t,r]),n}(o.default.useMemo(()=>[t,r,i],[t,null==r?void 0:r.toBase58(),null==i?void 0:i.toBase58()]),s),h=e.useRef(0),w=e.useRef(0);if(!a)throw new Error("JupiterProvider is required");const{routeMap:y,allTokenMints:O,jupiter:g,error:v,setError:b,routeCacheDuration:S=0,onlyDirectRoutes:_}=a;e.useEffect(()=>{T.current=-1},[[null==m?void 0:m.toString(),null==M?void 0:M.toString()].sort().join("-"),c]),e.useEffect(()=>{h.current&&(new Date).getTime()-h.current>=S&&(T.current=-1),I&&d!==T.current&&f(!0)},[d,I,c,m,M,_]),e.useEffect(()=>{if(g)if(I&&v!==n.INITIALIZE_ERROR){if(I&&m&&M&&y){let r=(new Date).getTime();w.current=r,g.computeRoutes({inputMint:m,outputMint:M,inputAmount:I,slippage:c,forceFetch:d!==T.current,onlyDirectRoutes:_}).then(({routesInfos:e,cached:t})=>{w.current===r&&(p(e),b(void 0),t||(h.current=(new Date).getTime()))}).catch(e=>{console.error(e),w.current===r&&(p(void 0),b(n.ROUTES_ERROR))}).finally(()=>{w.current===r&&(T.current=d,f(!1))})}}else p(void 0)},[g,I,m,M,c,d,_]);s=e.useCallback(async({wallet:e,routeInfo:t,onTransaction:r})=>{if(v)throw new Error(v);if(!g)throw new Error("Jupiter not initialized");if(null==e||!e.publicKey)throw new Error("Wallet not connected");if(!t)throw new Error("Invalid state, impossible to build transaction");const n=(await g.exchange({routeInfo:t}))["execute"];return n({wallet:e,onTransaction:r})},[g]);return{allTokenMints:O,routeMap:y,exchange:s,refresh:()=>{!l&&h.current&&E(e=>e+1)},lastRefreshTimestamp:h.current,loading:l,routes:R,error:v}},exports.useJupiterRouteMap=()=>{var t=e.useContext(u);if(t)return t.routeMap;throw new Error("JupiterProvider is required")};
//# sourceMappingURL=react-hook.cjs.production.min.js.map
