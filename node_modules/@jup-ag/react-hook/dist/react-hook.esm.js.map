{"version":3,"file":"react-hook.esm.js","sources":["../src/error.tsx","../src/utils/useDebounce.ts","../src/index.tsx"],"sourcesContent":["export const Errors = {\n  INITIALIZE_ERROR: 'INITIALIZE_ERROR' as 'INITIALIZE_ERROR',\n  ROUTES_ERROR: 'ROUTES_ERROR' as 'ROUTES_ERROR',\n};\n","import { useEffect, useState } from 'react';\n\nexport default function useDebounce(value: any, delay: number) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(\n    () => {\n      // Update debounced value after delay\n      const handler = setTimeout(() => {\n        setDebouncedValue(value);\n      }, delay);\n      // Cancel the timeout if value changes (also on delay change or unmount)\n      return () => {\n        clearTimeout(handler);\n      };\n    },\n    [value, delay], // Only re-call effect if value or delay changes\n  );\n  return debouncedValue;\n}\n","import React, { useEffect, useState, useMemo, useCallback, useRef, createContext, useContext } from 'react';\nimport { Connection, PublicKey, Cluster } from '@solana/web3.js';\nimport { Errors } from './error';\nimport type { SignerWalletAdapter } from '@solana/wallet-adapter-base';\nimport useDebounce from './utils/useDebounce';\nimport {\n  RouteInfo,\n  Jupiter,\n  SwapResult,\n  TOKEN_LIST_URL,\n  MARKETS_URL,\n  JUPITER_ERRORS,\n  TransactionFeeInfo,\n  getRouteInfoUniqueId,\n  PlatformFeeAndAccounts,\n  QuoteMintToReferrer,\n  IConfirmationTxDescription,\n  OnTransaction,\n} from '@jup-ag/core';\n\nexport type JupiterError = typeof Errors[keyof typeof Errors];\nexport type { IConfirmationTxDescription };\n\ninterface UseJupiterResult {\n  /** routes that are possible, sorted decending based on outAmount */\n  routes?: RouteInfo[];\n  /** exchange function to submit transaction */\n  exchange: (params: {\n    wallet: Pick<SignerWalletAdapter, 'signAllTransactions' | 'publicKey' | 'sendTransaction' | 'signTransaction'>;\n    routeInfo: RouteInfo;\n    /** a confirmation waiter factory to make a confirmation waiter for each transaction */\n    onTransaction?: OnTransaction;\n  }) => Promise<SwapResult>;\n  /** refresh function to refetch the prices */\n  refresh: () => void;\n  /** last refresh timestamp */\n  lastRefreshTimestamp: number;\n  /** all possible token mints to be chosen from */\n  allTokenMints: string[];\n  /** route map input mint with output mints */\n  routeMap: Map<string, string[]>;\n  /** loading state */\n  loading: boolean;\n  error: JupiterError | undefined;\n}\n\ninterface JupiterProps {\n  connection: Connection;\n  cluster: Cluster;\n  userPublicKey?: PublicKey;\n  platformFeeAndAccounts?: PlatformFeeAndAccounts;\n  quoteMintToReferrer?: QuoteMintToReferrer;\n  routeCacheDuration?: number;\n  onlyDirectRoutes?: boolean;\n  /* custom jupiter market url */\n  marketUrl?: string;\n  restrictIntermediateTokens?: boolean;\n}\n\nconst JupiterContext = createContext<\n  | (Pick<UseJupiterResult, 'allTokenMints' | 'routeMap'> & {\n      connection: Connection;\n      cluster: string;\n      jupiter: Jupiter | undefined;\n      error: JupiterError | undefined;\n      setError: (error?: JupiterError) => void;\n      routeCacheDuration?: number;\n      onlyDirectRoutes?: boolean;\n    })\n  | null\n>(null);\n\nexport const JupiterProvider: React.FC<JupiterProps> = ({\n  connection,\n  cluster,\n  userPublicKey,\n  children,\n  platformFeeAndAccounts,\n  quoteMintToReferrer,\n  routeCacheDuration,\n  marketUrl,\n  restrictIntermediateTokens,\n  onlyDirectRoutes,\n}) => {\n  const [jupiter, setJupiter] = useState<Jupiter>();\n\n  const [error, setError] = useState<JupiterError>();\n\n  useEffect(() => {\n    (async () => {\n      try {\n        const _jupiter = await Jupiter.load({\n          connection,\n          cluster,\n          user: userPublicKey,\n          platformFeeAndAccounts,\n          routeCacheDuration,\n          quoteMintToReferrer,\n          marketUrl,\n          restrictIntermediateTokens,\n        });\n\n        setJupiter(_jupiter);\n      } catch (e) {\n        console.error(e);\n        setError(Errors.INITIALIZE_ERROR);\n        throw e;\n      }\n    })();\n  }, [connection, cluster, restrictIntermediateTokens]);\n\n  useEffect(() => {\n    if (jupiter && userPublicKey) {\n      jupiter.setUserPublicKey(userPublicKey);\n    }\n  }, [jupiter, userPublicKey]);\n\n  const routeMap = useMemo(() => {\n    let routeMap = new Map<string, string[]>();\n\n    if (jupiter) {\n      routeMap = jupiter.getRouteMap(onlyDirectRoutes);\n    }\n    return routeMap;\n  }, [jupiter, onlyDirectRoutes]);\n\n  const allTokenMints = useMemo(() => {\n    return Array.from(routeMap.keys());\n  }, [routeMap]);\n\n  return (\n    <JupiterContext.Provider\n      value={{\n        jupiter,\n        allTokenMints,\n        connection,\n        cluster,\n        routeMap,\n        error,\n        setError,\n        routeCacheDuration,\n        onlyDirectRoutes,\n      }}\n    >\n      {children}\n    </JupiterContext.Provider>\n  );\n};\n\ninterface UseJupiterProps {\n  amount: number;\n  inputMint: PublicKey | undefined;\n  outputMint: PublicKey | undefined;\n  slippage: number;\n  /* inputAmount is being debounced, debounceTime 0 to disable debounce */\n  debounceTime?: number;\n}\n\nexport const useJupiterRouteMap = () => {\n  const context = useContext(JupiterContext);\n  if (!context) {\n    throw new Error('JupiterProvider is required');\n  }\n  return context.routeMap;\n};\n\nexport const useJupiter = ({\n  amount,\n  inputMint,\n  outputMint,\n  slippage,\n  debounceTime = 250,\n}: UseJupiterProps): UseJupiterResult => {\n  const context = useContext(JupiterContext);\n  const [loading, setLoading] = useState(false);\n  const [routes, setRoutes] = useState<RouteInfo[]>();\n  const [refreshCount, setRefreshCount] = useState<number>(0);\n  // lastRefreshCount indicate when the last refresh was triggered on which refreshCount\n  const lastRefreshCount = useRef<number>(refreshCount);\n\n  const [debouncedAmount, debouncedInputMint, debouncedOutputMint] = useDebounce(\n    React.useMemo(() => [amount, inputMint, outputMint], [amount, inputMint?.toBase58(), outputMint?.toBase58()]),\n    debounceTime,\n  );\n\n  const lastRefreshTimestamp = useRef<number>(0);\n  const lastQueryTimestamp = useRef<number>(0);\n\n  if (!context) {\n    throw new Error('JupiterProvider is required');\n  }\n\n  const { routeMap, allTokenMints, jupiter, error, setError, routeCacheDuration = 0, onlyDirectRoutes } = context;\n\n  // lastRefreshCount to determine when the last refresh was triggered, reset this to -1 to trigger a re-fetch\n  useEffect(() => {\n    lastRefreshCount.current = -1;\n  }, [[debouncedInputMint?.toString(), debouncedOutputMint?.toString()].sort().join('-'), slippage]);\n\n  useEffect(() => {\n    // if now - lastRefreshTimestamp > routeCacheDuration, then we need to refresh\n    if (lastRefreshTimestamp.current && new Date().getTime() - lastRefreshTimestamp.current >= routeCacheDuration) {\n      lastRefreshCount.current = -1;\n    }\n\n    if (debouncedAmount && refreshCount !== lastRefreshCount.current) {\n      // don't set loading if there is no input amount\n      setLoading(true);\n    }\n  }, [refreshCount, debouncedAmount, slippage, debouncedInputMint, debouncedOutputMint, onlyDirectRoutes]);\n\n  useEffect(() => {\n    if (!jupiter) {\n      return;\n    }\n\n    if (!debouncedAmount || error === Errors.INITIALIZE_ERROR) {\n      setRoutes(undefined);\n    } else if (debouncedAmount) {\n      if (!debouncedInputMint || !debouncedOutputMint || !routeMap) return;\n      let lastUpdatedTime = new Date().getTime();\n      lastQueryTimestamp.current = lastUpdatedTime;\n\n      jupiter\n        .computeRoutes({\n          inputMint: debouncedInputMint,\n          outputMint: debouncedOutputMint,\n          inputAmount: debouncedAmount,\n          slippage,\n          forceFetch: refreshCount !== lastRefreshCount.current,\n          onlyDirectRoutes,\n        })\n        .then(({ routesInfos, cached }) => {\n          if (lastQueryTimestamp.current !== lastUpdatedTime) {\n            return;\n          }\n          setRoutes(routesInfos);\n          setError(undefined);\n\n          if (!cached) {\n            lastRefreshTimestamp.current = new Date().getTime();\n          }\n        })\n        .catch((e) => {\n          console.error(e);\n          if (lastQueryTimestamp.current !== lastUpdatedTime) {\n            return;\n          }\n          // Clear routes when erring to avoid bad pricing\n          setRoutes(undefined);\n          setError(Errors.ROUTES_ERROR);\n        })\n        .finally(() => {\n          if (lastQueryTimestamp.current !== lastUpdatedTime) {\n            return;\n          }\n          lastRefreshCount.current = refreshCount;\n          setLoading(false);\n        });\n    }\n  }, [jupiter, debouncedAmount, debouncedInputMint, debouncedOutputMint, slippage, refreshCount, onlyDirectRoutes]);\n\n  const exchange: UseJupiterResult['exchange'] = useCallback(\n    async ({ wallet, routeInfo, onTransaction }): Promise<SwapResult> => {\n      if (error) {\n        throw new Error(error);\n      }\n\n      if (!jupiter) {\n        throw new Error('Jupiter not initialized');\n      }\n\n      if (!wallet?.publicKey) {\n        throw new Error('Wallet not connected');\n      }\n\n      if (!routeInfo) {\n        throw new Error('Invalid state, impossible to build transaction');\n      }\n\n      const { execute } = await jupiter.exchange({ routeInfo });\n\n      const result = await execute({ wallet, onTransaction });\n\n      return result;\n    },\n    [jupiter],\n  );\n\n  return {\n    allTokenMints,\n    routeMap,\n    exchange,\n    refresh: () => {\n      if (!loading && lastRefreshTimestamp.current) {\n        setRefreshCount((refreshCount) => refreshCount + 1);\n      }\n    },\n    lastRefreshTimestamp: lastRefreshTimestamp.current,\n    loading,\n    routes,\n    error,\n  };\n};\n\nexport { RouteInfo, getRouteInfoUniqueId, TOKEN_LIST_URL, JUPITER_ERRORS, MARKETS_URL, Errors, TransactionFeeInfo };\n"],"names":["Errors","INITIALIZE_ERROR","ROUTES_ERROR","useDebounce","value","delay","debouncedValue","setDebouncedValue","useState","useEffect","handler","setTimeout","clearTimeout","JupiterContext","createContext","JupiterProvider","connection","cluster","userPublicKey","children","platformFeeAndAccounts","quoteMintToReferrer","routeCacheDuration","marketUrl","restrictIntermediateTokens","onlyDirectRoutes","jupiter","setJupiter","error","setError","routeMap","_jupiter","Jupiter","load","user","e","console","setUserPublicKey","useMemo","let","Map","getRouteMap","allTokenMints","Array","from","keys","React","createElement","Provider","useJupiterRouteMap","context","useContext","Error","useJupiter","amount","inputMint","outputMint","slippage","debounceTime","loading","setLoading","routes","setRoutes","refreshCount","setRefreshCount","lastRefreshCount","useRef","debouncedAmount","debouncedInputMint","debouncedOutputMint","toBase58","lastRefreshTimestamp","lastQueryTimestamp","current","toString","sort","join","Date","getTime","lastUpdatedTime","computeRoutes","inputAmount","forceFetch","then","routesInfos","cached","undefined","catch","finally","exchange","useCallback","async","wallet","routeInfo","onTransaction","publicKey","execute","refresh"],"mappings":"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"}