import React,{useState,useEffect,useMemo,useContext,useRef,useCallback,createContext}from"react";import{Jupiter}from"@jup-ag/core";export{JUPITER_ERRORS,MARKETS_URL,TOKEN_LIST_URL,getRouteInfoUniqueId}from"@jup-ag/core";const Errors={INITIALIZE_ERROR:"INITIALIZE_ERROR",ROUTES_ERROR:"ROUTES_ERROR"};function useDebounce(t,r){const[e,o]=useState(t);return useEffect(()=>{const e=setTimeout(()=>{o(t)},r);return()=>{clearTimeout(e)}},[t,r]),e}const JupiterContext=createContext(null),JupiterProvider=({connection:t,cluster:r,userPublicKey:o,children:e,platformFeeAndAccounts:u,quoteMintToReferrer:n,routeCacheDuration:i,marketUrl:s,restrictIntermediateTokens:c,onlyDirectRoutes:a})=>{const[l,R]=useState(),[p,f]=useState(),E=(useEffect(()=>{(async()=>{try{var e=await Jupiter.load({connection:t,cluster:r,user:o,platformFeeAndAccounts:u,routeCacheDuration:i,quoteMintToReferrer:n,marketUrl:s,restrictIntermediateTokens:c});R(e)}catch(e){throw console.error(e),f(Errors.INITIALIZE_ERROR),e}})()},[t,r,c]),useEffect(()=>{l&&o&&l.setUserPublicKey(o)},[l,o]),useMemo(()=>{let e=new Map;return e=l?l.getRouteMap(a):e},[l,a]));var d=useMemo(()=>Array.from(E.keys()),[E]);return React.createElement(JupiterContext.Provider,{value:{jupiter:l,allTokenMints:d,connection:t,cluster:r,routeMap:E,error:p,setError:f,routeCacheDuration:i,onlyDirectRoutes:a}},e)},useJupiterRouteMap=()=>{var e=useContext(JupiterContext);if(e)return e.routeMap;throw new Error("JupiterProvider is required")},useJupiter=({amount:e,inputMint:t,outputMint:r,slippage:o,debounceTime:u=250})=>{var n=useContext(JupiterContext);const[i,s]=useState(!1),[c,a]=useState(),[l,R]=useState(0),p=useRef(l),[f,E,d]=useDebounce(React.useMemo(()=>[e,t,r],[e,null==t?void 0:t.toBase58(),null==r?void 0:r.toBase58()]),u),m=useRef(0),T=useRef(0);if(!n)throw new Error("JupiterProvider is required");const{routeMap:I,allTokenMints:w,jupiter:M,error:h,setError:v,routeCacheDuration:J=0,onlyDirectRoutes:C}=n;useEffect(()=>{p.current=-1},[[null===E||void 0===E?void 0:E.toString(),null===d||void 0===d?void 0:d.toString()].sort().join("-"),o]),useEffect(()=>{m.current&&(new Date).getTime()-m.current>=J&&(p.current=-1),f&&l!==p.current&&s(!0)},[l,f,o,E,d,C]),useEffect(()=>{if(M)if(f&&h!==Errors.INITIALIZE_ERROR){if(f&&E&&d&&I){let r=(new Date).getTime();T.current=r,M.computeRoutes({inputMint:E,outputMint:d,inputAmount:f,slippage:o,forceFetch:l!==p.current,onlyDirectRoutes:C}).then(({routesInfos:e,cached:t})=>{T.current===r&&(a(e),v(void 0),t||(m.current=(new Date).getTime()))}).catch(e=>{console.error(e),T.current===r&&(a(void 0),v(Errors.ROUTES_ERROR))}).finally(()=>{T.current===r&&(p.current=l,s(!1))})}}else a(void 0)},[M,f,E,d,o,l,C]);u=useCallback(async({wallet:e,routeInfo:t,onTransaction:r})=>{if(h)throw new Error(h);if(!M)throw new Error("Jupiter not initialized");if(null==e||!e.publicKey)throw new Error("Wallet not connected");if(!t)throw new Error("Invalid state, impossible to build transaction");const o=(await M.exchange({routeInfo:t}))["execute"];return await o({wallet:e,onTransaction:r})},[M]);return{allTokenMints:w,routeMap:I,exchange:u,refresh:()=>{!i&&m.current&&R(e=>e+1)},lastRefreshTimestamp:m.current,loading:i,routes:c,error:h}};export{Errors,JupiterProvider,useJupiter,useJupiterRouteMap};
//# sourceMappingURL=react-hook.esm.js.map
