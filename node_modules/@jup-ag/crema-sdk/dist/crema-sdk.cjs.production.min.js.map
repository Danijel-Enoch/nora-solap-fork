{"version":3,"file":"crema-sdk.cjs.production.min.js","sources":["../node_modules/regenerator-runtime/runtime.js","../src/util/decimalExt.ts","../src/instructions/instruction.ts","../src/util/layout.ts","../src/util/transaction.ts","../src/util/token.ts","../src/instructions/addUserPosition.ts","../src/instructions/claim.ts","../src/instructions/depositAllTokenTypes.ts","../src/instructions/initialize.ts","../src/instructions/managerClaim.ts","../src/instructions/swap.ts","../src/instructions/withdrawAllTokenTypes.ts","../src/instructions/simulateSwap.ts","../src/state/tick.ts","../src/state/positions.ts","../src/state/tokenSwap.ts","../src/math/tick.ts","../src/math/liquity.ts","../src/tokenSwap.ts"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import \"decimal.js\";\nimport BN from \"bn.js\";\nimport invariant from \"tiny-invariant\";\nimport Decimal from \"decimal.js\";\n\nDecimal.config({\n  precision: 64,\n  rounding: Decimal.ROUND_DOWN,\n  toExpNeg: -64,\n  toExpPos: 64,\n});\n\nconst TEN = new Decimal(10);\nconst P64 = new Decimal(2).pow(64);\nconst MAX_INT64 = P64.div(2).sub(1);\nconst MIN_INT64 = P64.div(2).neg();\nconst MAX_UINT64 = P64.sub(1);\nconst MAX_INT128 = P64.pow(63).sub(1);\nconst MIN_INT128 = MAX_INT128.neg();\nconst MAX_UINT128 = P64.pow(64).sub(1);\nconst MAX_PRECISION = 40;\n\nexport class DecimalExt {\n  /**\n   * New a Decimal from a int64 buffer\n   * @param buffer The buffer\n   * @param precision The pricision\n   * @returns The Decimal value, the result will be div 10^precision\n   */\n  static from64Buffer(buffer: Buffer, precision: number = 0): Decimal {\n    invariant(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n\n    if (buffer[7] >= 0x80) {\n      let ss = [];\n      for (let v of buffer) {\n        ss.push(`00${Math.abs(~v & 0xff).toString(16)}`.slice(-2));\n      }\n      let bn = new BN(ss.join(\"\"), 16, \"le\").add(new BN(1)).neg();\n      return new Decimal(bn.toString()).div(TEN.pow(precision));\n    }\n    return new Decimal(new BN(buffer, \"le\").toString()).div(TEN.pow(precision));\n  }\n\n  /**\n   * New a Decimal from a uint64 buffer\n   * @param buffer The buffer\n   * @param precision The precision\n   * @returns The Decimal value, the result will be div 10^precision\n   */\n  static fromU64Buffer(buffer: Buffer, precision: number = 0): Decimal {\n    invariant(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n    return new Decimal(new BN(buffer, 16, \"le\").toString()).div(\n      TEN.pow(precision)\n    );\n  }\n\n  /**\n   * New a Decimal from a int128 buffer\n   * @param buffer The buffer\n   * @param precision The pricision\n   * @returns The Decimal value, the result will be div 10^precision\n   */\n  static from128Buffer(buffer: Buffer, precision: number = 0): Decimal {\n    invariant(buffer.length === 16, `Invalid buffer length: ${buffer.length}`);\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n\n    if (buffer[15] >= 0x80) {\n      let ss = [];\n      for (let v of buffer) {\n        ss.push(`00${Math.abs(~v & 0xff).toString(16)}`.slice(-2));\n      }\n      let bn = new BN(ss.join(\"\"), 16, \"le\").add(new BN(1)).neg();\n      return new Decimal(bn.toString()).div(TEN.pow(precision));\n    }\n    return new Decimal(new BN(buffer, \"le\").toString()).div(TEN.pow(precision));\n  }\n\n  /**\n   * New a Decimal from a uint128 buffer\n   * @param buffer The buffer\n   * @param precision The precision\n   * @returns The Decimal value, the result will be div 10^precision\n   */\n  static fromU128Buffer(buffer: Buffer, precision: number = 0): Decimal {\n    invariant(buffer.length === 16, `Invalid buffer length: ${buffer.length}`);\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n    return new Decimal(new BN(buffer, \"le\").toString()).div(TEN.pow(precision));\n  }\n\n  /**\n   * Convert a Decimal value to int64 buffer\n   * @param v The Decimal value\n   * @param precision The precision\n   * @returns The buffer, the result will be mul 10^precision\n   */\n  static to64Buffer(v: Decimal, precision: number = 0): Buffer {\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n    v = v.mul(TEN.pow(precision)).round();\n    invariant(\n      v.greaterThanOrEqualTo(MIN_INT64) && v.lessThanOrEqualTo(MAX_INT64),\n      `Invalid v: ${v.toString()} to int128 buffer with precision: ${precision}`\n    );\n    let bn = new BN(v.toString());\n    if (bn.isNeg()) {\n      let buffer = bn.add(new BN(1)).toBuffer(\"le\", 8);\n      buffer.forEach(function(item, index, input) {\n        input[index] = ~item & 0xff;\n      });\n      return buffer;\n    } else {\n      return bn.toBuffer(\"le\", 8);\n    }\n  }\n\n  /**\n   * Convert a Decimal value to uint64 buffer\n   * @param v The Decimal value\n   * @param precision The precision\n   * @returns The buffer, the result will be mul 10^precision\n   */\n  static toU64Buffer(v: Decimal, precision: number = 0): Buffer {\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n    v = v.mul(TEN.pow(precision)).round();\n    invariant(\n      v.greaterThanOrEqualTo(0) && v.lessThanOrEqualTo(MAX_UINT64),\n      `Invalid v: ${v.toString()} to uint64 buffer with precision: ${precision}`\n    );\n    return new BN(v.toString()).toBuffer(\"le\", 8);\n  }\n\n  /**\n   * Convert a Decimal value to int128 buffer\n   * @param v The Decimal value\n   * @param precision The precision\n   * @returns The buffer, the result will be mul 10^precision\n   */\n  static to128Buffer(v: Decimal, precision: number = 0): Buffer {\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n    v = v.mul(TEN.pow(precision)).round();\n    invariant(\n      v.greaterThanOrEqualTo(MIN_INT128) && v.lessThanOrEqualTo(MAX_INT128),\n      `Invalid v: ${v.toString()} to int128 buffer with precision: ${precision}`\n    );\n    let bn = new BN(v.toString());\n    if (bn.isNeg()) {\n      let buffer = bn.add(new BN(1)).toBuffer(\"le\", 16);\n      buffer.forEach(function(item, index, input) {\n        input[index] = ~item & 0xff;\n      });\n      return buffer;\n    } else {\n      return bn.toBuffer(\"le\", 16);\n    }\n  }\n\n  /**\n   * Convert a Decimal value to uint128 buffer\n   * @param v The Decimal value\n   * @param precision The precision\n   * @returns The buffer, the result will be mul 10^precision\n   */\n  static toU128Buffer(v: Decimal, precision: number = 0): Buffer {\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n    v = v.mul(TEN.pow(precision)).round();\n    invariant(\n      v.greaterThanOrEqualTo(0) && v.lessThanOrEqualTo(MAX_UINT128),\n      `Invalid v: ${v.toString()} to int128 buffer with precision: ${precision}`\n    );\n    return new BN(v.toString()).toBuffer(\"le\", 16);\n  }\n}\n","/** @internal */\nexport enum TokenSwapInstruction {\n  Initialize = 0,\n  Swap = 1,\n  DepositAllTokenTypes = 2,\n  WithdrawAllTokenTypes = 3,\n  Claim = 4,\n  ManagerClaim = 5,\n  AddUserPosition = 6,\n  UpdateFee = 7,\n  SimulateSwap = 8,\n}\n","import { blob, Layout, Blob } from \"@solana/buffer-layout\";\nimport { PublicKey, AccountInfo } from \"@solana/web3.js\";\nimport Decimal from \"decimal.js\";\nimport { DecimalExt } from \"./decimalExt\";\n\nexport type Parser<T> = (\n  pubkey: PublicKey,\n  info: AccountInfo<Buffer>\n) =>\n  | {\n      pubkey: PublicKey;\n      info: AccountInfo<Buffer>;\n      data: T;\n    }\n  | undefined;\n\n/** @internal */\nexport interface EncodeDecode<T> {\n  decode: (buffer: Buffer, offset?: number) => T;\n  encode: (src: T, buffer: Buffer, offset?: number) => number;\n}\n\n/** @internal */\nexport const encodeDecode = <T>(layout: Layout<T>): EncodeDecode<T> => {\n  const decode = layout.decode.bind(layout);\n  const encode = layout.encode.bind(layout);\n  return { decode, encode };\n};\n\nexport const publicKey = (property = \"publicKey\"): Layout<PublicKey> => {\n  const layout = blob(32, property);\n  const { encode, decode } = encodeDecode(layout);\n\n  const publicKeyLayout = (layout as Layout<unknown>) as Layout<PublicKey>;\n\n  publicKeyLayout.decode = (buffer: Buffer, offset: number) => {\n    const src = decode(buffer, offset);\n    return new PublicKey(src);\n  };\n\n  publicKeyLayout.encode = (\n    publicKey: PublicKey,\n    buffer: Buffer,\n    offset: number\n  ) => {\n    const src = publicKey.toBuffer();\n    return encode(src, buffer, offset);\n  };\n\n  return publicKeyLayout;\n};\n\nexport const uint64 = (property: string = \"uint128\"): Blob => {\n  return blob(8, property);\n};\n\nexport const int64 = (property: string = \"uint128\"): Blob => {\n  return blob(8, property);\n};\n\nexport const int128 = (property: string = \"uint128\"): Blob => {\n  return blob(16, property);\n};\n\nexport const uint128 = (property: string = \"uint128\"): Blob => {\n  return blob(16, property);\n};\n\nexport const decimal64 = (\n  property: string = \"uint64\",\n  precision: number = 0\n): Layout<Decimal> => {\n  const layout = blob(8, property);\n  //const { encode, decode } = encodeDecode(layout);\n  const decimal64Layout = (layout as Layout<unknown>) as Layout<Decimal>;\n\n  const _decode = layout.decode.bind(layout);\n  const _encode = layout.encode.bind(layout);\n\n  decimal64Layout.decode = (buffer: Buffer, offset: number) => {\n    const src = Buffer.from(_decode(buffer, offset));\n    return DecimalExt.from64Buffer(src, precision);\n  };\n\n  decimal64Layout.encode = (\n    decimal: Decimal,\n    buffer: Buffer,\n    offset: number\n  ) => {\n    const src = DecimalExt.to64Buffer(decimal, precision);\n    return _encode(src, buffer, offset);\n  };\n\n  return decimal64Layout;\n};\n\nexport const decimalU64 = (\n  property: string = \"uint64\",\n  precision: number = 0\n): Layout<Decimal> => {\n  const layout = blob(8, property);\n  //const { encode, decode } = encodeDecode(layout)\n  const _decode = layout.decode.bind(layout);\n  const _encode = layout.encode.bind(layout);\n  const decimalU64Layout = (layout as Layout<unknown>) as Layout<Decimal>;\n\n  decimalU64Layout.decode = (buffer: Buffer, offset: number) => {\n    const src = Buffer.from(_decode(buffer, offset));\n    return DecimalExt.fromU64Buffer(src, precision);\n  };\n\n  decimalU64Layout.encode = (\n    decimal: Decimal,\n    buffer: Buffer,\n    offset: number\n  ) => {\n    const src = DecimalExt.toU64Buffer(decimal, precision);\n    return _encode(src, buffer, offset);\n  };\n\n  return decimalU64Layout;\n};\n\nexport const decimal128 = (\n  property: string = \"uint64\",\n  precision: number = 0\n): Layout<Decimal> => {\n  const layout = blob(16, property);\n  //const { encode, decode } = encodeDecode(layout);\n  const _decode = layout.decode.bind(layout);\n  const _encode = layout.encode.bind(layout);\n  const decimal128Layout = (layout as Layout<unknown>) as Layout<Decimal>;\n\n  decimal128Layout.decode = (buffer: Buffer, offset: number) => {\n    const src = Buffer.from(_decode(buffer, offset));\n    return DecimalExt.from128Buffer(src, precision);\n  };\n\n  decimal128Layout.encode = (\n    decimal: Decimal,\n    buffer: Buffer,\n    offset: number\n  ) => {\n    const src = DecimalExt.to128Buffer(decimal, precision);\n    return _encode(src, buffer, offset);\n  };\n\n  return decimal128Layout;\n};\n\nexport const decimalU128 = (\n  property: string = \"uint64\",\n  precision: number = 0\n): Layout<Decimal> => {\n  const layout = blob(16, property);\n  //const { encode, decode } = encodeDecode(layout);\n  const _decode = layout.decode.bind(layout);\n  const _encode = layout.encode.bind(layout);\n  const decimalU128Layout = (layout as Layout<unknown>) as Layout<Decimal>;\n\n  decimalU128Layout.decode = (buffer: Buffer, offset: number) => {\n    const src = Buffer.from(_decode(buffer, offset));\n    let val = DecimalExt.fromU128Buffer(src, precision);\n    return val;\n  };\n\n  decimalU128Layout.encode = (\n    decimal: Decimal,\n    buffer: Buffer,\n    offset: number\n  ) => {\n    const src = DecimalExt.toU128Buffer(decimal, precision);\n    return _encode(src, buffer, offset);\n  };\n\n  return decimalU128Layout;\n};\n","import { sendAndConfirmTransaction as realSendAndConfirmTransaction } from \"@solana/web3.js\";\nimport {\n  Connection,\n  Transaction,\n  Signer,\n  TransactionSignature,\n} from \"@solana/web3.js\";\n\n/**\n * Send and confirm trnasaction with default option\n * @param conn The connection to use\n * @param transaction The transaction\n * @param signers The signers array\n * @returns\n */\nexport async function sendAndConfirmTransaction(\n  conn: Connection,\n  transaction: Transaction,\n  ...signers: Signer[]\n): Promise<TransactionSignature> {\n  return realSendAndConfirmTransaction(conn, transaction, signers, {\n    skipPreflight: false,\n    commitment: \"recent\",\n    preflightCommitment: \"recent\",\n  });\n}\n","import {\n  u64,\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n  Token,\n  AccountInfo,\n  AccountLayout,\n} from \"@solana/spl-token\";\nimport {\n  PublicKey,\n  TransactionInstruction,\n  Connection,\n  AccountInfo as BaseAccountInfo,\n} from \"@solana/web3.js\";\nimport invariant from \"tiny-invariant\";\n\n/**\n * Get a authority token account address\n * @param tokenMint The mint of token\n * @param owner The owner associated token address\n * @returns\n */\nexport async function getAssociatedTokenAddress(\n  tokenMint: PublicKey,\n  owner: PublicKey\n): Promise<PublicKey> {\n  return await Token.getAssociatedTokenAddress(\n    ASSOCIATED_TOKEN_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    tokenMint,\n    owner,\n    true\n  );\n}\n\n/**\n * Get a create associated token account instruction\n * @param tokenMint The mint of token\n * @param owner The owner associated token address\n * @param authority The authority token account address\n * @param payer The pays for transaction\n * @returns\n */\nexport function createAssociatedTokenAccountInstruction(\n  tokenMint: PublicKey,\n  associatedAccount: PublicKey,\n  owner: PublicKey,\n  payer: PublicKey\n): TransactionInstruction {\n  return Token.createAssociatedTokenAccountInstruction(\n    ASSOCIATED_TOKEN_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    tokenMint,\n    associatedAccount,\n    owner,\n    payer\n  );\n}\n\n/**\n * Get the token account info by address\n * @param conn The connection to use\n * @param address The token account address\n * @returns\n */\nexport async function getTokenAccount(\n  conn: Connection,\n  address: PublicKey\n): Promise<AccountInfo> {\n  let account = await conn.getAccountInfo(address);\n  invariant(\n    account?.data != null,\n    `The token account:${address.toBase58()} data is null`\n  );\n  let accountInfo = parseTokenAccount(account);\n  accountInfo.address = address;\n  return accountInfo;\n}\n\n/**\n * Get the token accounts by owner\n * @param conn The connection to use\n * @param owner The owner address\n * @returns The token accounts\n */\nexport async function getTokenAccounts(\n  conn: Connection,\n  owner: PublicKey\n): Promise<AccountInfo[]> {\n  let accounts = await conn.getTokenAccountsByOwner(owner, {\n    programId: TOKEN_PROGRAM_ID,\n  });\n  const accountInfos: AccountInfo[] = [];\n  for (let i = 0; i < accounts.value.length; i++) {\n    let { pubkey, account } = accounts.value[i];\n    invariant(\n      account?.data != null,\n      `The token account:${pubkey.toBase58()} data is null`\n    );\n    let accountInfo = parseTokenAccount(account);\n    accountInfo.address = pubkey;\n    accountInfos.push(accountInfo);\n  }\n  return accountInfos;\n}\n\nexport function parseTokenAccountData(data: Buffer): AccountInfo {\n  let accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n}\n\nexport function parseTokenAccount(\n  account: BaseAccountInfo<Buffer>\n): AccountInfo {\n  invariant(account?.data != null, `The account data is null`);\n  let accountInfo = AccountLayout.decode(account?.data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n}\n","import { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { PublicKey, TransactionInstruction } from \"@solana/web3.js\";\nimport { struct, u8 } from \"@solana/buffer-layout\";\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n  instruction: number;\n}\n\nconst DataLayout = struct<Data>([u8(\"instruction\")]);\n\nexport const addUserPositionInstruction = (\n  programId: PublicKey,\n  authority: PublicKey,\n  positionsKey: PublicKey\n): TransactionInstruction => {\n  let data = Buffer.alloc(DataLayout.span);\n  DataLayout.encode(\n    {\n      instruction: TokenSwapInstruction.AddUserPosition,\n    },\n    data\n  );\n  const keys = [\n    { pubkey: programId, isSigner: false, isWritable: false },\n    { pubkey: authority, isSigner: false, isWritable: false },\n    { pubkey: positionsKey, isSigner: false, isWritable: true },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n  ];\n\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data,\n  });\n};\n","import { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { PublicKey, TransactionInstruction } from \"@solana/web3.js\";\nimport { struct, u8 } from \"@solana/buffer-layout\";\nimport Decimal from \"decimal.js\";\nimport { decimalU64 } from \"../util/layout\";\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n    instruction: number;\n    positionIndex: Decimal;\n}\n\nconst DataLayout = struct<Data>([\n    u8(\"instruction\"),\n    decimalU64(\"positionIndex\"),\n]);\n\nexport const claimInstruction = (\n    programId: PublicKey,\n    tokenSwapKey: PublicKey,\n    authority: PublicKey,\n    userTransferAuthority: PublicKey,\n    swapTokenA: PublicKey,\n    swapTokenB: PublicKey,\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    nftMint: PublicKey,\n    nftUser: PublicKey,\n    ticksKey: PublicKey,\n    positionsKey: PublicKey,\n    positionIndex: Decimal\n): TransactionInstruction => {\n    let data = Buffer.alloc(DataLayout.span);\n    DataLayout.encode(\n        {\n            instruction: TokenSwapInstruction.Claim,\n            positionIndex,\n        },\n        data\n    );\n    const keys = [\n        { pubkey: tokenSwapKey, isSigner: false, isWritable: false },\n        { pubkey: authority, isSigner: false, isWritable: false },\n        { pubkey: userTransferAuthority, isSigner: true, isWritable: false },\n        { pubkey: nftMint, isSigner: false, isWritable: false },\n        { pubkey: nftUser, isSigner: false, isWritable: false },\n        { pubkey: swapTokenA, isSigner: false, isWritable: true },\n        { pubkey: swapTokenB, isSigner: false, isWritable: true },\n        { pubkey: userTokenA, isSigner: false, isWritable: true },\n        { pubkey: userTokenB, isSigner: false, isWritable: true },\n        { pubkey: ticksKey, isSigner: false, isWritable: false },\n        { pubkey: positionsKey, isSigner: false, isWritable: true },\n        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n    ];\n\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data,\n    });\n};\n","import { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { PublicKey, TransactionInstruction } from \"@solana/web3.js\";\nimport { struct, u8, s32 } from \"@solana/buffer-layout\";\nimport Decimal from \"decimal.js\";\nimport { decimalU64, decimalU128 } from \"../util/layout\";\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n  instruction: number;\n  isNewPosition: number;\n  liquityAmount: Decimal;\n  tickLower: number;\n  tickUpper: number;\n  maximumTokenA: Decimal;\n  maximumTokenB: Decimal;\n  positionIndex: Decimal;\n}\n\nconst DataLayout = struct<Data>([\n  u8(\"instruction\"),\n  u8(\"isNewPosition\"),\n  decimalU128(\"liquityAmount\"),\n  s32(\"tickLower\"),\n  s32(\"tickUpper\"),\n  decimalU64(\"maximumTokenA\"),\n  decimalU64(\"maximumTokenB\"),\n  decimalU64(\"positionIndex\"),\n]);\n\nexport const depositAllTokenTypesInstruction = (\n  programId: PublicKey,\n  tokenSwapKey: PublicKey,\n  authority: PublicKey,\n  userTransferAuthority: PublicKey,\n  userTokenA: PublicKey,\n  userTokenB: PublicKey,\n  swapTokenA: PublicKey,\n  swapTokenB: PublicKey,\n  nftMint: PublicKey,\n  nftUser: PublicKey,\n  ticksKey: PublicKey,\n  positionsKey: PublicKey,\n  isNewPosition: number,\n  tickLower: number,\n  tickUpper: number,\n  liquityAmount: Decimal,\n  maximumTokenA: Decimal,\n  maximumTokenB: Decimal,\n  positionIndex: Decimal\n): TransactionInstruction => {\n  let data = Buffer.alloc(DataLayout.span);\n  DataLayout.encode(\n    {\n      instruction: TokenSwapInstruction.DepositAllTokenTypes,\n      isNewPosition,\n      liquityAmount,\n      tickLower,\n      tickUpper,\n      maximumTokenA,\n      maximumTokenB,\n      positionIndex,\n    },\n    data\n  );\n  const keys = [\n    { pubkey: tokenSwapKey, isSigner: false, isWritable: true },\n    { pubkey: authority, isSigner: false, isWritable: false },\n    { pubkey: userTransferAuthority, isSigner: true, isWritable: false },\n    { pubkey: userTokenA, isSigner: false, isWritable: true },\n    { pubkey: userTokenB, isSigner: false, isWritable: true },\n    { pubkey: swapTokenA, isSigner: false, isWritable: true },\n    { pubkey: swapTokenB, isSigner: false, isWritable: true },\n    { pubkey: nftMint, isSigner: false, isWritable: true },\n    { pubkey: nftUser, isSigner: false, isWritable: true },\n    { pubkey: ticksKey, isSigner: false, isWritable: true },\n    { pubkey: positionsKey, isSigner: false, isWritable: true },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n  ];\n\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data,\n  });\n};\n","import { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { PublicKey, TransactionInstruction } from \"@solana/web3.js\";\nimport { struct, u8, u32 } from \"@solana/buffer-layout\";\nimport Decimal from \"decimal.js\";\nimport { decimalU128, decimalU64 } from \"../util/layout\";\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n  instruction: number;\n  nonce: number;\n  curveType: number;\n  fee: Decimal;\n  managerFee: Decimal;\n  tickSpace: number;\n  currentSqrtPrice: Decimal;\n  currentLiquity: Decimal;\n  feeGrowthGlobal0: Decimal;\n  feeGrowthGlobal1: Decimal;\n  managerFeeA: Decimal;\n  managerFeeB: Decimal;\n}\n\nconst DataLayout = struct<Data>([\n  u8(\"instruction\"),\n  u8(\"nonce\"),\n  u8(\"curveType\"),\n  decimalU64(\"fee\", 12),\n  decimalU64(\"managerFee\", 12),\n  u32(\"tickSpace\"),\n  decimalU128(\"currentSqrtPrice\", 12),\n  decimalU128(\"currentLiquity\"),\n  decimalU128(\"feeGrowthGlobal0\"),\n  decimalU128(\"feeGrowthGlobal1\"),\n  decimalU128(\"managerFeeA\"),\n  decimalU128(\"managerFeeB\"),\n]);\n\nexport const initializeInstruction = (\n  programId: PublicKey,\n  tokenSwapKey: PublicKey,\n  authority: PublicKey,\n  manager: PublicKey,\n  managerTokenA: PublicKey,\n  managerTokenB: PublicKey,\n  swapTokenA: PublicKey,\n  swapTokenB: PublicKey,\n  ticksKey: PublicKey,\n  positionsKey: PublicKey,\n  nonce: number,\n  curveType: number,\n  fee: Decimal,\n  managerFee: Decimal,\n  tickSpace: number,\n  currentSqrtPrice: Decimal\n): TransactionInstruction => {\n  let data = Buffer.alloc(DataLayout.span);\n  DataLayout.encode(\n    {\n      instruction: TokenSwapInstruction.Initialize,\n      nonce,\n      curveType,\n      fee,\n      managerFee,\n      tickSpace,\n      currentSqrtPrice,\n      currentLiquity: new Decimal(0),\n      feeGrowthGlobal0: new Decimal(0),\n      feeGrowthGlobal1: new Decimal(0),\n      managerFeeA: new Decimal(0),\n      managerFeeB: new Decimal(0),\n    },\n    data\n  );\n\n  const keys = [\n    { pubkey: tokenSwapKey, isSigner: false, isWritable: true },\n    { pubkey: authority, isSigner: false, isWritable: false },\n    { pubkey: manager, isSigner: false, isWritable: false },\n    { pubkey: managerTokenA, isSigner: false, isWritable: false },\n    { pubkey: managerTokenB, isSigner: false, isWritable: false },\n    { pubkey: swapTokenA, isSigner: false, isWritable: false },\n    { pubkey: swapTokenB, isSigner: false, isWritable: false },\n    { pubkey: ticksKey, isSigner: false, isWritable: true },\n    { pubkey: positionsKey, isSigner: false, isWritable: true },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n  ];\n\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data,\n  });\n};\n","import { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { PublicKey, TransactionInstruction } from \"@solana/web3.js\";\nimport { struct, u8 } from \"@solana/buffer-layout\";\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n  instruction: number;\n}\n\nconst DataLayout = struct<Data>([u8(\"instruction\")]);\n\nexport const managerClaimInstruction = (\n  programId: PublicKey,\n  tokenSwapKey: PublicKey,\n  authority: PublicKey,\n  userTransferAuthority: PublicKey,\n  swapTokenA: PublicKey,\n  swapTokenB: PublicKey,\n  userTokenA: PublicKey,\n  userTokenB: PublicKey\n): TransactionInstruction => {\n  let data = Buffer.alloc(DataLayout.span);\n  DataLayout.encode(\n    {\n      instruction: TokenSwapInstruction.ManagerClaim,\n    },\n    data\n  );\n  const keys = [\n    { pubkey: tokenSwapKey, isSigner: false, isWritable: true },\n    { pubkey: authority, isSigner: false, isWritable: false },\n    { pubkey: userTransferAuthority, isSigner: true, isWritable: false },\n    { pubkey: swapTokenA, isSigner: false, isWritable: true },\n    { pubkey: swapTokenB, isSigner: false, isWritable: true },\n    { pubkey: userTokenA, isSigner: false, isWritable: true },\n    { pubkey: userTokenB, isSigner: false, isWritable: true },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n  ];\n\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data,\n  });\n};\n","import { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { PublicKey, TransactionInstruction } from \"@solana/web3.js\";\nimport { struct, u8 } from \"@solana/buffer-layout\";\nimport Decimal from \"decimal.js\";\nimport { decimalU64 } from \"../util/layout\";\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n  instruction: number;\n  amountIn: Decimal;\n  minimumAmountOut: Decimal;\n}\n\nconst DataLayout = struct<Data>([\n  u8(\"instruction\"),\n  decimalU64(\"amountIn\"),\n  decimalU64(\"minimumAmountOut\"),\n]);\n\nexport const swapInstruction = (\n  programId: PublicKey,\n  tokenSwapKey: PublicKey,\n  authority: PublicKey,\n  userTransferAuthority: PublicKey,\n  userSource: PublicKey,\n  userDestination: PublicKey,\n  swapSource: PublicKey,\n  swapDestination: PublicKey,\n  ticksKey: PublicKey,\n  amountIn: Decimal,\n  minimumAmountOut: Decimal\n): TransactionInstruction => {\n  let data = Buffer.alloc(DataLayout.span);\n  DataLayout.encode(\n    {\n      instruction: TokenSwapInstruction.Swap,\n      amountIn,\n      minimumAmountOut,\n    },\n    data\n  );\n  const keys = [\n    { pubkey: tokenSwapKey, isSigner: false, isWritable: true },\n    { pubkey: authority, isSigner: false, isWritable: false },\n    { pubkey: userTransferAuthority, isSigner: true, isWritable: false },\n    { pubkey: userSource, isSigner: false, isWritable: true },\n    { pubkey: userDestination, isSigner: false, isWritable: true },\n    { pubkey: swapSource, isSigner: false, isWritable: true },\n    { pubkey: swapDestination, isSigner: false, isWritable: true },\n    { pubkey: ticksKey, isSigner: false, isWritable: true },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n  ];\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data,\n  });\n};\n","import { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { TransactionInstruction, PublicKey } from \"@solana/web3.js\";\nimport { struct, u8 } from \"@solana/buffer-layout\";\nimport Decimal from \"decimal.js\";\nimport { decimalU64 } from \"../util/layout\";\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n  instruction: number;\n  liquityAmount: Decimal;\n  minimumTokenA: Decimal;\n  minimumTokenB: Decimal;\n  positionIndex: Decimal;\n}\n\nconst DataLayout = struct<Data>([\n  u8(\"instruction\"),\n  decimalU64(\"liquityAmount\"),\n  decimalU64(\"minimumTokenA\"),\n  decimalU64(\"minimumTokenB\"),\n  decimalU64(\"positionIndex\"),\n]);\n\nexport const withdrawAllTokenTypesInstruction = (\n  programId: PublicKey,\n  tokenSwapKey: PublicKey,\n  authority: PublicKey,\n  userTransferAuthority: PublicKey,\n  swapTokenA: PublicKey,\n  swapTokenB: PublicKey,\n  userTokenA: PublicKey,\n  userTokenB: PublicKey,\n  nftMint: PublicKey,\n  nftUser: PublicKey,\n  ticksKey: PublicKey,\n  positionsKey: PublicKey,\n  liquityAmount: Decimal,\n  minimumTokenA: Decimal,\n  minimumTokenB: Decimal,\n  positionIndex: Decimal\n): TransactionInstruction => {\n  let data = Buffer.alloc(DataLayout.span);\n  DataLayout.encode(\n    {\n      instruction: TokenSwapInstruction.WithdrawAllTokenTypes,\n      liquityAmount,\n      minimumTokenA,\n      minimumTokenB,\n      positionIndex,\n    },\n    data\n  );\n  const keys = [\n    { pubkey: tokenSwapKey, isSigner: false, isWritable: true },\n    { pubkey: authority, isSigner: false, isWritable: false },\n    { pubkey: userTransferAuthority, isSigner: true, isWritable: false },\n    { pubkey: nftMint, isSigner: false, isWritable: true },\n    { pubkey: nftUser, isSigner: false, isWritable: true },\n    { pubkey: swapTokenA, isSigner: false, isWritable: true },\n    { pubkey: swapTokenB, isSigner: false, isWritable: true },\n    { pubkey: userTokenA, isSigner: false, isWritable: true },\n    { pubkey: userTokenB, isSigner: false, isWritable: true },\n    { pubkey: ticksKey, isSigner: false, isWritable: true },\n    { pubkey: positionsKey, isSigner: false, isWritable: true },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n  ];\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data,\n  });\n};\n","import { PublicKey, TransactionInstruction } from \"@solana/web3.js\";\nimport { struct, u8 } from \"@solana/buffer-layout\";\nimport Decimal from \"decimal.js\";\nimport { decimalU64 } from \"../util/layout\";\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n  instruction: number;\n  amountIn: Decimal;\n  // minimumAmountOut: Decimal,\n  direction: number;\n}\n\nconst DataLayout = struct<Data>([\n  u8(\"instruction\"),\n  decimalU64(\"amountIn\"),\n  // decimalU64(\"minimumAmountOut\"),\n  u8(\"direction\"),\n]);\n\nexport const simulateSwapInstruction = (\n  programId: PublicKey,\n  tokenSwapKey: PublicKey,\n  ticksKey: PublicKey,\n  amountIn: Decimal,\n  // minimumAmountOut: Decimal,\n  direction: number\n): TransactionInstruction => {\n  let data = Buffer.alloc(DataLayout.span);\n  DataLayout.encode(\n    {\n      instruction: TokenSwapInstruction.SimulateSwap,\n      amountIn,\n      // minimumAmountOut,\n      direction,\n    },\n    data\n  );\n  const keys = [\n    { pubkey: tokenSwapKey, isSigner: false, isWritable: true },\n    { pubkey: ticksKey, isSigner: false, isWritable: true },\n  ];\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data,\n  });\n};\n","import { struct, s32, u8, blob, seq } from \"@solana/buffer-layout\";\nimport { decimal128, decimalU128, Parser, publicKey } from \"../util/layout\";\nimport Decimal from \"decimal.js\";\nimport { AccountInfo, PublicKey } from \"@solana/web3.js\";\n\n// mainnet-beta\nexport const TICKS_ACCOUNT_SIZE = 504000;\n\n// devnet\n// export const TICKS_ACCOUNT_SIZE = 840000;\n\nexport interface Tick {\n  tick: number;\n  tickPrice: Decimal;\n  liquityGross: Decimal;\n  liquityNet: Decimal;\n  feeGrowthOutside0: Decimal;\n  feeGrowthOutside1: Decimal;\n}\n\nexport interface TicksAccount {\n  swapVersion: number;\n  tokenSwapKey: PublicKey;\n  accountType: number;\n  len: number;\n  ticks: Tick[];\n}\n\n/* @internal */\nexport interface TicksAccountDataFlat {\n  swapVersion: number;\n  tokenSwapKey: PublicKey;\n  accountType: number;\n  len: number;\n  dataFlat: Uint8Array;\n}\n\nexport const TickLayout = struct<Tick>(\n  [\n    s32(\"tick\"),\n    decimalU128(\"tickPrice\", 12),\n    decimalU128(\"liquityGross\"),\n    decimal128(\"liquityNet\"),\n    decimalU128(\"feeGrowthOutside0\", 16),\n    decimalU128(\"feeGrowthOutside1\", 16),\n  ],\n  \"tickInfo\"\n);\n\nexport const TicksAccountLayout = struct<TicksAccountDataFlat>(\n  [\n    u8(\"swapVersion\"),\n    publicKey(\"tokenSwapKey\"),\n    u8(\"accountType\"),\n    s32(\"len\"),\n    blob(TICKS_ACCOUNT_SIZE - 38, \"dataFlat\"),\n  ],\n  \"ticksAccount\"\n);\n\nexport const isTicksAccount = (info: AccountInfo<Buffer>): boolean => {\n  return info.data.length === TICKS_ACCOUNT_SIZE;\n};\n\nexport const parseTicksAccount: Parser<TicksAccount> = (\n  pubkey: PublicKey,\n  info: AccountInfo<Buffer>\n) => {\n  if (!isTicksAccount(info)) return;\n\n  const buffer = Buffer.from(info.data);\n  const {\n    swapVersion,\n    tokenSwapKey,\n    accountType,\n    len,\n    dataFlat,\n  } = TicksAccountLayout.decode(buffer);\n\n  const tickSpan = len * TickLayout.span;\n  const ticksBuffer = dataFlat.slice(0, tickSpan);\n  const ticks = seq(TickLayout, len).decode(ticksBuffer);\n\n  const ticksAccount: TicksAccount = {\n    swapVersion,\n    tokenSwapKey,\n    accountType,\n    len,\n    ticks,\n  };\n\n  return {\n    pubkey,\n    info,\n    data: ticksAccount,\n  };\n};\n","import { publicKey, decimalU128, Parser } from \"../util/layout\";\nimport { struct, s32, u8, blob, seq } from \"@solana/buffer-layout\";\nimport Decimal from \"decimal.js\";\nimport { AccountInfo, PublicKey } from \"@solana/web3.js\";\n\nexport const POSITIONS_ACCOUNT_SIZE = 360000;\n\nexport interface Position {\n  nftTokenId: PublicKey;\n  lowerTick: number;\n  upperTick: number;\n  liquity: Decimal;\n  feeGrowthInsideALast: Decimal;\n  feeGrowthInsideBLast: Decimal;\n  tokenAFee: Decimal;\n  tokenBFee: Decimal;\n}\n\nexport interface PositionsAccount {\n  swapVersion: number;\n  tokenSwapKey: PublicKey;\n  accountType: number;\n  len: number;\n  positions: Position[];\n}\n\n/* @internal */\nexport interface PositionsAccountDataFlat {\n  swapVersion: number;\n  tokenSwapKey: PublicKey;\n  accountType: number;\n  len: number;\n  dataFlat: Uint8Array;\n}\n\nexport const PositionLayout = struct<Position>(\n  [\n    publicKey(\"nftTokenId\"),\n    s32(\"lowerTick\"),\n    s32(\"upperTick\"),\n    decimalU128(\"liquity\"),\n    decimalU128(\"feeGrowthInsideALast\", 16),\n    decimalU128(\"feeGrowthInsideBLast\", 16),\n    decimalU128(\"tokenAFee\", 16),\n    decimalU128(\"tokenBFee\", 16),\n  ],\n  \"position\"\n);\n\nexport const PositionsAccountLayout = struct<PositionsAccountDataFlat>(\n  [\n    u8(\"swapVersion\"),\n    publicKey(\"tokenSwapKey\"),\n    u8(\"accountType\"),\n    s32(\"len\"),\n    blob(POSITIONS_ACCOUNT_SIZE - 38, \"dataFlat\"),\n  ],\n  \"positionsAccount\"\n);\n\nexport const MAX_ACCOUNT_POSITION_LENGTH = Math.floor(\n  (POSITIONS_ACCOUNT_SIZE - 38) / PositionLayout.span\n);\n\nexport const isPositionsAccount = (info: AccountInfo<Buffer>): boolean => {\n  return info.data.length === POSITIONS_ACCOUNT_SIZE;\n};\n\nexport const parsePositionsAccount: Parser<PositionsAccount> = (\n  pubkey: PublicKey,\n  info: AccountInfo<Buffer>\n) => {\n  if (!isPositionsAccount(info)) return;\n\n  const buffer = Buffer.from(info.data);\n  const {\n    swapVersion,\n    tokenSwapKey,\n    accountType,\n    len,\n    dataFlat,\n  } = PositionsAccountLayout.decode(buffer);\n\n  const positionSpan = len * PositionLayout.span;\n  const positionsBuffer = dataFlat.slice(0, positionSpan);\n  const positions = seq(PositionLayout, len).decode(positionsBuffer);\n\n  const positionsAccount: PositionsAccount = {\n    swapVersion,\n    tokenSwapKey,\n    accountType,\n    len,\n    positions,\n  };\n\n  return {\n    pubkey,\n    info,\n    data: positionsAccount,\n  };\n};\n","import { decimalU128, decimalU64, Parser, publicKey } from \"../util/layout\";\nimport { u8, u32, struct } from \"@solana/buffer-layout\";\nimport { AccountInfo, PublicKey } from \"@solana/web3.js\";\nimport Decimal from \"decimal.js\";\n\nexport interface TokenSwapAccount {\n  tokenSwapKey: PublicKey;\n  accountType: number;\n  version: number;\n  isInitialized: number;\n  nonce: number;\n  tokenProgramId: PublicKey;\n  manager: PublicKey;\n  managerTokenA: PublicKey;\n  managerTokenB: PublicKey;\n  swapTokenA: PublicKey;\n  swapTokenB: PublicKey;\n  tokenAMint: PublicKey;\n  tokenBMint: PublicKey;\n  ticksKey: PublicKey;\n  positionsKey: PublicKey;\n  curveType: number;\n  fee: Decimal;\n  managerFee: Decimal;\n  tickSpace: number;\n  currentSqrtPrice: Decimal;\n  currentLiquity: Decimal;\n  feeGrowthGlobal0: Decimal;\n  feeGrowthGlobal1: Decimal;\n  managerFeeA: Decimal;\n  managerFeeB: Decimal;\n}\n\nexport const TokenSwapAccountLayout = struct<TokenSwapAccount>(\n  [\n    publicKey(\"tokenSwapKey\"),\n    u8(\"accountType\"),\n    u8(\"version\"),\n    u8(\"isInitialized\"),\n    u8(\"nonce\"),\n    publicKey(\"tokenProgramId\"),\n    publicKey(\"manager\"),\n    publicKey(\"managerTokenA\"),\n    publicKey(\"managerTokenB\"),\n    publicKey(\"swapTokenA\"),\n    publicKey(\"swapTokenB\"),\n    publicKey(\"tokenAMint\"),\n    publicKey(\"tokenBMint\"),\n    publicKey(\"ticksKey\"),\n    publicKey(\"positionsKey\"),\n    u8(\"curveType\"),\n    decimalU64(\"fee\", 12),\n    decimalU64(\"managerFee\", 12),\n    u32(\"tickSpace\"),\n    decimalU128(\"currentSqrtPrice\", 12),\n    decimalU128(\"currentLiquity\"),\n    decimalU128(\"feeGrowthGlobal0\", 16),\n    decimalU128(\"feeGrowthGlobal1\", 16),\n    decimalU128(\"managerFeeA\"),\n    decimalU128(\"managerFeeB\"),\n  ],\n  \"tokenSwapAccount\"\n);\n\nexport const TOKEN_SWAP_ACCOUNT_SIZE = TokenSwapAccountLayout.span;\n\nexport const isTokenSwapAccount = (info: AccountInfo<Buffer>): boolean => {\n  return info.data.length === TOKEN_SWAP_ACCOUNT_SIZE;\n};\n\nexport const parseTokenSwapAccount: Parser<TokenSwapAccount> = (\n  pubkey: PublicKey,\n  info: AccountInfo<Buffer>\n) => {\n  if (!isTokenSwapAccount(info)) {\n    return;\n  }\n\n  const buffer = Buffer.from(info.data);\n  const tokenSwapAccount = TokenSwapAccountLayout.decode(buffer);\n\n  return {\n    pubkey,\n    info,\n    data: tokenSwapAccount,\n  };\n};\n","import { Decimal } from \"decimal.js\";\nimport invariant from \"tiny-invariant\";\nimport { Tick } from \"../state\";\n\n// The max ticker\nexport const MAX_TICK = 443632;\n// export const MAX_TICK = 552648\n\n// The min ticker\nexport const MIN_TICK = -MAX_TICK;\n\n// The price pieces\n// price = pow(PIECES, TICK)\nexport const PIECES = new Decimal(\"1.0001\");\nexport const PRICE_OFFSET = new Decimal(\"1e-12\");\nexport const MAX_PRICE = PIECES.pow(MAX_TICK);\nexport const MIN_PRICE = PIECES.pow(MIN_TICK);\nexport const MAX_SQRT_PRICE = PIECES.pow(MAX_TICK / 2);\nexport const MIN_SQRT_PRICE = PIECES.pow(MIN_TICK / 2);\n\n/**\n * Get the tick by sqrt price\n *\n * @param sqrtPrice the sqrt price\n * @return the tick\n */\nexport function sqrtPrice2Tick(sqrtPrice: Decimal): number {\n  invariant(\n    sqrtPrice.lessThan(MAX_SQRT_PRICE),\n    `Invalid sqrtPrice: ${sqrtPrice.toString()} Max: ${MAX_SQRT_PRICE}, too large`\n  );\n  invariant(\n    sqrtPrice.greaterThan(MIN_SQRT_PRICE),\n    `Invalid sqrtPrice: ${sqrtPrice.toString()}, Min: ${MIN_SQRT_PRICE}, too small`\n  );\n  return sqrtPrice\n    .pow(2)\n    .log(PIECES)\n    .toDP(0, Decimal.ROUND_HALF_UP)\n    .toNumber();\n}\n\n/**\n * Get the sqrt price by tick\n * @param tick the tick\n * @returns the sqrt price\n */\nexport function tick2SqrtPrice(tick: number): Decimal {\n  invariant(\n    tick >= MIN_TICK && tick <= MAX_TICK,\n    `Invalid tick: ${tick}, must be in range [${MIN_TICK}, ${MAX_TICK}]`\n  );\n  return PIECES.pow(tick / 2);\n}\n\n/**\n * Get the tick by price\n * @param price the price\n * @returns the tick\n */\nexport function price2Tick(price: Decimal): number {\n  invariant(\n    price.lessThan(MAX_PRICE),\n    `Invalid price:${price.toString()} Max: ${MAX_PRICE},  too large`\n  );\n  invariant(\n    price.greaterThan(MIN_PRICE),\n    `Invalid price:${price.toString()} Min: ${MIN_PRICE}, too small`\n  );\n  return price\n    .log(PIECES)\n    .toDP(0, Decimal.ROUND_HALF_UP)\n    .toNumber();\n}\n\n/**\n * Get the price by tick\n * @param tick the tick\n * @returns the price\n */\nexport function tick2Price(tick: number): Decimal {\n  invariant(\n    tick >= MIN_TICK && tick <= MAX_TICK,\n    `Invalid tick: ${tick}, must be in range [${MIN_TICK}, ${MAX_TICK}]`\n  );\n  return PIECES.pow(tick);\n}\n\n/**\n * Get the nearest valid tick\n * @deprecated please use {@link getNearestTickBySqrtPrice Or getNearestTickByPrice} instead\n * @param sqrtPrice the sqrt price\n * @param tickSpace the tick space\n * @param isLower is the tick is lowwer\n * @returns the tick or null\n */\nexport function getNearestTick(\n  sqrtPrice: Decimal,\n  tickSpace: number,\n  isLower: boolean\n): number | null {\n  return getNearestTickBySqrtPrice(sqrtPrice, tickSpace);\n}\n\n/**\n * Get the nearest valid tick for positions\n * @param sqrtPrice the sqrt price\n * @param tickSpace the tick space\n * @returns the tick or null(if the tick space <= 0)\n */\nexport function getNearestTickBySqrtPrice(\n  sqrtPrice: Decimal,\n  tickSpace: number\n): number {\n  invariant(\n    tickSpace > 0 && tickSpace % 1 === 0,\n    `Invalid tickSpace:${tickSpace}`\n  );\n  invariant(\n    sqrtPrice.lessThan(MAX_SQRT_PRICE),\n    `Invalid sqrtPrice: ${sqrtPrice.toString()} Max: ${MAX_SQRT_PRICE}, too large`\n  );\n  invariant(\n    sqrtPrice.greaterThan(MIN_SQRT_PRICE),\n    `Invalid sqrtPrice: ${sqrtPrice.toString()}, Min: ${MIN_SQRT_PRICE}, too small`\n  );\n  let t = sqrtPrice2Tick(sqrtPrice);\n  let m = (t - MIN_TICK) % tickSpace;\n  if (m > tickSpace / 2) {\n    return t - m + tickSpace;\n  }\n  return t - m;\n}\n\n/**\n * Get the nearest valid tick for positions\n * @param price the price\n * @param tickSpace the tick space\n * @returns the tick or null(if the tick space <= 0)\n */\nexport function getNearestTickByPrice(\n  price: Decimal,\n  tickSpace: number\n): number {\n  invariant(\n    tickSpace > 0 && tickSpace % 1 === 0,\n    `Invalid tickSpace:${tickSpace}`\n  );\n  invariant(\n    price.lessThan(MAX_PRICE),\n    `Invalid price:${price.toString()} Max: ${MAX_PRICE},  too large`\n  );\n  invariant(\n    price.greaterThan(MIN_PRICE),\n    `Invalid price:${price.toString()} Min: ${MIN_PRICE}, too small`\n  );\n  let t = price2Tick(price);\n  let m = (t - MIN_TICK) % tickSpace;\n  if (m > tickSpace / 2) {\n    return t - m + tickSpace;\n  }\n  return t - m;\n}\n\n/**\n *\n * @param ticks The tick array of token swap\n * @param currentSqrtPrice The current sqrt price of token swap\n * @param fee The fee rate of token swap\n * @param currentLiquity The current liquity of token swap\n * @param amountIn The amount in of token A\n * @returns amountOut:The amount out of token B, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate\n */\nexport function calculateSwapA2B(\n  ticks: Tick[],\n  currentSqrtPrice: Decimal,\n  fee: Decimal,\n  currentLiquity: Decimal,\n  amountIn: Decimal\n): {\n  amountOut: Decimal;\n  amountUsed: Decimal;\n  feeUsed: Decimal;\n  afterPrice: Decimal;\n  afterLiquity: Decimal;\n} {\n  invariant(amountIn.greaterThan(new Decimal(0)), \"invalid amount in\");\n  invariant(\n    currentLiquity.greaterThanOrEqualTo(new Decimal(0)),\n    \"invalid liquity\"\n  );\n  invariant(ticks.length > 0, \"the ticks is empty\");\n  //let currentTick = sqrtPrice2Tick(currentSqrtPrice);\n  invariant(currentSqrtPrice > ticks[0].tickPrice, \"out of ticks\");\n  let liquity = currentLiquity;\n  let out = new Decimal(0);\n  let remind = amountIn;\n  let remindWithFee = new Decimal(0);\n  let feeUsed = new Decimal(0);\n  let amountUsed = new Decimal(0);\n  for (let i = ticks.length - 1; i >= 0; i--) {\n    if (liquity.equals(new Decimal(0))) {\n      currentSqrtPrice = ticks[i].tickPrice.sub(PRICE_OFFSET);\n      liquity = liquity.sub(ticks[i].liquityNet);\n      //upperSqrtPrice = ticks[i].tickPrice;\n      continue;\n    }\n    if (currentSqrtPrice < ticks[i].tickPrice) {\n      continue;\n    }\n    let upperSqrtPrice = currentSqrtPrice;\n    let lowerSqrtPrice = ticks[i].tickPrice;\n    let maxAmountIn = maxAmountA(lowerSqrtPrice, currentSqrtPrice, liquity);\n    let fullStepFee = maxAmountIn.mul(fee).toDP(0, Decimal.ROUND_DOWN);\n    if (remind.lessThan(fullStepFee)) {\n      remindWithFee = remind;\n    } else {\n      remindWithFee = remind.sub(fullStepFee);\n    }\n\n    if (maxAmountIn.greaterThanOrEqualTo(remindWithFee)) {\n      remindWithFee = remind\n        .mul(new Decimal(1).sub(fee))\n        .toDP(0, Decimal.ROUND_UP);\n      let { amountOut, afterSqrtPrice } = swapA2B(\n        upperSqrtPrice,\n        liquity,\n        remindWithFee\n      );\n      amountUsed = amountUsed.add(remind);\n      feeUsed = feeUsed.add(remind.sub(remindWithFee));\n      return {\n        amountOut: out.add(amountOut),\n        amountUsed,\n        feeUsed,\n        afterPrice: afterSqrtPrice,\n        afterLiquity: liquity,\n      };\n    } else {\n      remind = remindWithFee.sub(maxAmountIn);\n      amountUsed = amountUsed.add(maxAmountIn).add(fullStepFee);\n      feeUsed = feeUsed.add(fullStepFee);\n      out = out.add(maxAmountB(lowerSqrtPrice, upperSqrtPrice, liquity));\n      liquity = liquity.sub(ticks[i].liquityNet);\n      currentSqrtPrice = ticks[i].tickPrice.sub(PRICE_OFFSET);\n      //upperSqrtPrice = ticks[i].tickPrice;\n    }\n  }\n  return {\n    amountOut: out,\n    amountUsed,\n    feeUsed,\n    afterPrice: currentSqrtPrice,\n    afterLiquity: liquity,\n  };\n}\n\n/**\n *\n * @param ticks The tick array of token swap\n * @param currentSqrtPrice The current sqrt price of token swap\n * @param fee The fee rate of token swap\n * @param currentLiquity The current liquity of token swap\n * @param amountIn The amount in of token B\n * @returns amountOut:The amount out of token B, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate\n */\nexport function calculateSwapB2A(\n  ticks: Tick[],\n  currentSqrtPrice: Decimal,\n  fee: Decimal,\n  currentLiquity: Decimal,\n  amountIn: Decimal\n): {\n  amountOut: Decimal;\n  amountUsed: Decimal;\n  feeUsed: Decimal;\n  afterPrice: Decimal;\n  afterLiquity: Decimal;\n} {\n  invariant(amountIn.greaterThan(new Decimal(0)), \"invalid amount in\");\n  invariant(\n    currentLiquity.greaterThanOrEqualTo(new Decimal(0)),\n    \"invalid liquity\"\n  );\n  invariant(ticks.length > 0, \"the ticks is empty\");\n  //let currentTick = sqrtPrice2Tick(currentSqrtPrice);\n  invariant(\n    currentSqrtPrice.lessThan(ticks[ticks.length - 1].tickPrice),\n    \"out of ticks\"\n  );\n  let liquity = currentLiquity;\n  let out = new Decimal(0);\n  let remind = amountIn;\n  let remindWithFee = new Decimal(0);\n  let amountUsed = new Decimal(0);\n  let feeUsed = new Decimal(0);\n  for (let i = 0; i < ticks.length; i++) {\n    if (liquity.equals(new Decimal(0))) {\n      currentSqrtPrice = ticks[i].tickPrice.add(PRICE_OFFSET);\n      liquity = liquity.add(ticks[i].liquityNet);\n      continue;\n    }\n    if (currentSqrtPrice > ticks[i].tickPrice) {\n      continue;\n    }\n    let upperSqrtPrice = ticks[i].tickPrice;\n    let maxAmountIn = maxAmountB(currentSqrtPrice, upperSqrtPrice, liquity);\n    let fullStepFee = maxAmountIn.mul(fee).toDP(0, Decimal.ROUND_DOWN);\n    if (remind.lessThan(fullStepFee)) {\n      remindWithFee = remind;\n    } else {\n      remindWithFee = remind.sub(fullStepFee);\n    }\n    if (maxAmountIn.greaterThanOrEqualTo(remindWithFee)) {\n      remindWithFee = remind\n        .mul(new Decimal(1).sub(fee))\n        .toDP(0, Decimal.ROUND_UP);\n      let { amountOut, afterSqrtPrice } = swapB2A(\n        currentSqrtPrice,\n        liquity,\n        remindWithFee\n      );\n      amountUsed = amountUsed.add(remind);\n      feeUsed = feeUsed.add(remind.sub(remindWithFee));\n      return {\n        amountOut: out.add(amountOut),\n        feeUsed,\n        amountUsed,\n        afterPrice: afterSqrtPrice.pow(2),\n        afterLiquity: liquity,\n      };\n    } else {\n      remind = remindWithFee.sub(maxAmountIn);\n      amountUsed = amountUsed.add(maxAmountIn).add(fullStepFee);\n      feeUsed = feeUsed.add(fullStepFee);\n      out = out.add(maxAmountA(currentSqrtPrice, upperSqrtPrice, liquity));\n      liquity = liquity.add(ticks[i].liquityNet);\n      currentSqrtPrice = ticks[i].tickPrice.add(PRICE_OFFSET);\n    }\n  }\n  return {\n    amountOut: out,\n    amountUsed,\n    feeUsed,\n    afterPrice: currentSqrtPrice,\n    afterLiquity: liquity,\n  };\n}\n\n/** @internal */\nexport function maxAmountA(\n  lowerSqrtPrice: Decimal,\n  upperSqrtPrice: Decimal,\n  liquity: Decimal\n): Decimal {\n  return liquity\n    .div(lowerSqrtPrice)\n    .toDP(0, Decimal.ROUND_DOWN)\n    .sub(liquity.div(upperSqrtPrice).toDP(0, Decimal.ROUND_DOWN));\n}\n\n/** @internal */\nexport function maxAmountB(\n  lowerSqrtPrice: Decimal,\n  upperSqrtPrice: Decimal,\n  liquity: Decimal\n): Decimal {\n  return liquity\n    .mul(upperSqrtPrice.sub(lowerSqrtPrice))\n    .toDP(0, Decimal.ROUND_DOWN);\n}\n\n/** @internal */\nexport function swapA2B(\n  upperSqrtPrice: Decimal,\n  liquity: Decimal,\n  amountIn: Decimal\n): { amountOut: Decimal; afterSqrtPrice: Decimal } {\n  let afterSqrtPrice = liquity.div(amountIn.add(liquity.div(upperSqrtPrice)));\n  let delta_increase = amountIn.add(\n    liquity.div(upperSqrtPrice).toDP(0, Decimal.ROUND_DOWN)\n  );\n  let out = liquity\n    .mul(upperSqrtPrice)\n    .toDP(0, Decimal.ROUND_DOWN)\n    .sub(\n      liquity\n        .mul(liquity)\n        .div(delta_increase)\n        .toDP(0, Decimal.ROUND_DOWN)\n    );\n  return { amountOut: out, afterSqrtPrice };\n}\n\n/** @internal */\nexport function swapB2A(\n  lowerSqrtPrice: Decimal,\n  liquity: Decimal,\n  amountIn: Decimal\n): { amountOut: Decimal; afterSqrtPrice: Decimal } {\n  let afterSqrtPrice = amountIn.div(liquity).add(lowerSqrtPrice);\n  let delta_increase = amountIn.add(\n    liquity.mul(lowerSqrtPrice).toDP(0, Decimal.ROUND_DOWN)\n  );\n  let out = liquity\n    .div(lowerSqrtPrice)\n    .toDP(0, Decimal.ROUND_DOWN)\n    .sub(\n      liquity\n        .mul(liquity)\n        .div(delta_increase)\n        .toDP(0, Decimal.ROUND_DOWN)\n    );\n  return { amountOut: out, afterSqrtPrice };\n}\n","import Decimal from \"decimal.js\";\nimport { Tick } from \"../state\";\nimport invariant from \"tiny-invariant\";\nimport { tick2SqrtPrice } from \"./tick\";\n\n/**\n * Calculate liquity and another token amount when current tick is in [tickLower, tickUpper]\n * @param tickLower The tick lower\n * @param tickUpper The tick upper\n * @param currentSqrtPrice The current sqrt price\n * @param desiredAmountSrc The src token amount\n * @param direct 0(desiredAmountSrc is TokenA), 1(desiredAmountSrc is TokenB)\n * @returns The liquity and dst token amount\n */\nexport function calculateLiquity(\n  tickLower: number,\n  tickUpper: number,\n  desiredAmountSrc: Decimal,\n  currentSqrtPrice: Decimal,\n  direct: number\n): {\n  desiredAmountDst: Decimal;\n  deltaLiquity: Decimal;\n} {\n  invariant(tickLower < tickUpper, \"The tickLower must less than tickUpper\");\n  let lowerSqrtPrice = tick2SqrtPrice(tickLower);\n  let upperSqrtPrice = tick2SqrtPrice(tickUpper);\n  invariant(\n    currentSqrtPrice.greaterThanOrEqualTo(lowerSqrtPrice) &&\n      currentSqrtPrice.lessThanOrEqualTo(upperSqrtPrice),\n    \"The current price must in [lowerPrice,upperPrice]\"\n  );\n  let one = new Decimal(1);\n  if (direct === 0) {\n    let deltaLiquity = desiredAmountSrc.div(\n      one.div(currentSqrtPrice).sub(one.div(upperSqrtPrice))\n    );\n    let desiredAmountDst = deltaLiquity.mul(\n      currentSqrtPrice.sub(lowerSqrtPrice)\n    );\n    return { desiredAmountDst, deltaLiquity };\n  } else {\n    let deltaLiquity = desiredAmountSrc.div(\n      currentSqrtPrice.sub(lowerSqrtPrice)\n    );\n    let desiredAmountDst = deltaLiquity.mul(\n      one.div(currentSqrtPrice).sub(one.div(upperSqrtPrice))\n    );\n    return { desiredAmountDst, deltaLiquity };\n  }\n}\n\n/**\n * Calculate amount out of token A and token B by liquity\n * @param tickLower The tick lower\n * @param tickUpper The tick upper\n * @param currentSqrtPrice The current sqrt price\n * @param liquity The liquity amount\n * @returns The amount of token A and token B\n */\nexport function calculateTokenAmount(\n  tickLower: number,\n  tickUpper: number,\n  liquity: Decimal,\n  currentSqrtPrice: Decimal\n): {\n  amountA: Decimal;\n  amountB: Decimal;\n} {\n  let lowerSqrtPrice = tick2SqrtPrice(tickLower);\n  let upperSqrtPrice = tick2SqrtPrice(tickUpper);\n  if (currentSqrtPrice.lessThan(lowerSqrtPrice)) {\n    return {\n      amountA: liquity.div(lowerSqrtPrice).sub(liquity.div(upperSqrtPrice)),\n      amountB: new Decimal(0),\n    };\n  } else if (currentSqrtPrice.greaterThan(upperSqrtPrice)) {\n    return {\n      amountA: new Decimal(0),\n      amountB: liquity.mul(upperSqrtPrice).sub(liquity.mul(lowerSqrtPrice)),\n    };\n  } else {\n    return {\n      amountA: liquity.div(currentSqrtPrice).sub(liquity.div(upperSqrtPrice)),\n      amountB: liquity.mul(currentSqrtPrice).sub(liquity.mul(lowerSqrtPrice)),\n    };\n  }\n}\n\n/**\n * Calculate liquity when current tick is less than tickLower\n * @param tickLower The tick lower\n * @param tickUpper The tick upper\n * @param desiredAmountA The desired amount of token A\n * @returns the liquity\n */\nexport function calculateLiquityOnlyA(\n  tickLower: number,\n  tickUpper: number,\n  desiredAmountA: Decimal\n): Decimal {\n  invariant(tickLower < tickUpper, \"The tickLower must less than tickUpper\");\n  let lowerSqrtPrice = tick2SqrtPrice(tickLower);\n  let upperSqrtPrice = tick2SqrtPrice(tickUpper);\n  let one = new Decimal(1);\n  return desiredAmountA.div(\n    one.div(lowerSqrtPrice).sub(one.div(upperSqrtPrice))\n  );\n}\n\n/**\n * Calculate liquity when current tick is less than tickLower\n * @param tickLower The tick lower\n * @param tickUpper The tick upper\n * @param desiredAmountA The desired amount of token B\n * @returns The liquity\n */\nexport function calculateLiquityOnlyB(\n  tickLower: number,\n  tickUpper: number,\n  desiredAmountB: Decimal\n): Decimal {\n  invariant(tickLower < tickUpper, \"The tickLower must less than tickUpper\");\n  let lowerSqrtPrice = tick2SqrtPrice(tickLower);\n  let upperSqrtPrice = tick2SqrtPrice(tickUpper);\n  return desiredAmountB.div(upperSqrtPrice.sub(lowerSqrtPrice));\n}\n\nexport interface Liquity {\n  lowerTick: number;\n  upperTick: number;\n  amount: Decimal;\n}\n/**\n * Calculate the liquitys table\n * @param ticks The tick array of token swap\n * @returns The min, max of liquity, and liquitys array\n */\nexport function calculateLiquityTable(\n  ticks: Tick[]\n): {\n  maxLiquity: Decimal;\n  minLiquity: Decimal;\n  liquitys: Liquity[];\n} {\n  let minLiquity = new Decimal(0);\n  let maxLiquity = new Decimal(0);\n  const liquitys: Liquity[] = [];\n  let liquity: Liquity = {\n    lowerTick: 0,\n    upperTick: 0,\n    amount: new Decimal(0),\n  };\n  for (let i = 0; i < ticks.length; i++) {\n    if (liquity.amount.equals(0)) {\n      liquity.lowerTick = ticks[i].tick;\n      liquity.amount = ticks[i].liquityNet;\n      continue;\n    }\n    liquity.upperTick = ticks[i].tick;\n    minLiquity =\n      liquity.amount.lessThan(minLiquity) || minLiquity.equals(0)\n        ? liquity.amount\n        : minLiquity;\n    maxLiquity = liquity.amount.greaterThan(maxLiquity)\n      ? liquity.amount\n      : maxLiquity;\n    liquitys.push({\n      lowerTick: liquity.lowerTick,\n      upperTick: liquity.upperTick,\n      amount: liquity.amount,\n    });\n    liquity.amount = liquity.amount.add(ticks[i].liquityNet);\n    liquity.lowerTick = ticks[i].tick;\n  }\n  return { maxLiquity, minLiquity, liquitys };\n}\n","import Decimal from \"decimal.js\";\nimport invariant from \"tiny-invariant\";\nimport { sendAndConfirmTransaction } from \"./util\";\nimport { TransactionSignature } from \"@solana/web3.js\";\nimport { MintLayout, Token, TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport {\n  addUserPositionInstruction,\n  claimInstruction,\n  depositAllTokenTypesInstruction,\n  initializeInstruction,\n  managerClaimInstruction,\n  swapInstruction,\n  withdrawAllTokenTypesInstruction,\n  simulateSwapInstruction,\n} from \"./instructions\";\nimport {\n  TICKS_ACCOUNT_SIZE,\n  POSITIONS_ACCOUNT_SIZE,\n  TOKEN_SWAP_ACCOUNT_SIZE,\n  MAX_ACCOUNT_POSITION_LENGTH,\n} from \"./state\";\nimport {\n  Connection,\n  PublicKey,\n  Signer,\n  Keypair,\n  GetProgramAccountsConfig,\n  Transaction,\n  SystemProgram,\n} from \"@solana/web3.js\";\nimport {\n  isPositionsAccount,\n  isTicksAccount,\n  isTokenSwapAccount,\n  parsePositionsAccount,\n  parseTicksAccount,\n  parseTokenSwapAccount,\n  Tick,\n  TokenSwapAccount,\n} from \"./state\";\nimport {\n  createAssociatedTokenAccountInstruction,\n  getAssociatedTokenAddress,\n  getTokenAccounts,\n} from \"./util/token\";\nimport {\n  sqrtPrice2Tick,\n  calculateLiquity,\n  calculateLiquityOnlyA,\n  calculateLiquityOnlyB,\n  getNearestTickByPrice,\n  calculateTokenAmount,\n  calculateSwapA2B,\n  calculateSwapB2A,\n} from \"./math\";\n\nexport const INIT_KEY = new PublicKey(\"11111111111111111111111111111111\");\n\nexport interface PositionInfo {\n  positionsKey: PublicKey;\n  index: Decimal;\n  positionId: PublicKey;\n  lowerTick: number;\n  upperTick: number;\n  liquity: Decimal;\n  feeGrowthInsideALast: Decimal;\n  feeGrowthInsideBLast: Decimal;\n  tokenAFee: Decimal;\n  tokenBFee: Decimal;\n}\n\nDecimal.config({\n  precision: 64,\n  rounding: Decimal.ROUND_HALF_DOWN,\n  toExpNeg: -64,\n  toExpPos: 64,\n});\n\n/**\n * The token swap class\n */\nexport class TokenSwap {\n  private conn: Connection;\n  private programId: PublicKey = INIT_KEY;\n  private tokenSwapKey: PublicKey = INIT_KEY;\n  public payer: Signer | null;\n  public authority: PublicKey = INIT_KEY;\n  public isLoaded: boolean = false;\n  public currentTick: number = 0;\n  public tokenSwapInfo: TokenSwapAccount = {\n    tokenSwapKey: INIT_KEY,\n    accountType: 0,\n    version: 0,\n    isInitialized: 0,\n    nonce: 0,\n    tokenProgramId: TOKEN_PROGRAM_ID,\n    manager: INIT_KEY,\n    managerTokenA: INIT_KEY,\n    managerTokenB: INIT_KEY,\n    swapTokenA: INIT_KEY,\n    swapTokenB: INIT_KEY,\n    tokenAMint: INIT_KEY,\n    tokenBMint: INIT_KEY,\n    ticksKey: INIT_KEY,\n    positionsKey: INIT_KEY,\n    curveType: 0,\n    fee: new Decimal(0),\n    managerFee: new Decimal(0),\n    tickSpace: 0,\n    currentSqrtPrice: new Decimal(0),\n    currentLiquity: new Decimal(0),\n    feeGrowthGlobal0: new Decimal(0),\n    feeGrowthGlobal1: new Decimal(0),\n    managerFeeA: new Decimal(0),\n    managerFeeB: new Decimal(0),\n  };\n  public ticks: Tick[] = [];\n  public positions: Map<string, PositionInfo>;\n  public positionsKeys: Map<PublicKey, number>;\n\n  /**\n   * The constructor of TokenSwap\n   * @param conn The connection to use\n   * @param programId The token swap program id\n   * @param tokenSwapKey The token swap key\n   * @param payer The default pays for the transaction\n   */\n  constructor(\n    conn: Connection,\n    programId: PublicKey,\n    tokenSwapKey: PublicKey,\n    payer: Signer | null\n  ) {\n    this.conn = conn;\n    this.tokenSwapKey = tokenSwapKey;\n    this.programId = programId;\n    this.payer = payer;\n    this.positions = new Map();\n    this.positionsKeys = new Map();\n  }\n\n  /**\n   * Set the default payer\n   * @returns\n   */\n  setDefaultPayer(payer: Signer) {\n    this.payer = payer;\n  }\n\n  /**\n   * Load the token swap info\n   */\n  async load(): Promise<TokenSwap> {\n    let config: GetProgramAccountsConfig = {\n      encoding: \"base64\",\n      filters: [\n        {\n          memcmp: {\n            offset: 1,\n            bytes: this.tokenSwapKey.toBase58(),\n          },\n        },\n      ],\n    };\n    let accounts = await this.conn.getProgramAccounts(this.programId, config);\n    accounts.map((item) => {\n      if (isTokenSwapAccount(item.account)) {\n        let info = parseTokenSwapAccount(item.pubkey, item.account);\n        invariant(\n          info?.data !== undefined,\n          \"The token swap account parse failed\"\n        );\n        this.tokenSwapInfo = info.data;\n      } else if (isTicksAccount(item.account)) {\n        let info = parseTicksAccount(item.pubkey, item.account);\n        invariant(info?.data !== undefined, \"The tick account parse failed\");\n        this.ticks = info.data.ticks;\n      } else if (isPositionsAccount(item.account)) {\n        let info = parsePositionsAccount(item.pubkey, item.account);\n        invariant(\n          info?.data !== undefined,\n          \"The position account data parse failed\"\n        );\n        this.positionsKeys.set(item.pubkey, info.data.positions.length);\n        for (let i = 0; i < info.data.positions.length; i++) {\n          let p = info.data.positions[i];\n          this.positions.set(p.nftTokenId.toBase58(), {\n            positionsKey: item.pubkey,\n            index: new Decimal(i),\n            positionId: p.nftTokenId,\n            lowerTick: p.lowerTick,\n            upperTick: p.upperTick,\n            liquity: p.liquity,\n            feeGrowthInsideALast: p.feeGrowthInsideALast,\n            feeGrowthInsideBLast: p.feeGrowthInsideBLast,\n            tokenAFee: p.tokenAFee,\n            tokenBFee: p.tokenBFee,\n          });\n        }\n      } else {\n        console.log(\n          \"the account:%s length:%d unkown\",\n          item.pubkey.toString(),\n          item.account.data.length\n        );\n      }\n    });\n    if (this.authority.toString() === INIT_KEY.toString()) {\n      const [authority] = await PublicKey.findProgramAddress(\n        [this.tokenSwapKey.toBuffer()],\n        this.programId\n      );\n      this.authority = authority;\n    }\n    this.isLoaded = true;\n    this.currentTick = sqrtPrice2Tick(this.tokenSwapInfo.currentSqrtPrice);\n    return this;\n  }\n\n  /**\n   * Create a new token swap\n   * @param conn The connection to use\n   * @param programId The token swap program id\n   * @param payer Pays for the transaction\n   * @param tokenAMint The token A mint\n   * @param tokenBMint The token B mint\n   * @param manager The manager\n   * @param fee The fee of token swap\n   * @param managerFee The manager(protocol) fee of token swap\n   * @param tickSpace The tick space\n   * @param initializePrice The initilized price of token swap\n   * @param payer The pays for the transaction\n   */\n  static async createTokenSwap(\n    conn: Connection,\n    programId: PublicKey,\n    tokenAMint: PublicKey,\n    tokenBMint: PublicKey,\n    manager: PublicKey,\n    fee: Decimal,\n    managerFee: Decimal,\n    tickSpace: number,\n    initializePrice: Decimal,\n    payer: Signer,\n    isDebug: boolean = false\n  ): Promise<TokenSwap> {\n    // generate account create instruction that token swap need\n    const tokenSwapAccount = Keypair.generate();\n    const ticksAccount = Keypair.generate();\n    const positionsAccount = Keypair.generate();\n    const [authority, nonce] = await PublicKey.findProgramAddress(\n      [tokenSwapAccount.publicKey.toBuffer()],\n      programId\n    );\n    const ticksAccountLamports = await conn.getMinimumBalanceForRentExemption(\n      TICKS_ACCOUNT_SIZE\n    );\n    const positionsAccountLarports = await conn.getMinimumBalanceForRentExemption(\n      POSITIONS_ACCOUNT_SIZE\n    );\n    const tokenSwapAccountLamports = await conn.getMinimumBalanceForRentExemption(\n      TOKEN_SWAP_ACCOUNT_SIZE\n    );\n    let transaction = new Transaction().add(\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: tokenSwapAccount.publicKey,\n        lamports: tokenSwapAccountLamports,\n        space: TOKEN_SWAP_ACCOUNT_SIZE,\n        programId: programId,\n      }),\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: ticksAccount.publicKey,\n        lamports: ticksAccountLamports,\n        space: TICKS_ACCOUNT_SIZE,\n        programId: programId,\n      }),\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: positionsAccount.publicKey,\n        lamports: positionsAccountLarports,\n        space: POSITIONS_ACCOUNT_SIZE,\n        programId: programId,\n      })\n    );\n\n    // generate create token swap authority token account instruction\n    let swapTokenA = await getAssociatedTokenAddress(tokenAMint, authority);\n    let swapTokenB = await getAssociatedTokenAddress(tokenBMint, authority);\n    transaction.add(\n      createAssociatedTokenAccountInstruction(\n        tokenAMint,\n        swapTokenA,\n        authority,\n        payer.publicKey\n      ),\n      createAssociatedTokenAccountInstruction(\n        tokenBMint,\n        swapTokenB,\n        authority,\n        payer.publicKey\n      )\n    );\n\n    // generate token swap initialize instruction\n    const currentSqrtPrice = initializePrice.sqrt();\n    const tokenA = new Token(conn, tokenAMint, TOKEN_PROGRAM_ID, payer);\n    const tokenB = new Token(conn, tokenBMint, TOKEN_PROGRAM_ID, payer);\n    const managerTokenA = await tokenA.getOrCreateAssociatedAccountInfo(\n      manager\n    );\n    const managerTokenB = await tokenB.getOrCreateAssociatedAccountInfo(\n      manager\n    );\n\n    const curveType = 0;\n    transaction.add(\n      initializeInstruction(\n        programId,\n        tokenSwapAccount.publicKey,\n        authority,\n        manager,\n        managerTokenA.address,\n        managerTokenB.address,\n        swapTokenA,\n        swapTokenB,\n        ticksAccount.publicKey,\n        positionsAccount.publicKey,\n        nonce,\n        curveType,\n        fee,\n        managerFee,\n        tickSpace,\n        currentSqrtPrice\n      )\n    );\n\n    // send and confirm transaction\n    const tx = await sendAndConfirmTransaction(\n      conn,\n      transaction,\n      payer,\n      tokenSwapAccount,\n      ticksAccount,\n      positionsAccount\n    );\n    if (isDebug) {\n      console.log(tx);\n    }\n\n    return await new TokenSwap(\n      conn,\n      programId,\n      tokenSwapAccount.publicKey,\n      payer\n    ).load();\n  }\n\n  /**\n   *\n   * @param userTokenA The user address of token A\n   * @param userTokenB The user address of token B\n   * @param lowerTick The lower tick\n   * @param upperTick The upper tick\n   * @param liquity The liquity amount\n   * @param maximumAmountA The maximum amount of Token A\n   * @param maximumAmountB The maximum amount of Token B\n   * @param userTransferAuthroity The pays for the transaction\n   * @returns\n   */\n  async mintPosition(\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    lowerTick: number,\n    upperTick: number,\n    liquity: Decimal,\n    maximumAmountA: Decimal,\n    maximumAmountB: Decimal,\n    userTransferAuthroity: Signer,\n    payer: Signer | null = null\n  ): Promise<TransactionSignature | null> {\n    if (this.isLoaded) {\n      await this.load();\n    }\n    invariant(\n      lowerTick < upperTick,\n      \"The lowerTick must be less than upperTick\"\n    );\n    payer = payer != null ? payer : this.payer;\n    invariant(payer != null, \"The payer is null\");\n\n    // Generate create position nft token instructions\n    const nftMintAccount = Keypair.generate();\n    const nftUser = await getAssociatedTokenAddress(\n      nftMintAccount.publicKey,\n      payer.publicKey\n    );\n    const accountLamports = await Token.getMinBalanceRentForExemptAccount(\n      this.conn\n    );\n    const positionsKey = this.choosePosition();\n    invariant(positionsKey != null, \"The position account space is full\");\n    let transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: nftMintAccount.publicKey,\n        lamports: accountLamports,\n        space: MintLayout.span,\n        programId: TOKEN_PROGRAM_ID,\n      }),\n      Token.createInitMintInstruction(\n        TOKEN_PROGRAM_ID,\n        nftMintAccount.publicKey,\n        0,\n        this.authority,\n        null\n      ),\n      createAssociatedTokenAccountInstruction(\n        nftMintAccount.publicKey,\n        nftUser,\n        payer.publicKey,\n        payer.publicKey\n      )\n    );\n\n    // Generate mint positon instruction\n    transaction.add(\n      depositAllTokenTypesInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        userTransferAuthroity.publicKey,\n        userTokenA,\n        userTokenB,\n        this.tokenSwapInfo.swapTokenA,\n        this.tokenSwapInfo.swapTokenB,\n        nftMintAccount.publicKey,\n        nftUser,\n        this.tokenSwapInfo.ticksKey,\n        positionsKey,\n        0,\n        lowerTick,\n        upperTick,\n        liquity,\n        maximumAmountA,\n        maximumAmountB,\n        new Decimal(0)\n      )\n    );\n\n    // send and confirm transaction\n    return await sendAndConfirmTransaction(\n      this.conn,\n      transaction,\n      payer,\n      userTransferAuthroity,\n      nftMintAccount\n    );\n  }\n\n  /**\n   * Increase liquity on a exist position\n   * @param positionId The position id (nft mint address)\n   * @param userTokenA The user address of token A\n   * @param userTokenB The user address of token B\n   * @param lowerTick The lower tick\n   * @param upperTick The upper tick\n   * @param liquity The liquity amount\n   * @param maximumAmountA The maximum of token A\n   * @param maximumAmountB The maximum of token B\n   * @returns\n   */\n  async increaseLiquity(\n    positionId: PublicKey,\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    liquity: Decimal,\n    maximumAmountA: Decimal,\n    maximumAmountB: Decimal,\n    payer: Signer | null = null\n  ): Promise<TransactionSignature | null> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    const positionInfo = this.getPositionInfo(positionId);\n    invariant(positionInfo != undefined, `Position:${positionId} not found`);\n    payer = payer != null ? payer : this.payer;\n    invariant(payer !== null, \"The payer is null\");\n\n    let nftToken = new Token(this.conn, positionId, TOKEN_PROGRAM_ID, payer);\n    let nftUser = await nftToken.getAccountInfo(\n      await getAssociatedTokenAddress(nftToken.publicKey, payer.publicKey)\n    );\n    invariant(\n      nftUser.amount.toNumber() === 1,\n      `You not hold this position:${nftToken.publicKey.toBase58()}`\n    );\n\n    // Generate mint positon instruction\n    let transaction = new Transaction();\n    transaction.add(\n      depositAllTokenTypesInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        payer.publicKey,\n        userTokenA,\n        userTokenB,\n        this.tokenSwapInfo.swapTokenA,\n        this.tokenSwapInfo.swapTokenB,\n        positionId,\n        nftUser.address,\n        this.tokenSwapInfo.ticksKey,\n        positionInfo.positionsKey,\n        1,\n        positionInfo.lowerTick,\n        positionInfo.upperTick,\n        liquity,\n        maximumAmountA,\n        maximumAmountB,\n        positionInfo.index\n      )\n    );\n\n    // send and confirm transaction\n    return await sendAndConfirmTransaction(this.conn, transaction, payer);\n  }\n\n  /**\n   * Decrease liquity, after decrease if liquity amount is zero the position will be remove\n   * @param positionId The position id (nft mint address)\n   * @param userTokenA The user address of token A\n   * @param userTokenB The user address of token B\n   * @param liquity The liquity amount\n   * @param minimumAmountA The minimum amount of token A want recv\n   * @param minimumAmountB The minimum amount of token b want recv\n   * @param userAuthroity The pays for the transaction\n   * @returns\n   */\n  async decreaseLiquity(\n    positionId: PublicKey,\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    liquity: Decimal,\n    minimumAmountA: Decimal,\n    minimumAmountB: Decimal,\n    payer: Signer | null = null\n  ): Promise<TransactionSignature | null> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    const positionInfo = this.getPositionInfo(positionId);\n    invariant(positionInfo != undefined, `Position:${positionId} not found`);\n    payer = payer != null ? payer : this.payer;\n    invariant(payer !== null, \"The payer is null\");\n    let nftToken = new Token(this.conn, positionId, TOKEN_PROGRAM_ID, payer);\n    let nftUser = await nftToken.getAccountInfo(\n      await getAssociatedTokenAddress(nftToken.publicKey, payer.publicKey)\n    );\n    invariant(\n      nftUser.amount.toNumber() === 1,\n      `You not hold this position:${nftToken.publicKey.toBase58()}`\n    );\n\n    // Create withdrawAllTokenTypes instruction\n    let transaction = new Transaction().add(\n      withdrawAllTokenTypesInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        payer.publicKey,\n        this.tokenSwapInfo.swapTokenA,\n        this.tokenSwapInfo.swapTokenB,\n        userTokenA,\n        userTokenB,\n        positionId,\n        nftUser.address,\n        this.tokenSwapInfo.ticksKey,\n        positionInfo.positionsKey,\n        liquity,\n        minimumAmountA,\n        minimumAmountB,\n        positionInfo.index\n      )\n    );\n\n    // send and confirm transaction\n    return await sendAndConfirmTransaction(this.conn, transaction, payer);\n  }\n\n  /**\n   *\n   * @param userSource The token that user want swap out\n   * @param userDestination The token that user want swap in\n   * @param direct 0-A swap B, 1-B swap A\n   * @param amountIn The amount in\n   * @param minimumAmountOut The minimum amount out\n   * @param userTransactionAuthority Account delegated to transfer user's tokens\n   * @returns\n   */\n  async swap(\n    userSource: PublicKey,\n    userDestination: PublicKey,\n    direct: number,\n    amountIn: Decimal,\n    minimumAmountOut: Decimal,\n    userTransferAuthority: Signer,\n    payer: Signer | null = null\n  ): Promise<TransactionSignature | null> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    payer = payer != null ? payer : this.payer;\n    invariant(payer !== null, \"The payer is null\");\n    let { swapSrc, swapDst } =\n      direct === 1\n        ? {\n            swapSrc: this.tokenSwapInfo.swapTokenA,\n            swapDst: this.tokenSwapInfo.swapTokenB,\n          }\n        : {\n            swapSrc: this.tokenSwapInfo.swapTokenB,\n            swapDst: this.tokenSwapInfo.swapTokenA,\n          };\n\n    let transaction = new Transaction().add(\n      swapInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        userTransferAuthority.publicKey,\n        userSource,\n        userDestination,\n        swapSrc,\n        swapDst,\n        this.tokenSwapInfo.ticksKey,\n        amountIn,\n        minimumAmountOut\n      )\n    );\n\n    // send and confirm transaction\n    return await sendAndConfirmTransaction(\n      this.conn,\n      transaction,\n      payer,\n      userTransferAuthority\n    );\n  }\n\n  async simulateSwap(amountIn: Decimal, direction: number, payer: Signer) {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    let transaction = new Transaction().add(\n      simulateSwapInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.tokenSwapInfo.ticksKey,\n        amountIn,\n        direction\n      )\n    );\n\n    let res = await this.conn.simulateTransaction(transaction, [payer]);\n    console.log(res);\n  }\n\n  /**\n   *\n   * Collect fee from specified position\n   * @param positionID The NFT token public key of position\n   * @param userTokenA The user address of token A\n   * @param userTokenB The user address of token B\n   * @param userAuthroity The pays for the transaction\n   * @returns\n   */\n  async collect(\n    positionId: PublicKey,\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    payer: Signer | null = null\n  ): Promise<TransactionSignature | null> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    const positionInfo = this.getPositionInfo(positionId);\n    invariant(positionInfo != undefined, `Position:${positionId} not found`);\n    payer = payer != null ? payer : this.payer;\n    invariant(payer !== null, \"The payer is null\");\n    let nftToken = new Token(this.conn, positionId, TOKEN_PROGRAM_ID, payer);\n    let nftUser = await nftToken.getAccountInfo(\n      await getAssociatedTokenAddress(nftToken.publicKey, payer.publicKey)\n    );\n    invariant(\n      nftUser.amount.toNumber() === 1,\n      `You not hold this position:${nftToken.publicKey.toBase58()}`\n    );\n\n    let transaction = new Transaction().add(\n      claimInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        payer.publicKey,\n        this.tokenSwapInfo.swapTokenB,\n        this.tokenSwapInfo.swapTokenB,\n        userTokenA,\n        userTokenB,\n        positionId,\n        nftUser.address,\n        this.tokenSwapInfo.ticksKey,\n        positionInfo.positionsKey,\n        positionInfo.index\n      )\n    );\n\n    // send and confirm transaction\n    return await sendAndConfirmTransaction(this.conn, transaction, payer);\n  }\n\n  /**\n   * Collect the manager fee\n   * @param userTokenA The manager address of token A\n   * @param userTokenB The manager address of token B\n   * @param userAuthroity The pays for the transaction\n   * @returns\n   */\n  async managerCollect(\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    payer: Signer | null = null\n  ): Promise<TransactionSignature | null> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    payer = payer != null ? payer : this.payer;\n    invariant(payer !== null, \"The payer is null\");\n    let transaction = new Transaction().add(\n      managerClaimInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        payer.publicKey,\n        this.tokenSwapInfo.swapTokenA,\n        this.tokenSwapInfo.swapTokenB,\n        userTokenA,\n        userTokenB\n      )\n    );\n\n    // send and confirm transaction\n    return await sendAndConfirmTransaction(this.conn, transaction, payer);\n  }\n\n  /**\n   * Add a positions account for token swap\n   * @param payer The pays for transaction\n   * @returns\n   */\n  async addPositionsAccount(\n    payer: Signer | null = null\n  ): Promise<TransactionSignature | null> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    payer = payer != null ? payer : this.payer;\n    invariant(payer !== null, \"The payer is null\");\n    let positionsAccount = Keypair.generate();\n    let lamports = await this.conn.getMinimumBalanceForRentExemption(\n      POSITIONS_ACCOUNT_SIZE\n    );\n    let transaction = new Transaction().add(\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: positionsAccount.publicKey,\n        lamports,\n        space: POSITIONS_ACCOUNT_SIZE,\n        programId: this.programId,\n      }),\n      addUserPositionInstruction(\n        this.programId,\n        this.authority,\n        positionsAccount.publicKey\n      )\n    );\n\n    return await sendAndConfirmTransaction(\n      this.conn,\n      transaction,\n      payer,\n      positionsAccount\n    );\n  }\n\n  async approve(\n    userToken: PublicKey,\n    tokenMint: PublicKey,\n    amount: Decimal,\n    authority: Signer,\n    payer: Signer | null = null\n  ): Promise<void> {\n    payer = payer != null ? payer : this.payer;\n    invariant(payer !== null, \"The payer is null\");\n    let token = new Token(this.conn, tokenMint, TOKEN_PROGRAM_ID, payer);\n    await token.approve(\n      userToken,\n      authority.publicKey,\n      payer,\n      [],\n      amount.toNumber()\n    );\n  }\n\n  /**\n   * Get user's positions\n   * @param owner The owner of position\n   * @returns The positions list\n   */\n  async getUserPositions(\n    owner: PublicKey | undefined = undefined\n  ): Promise<PositionInfo[] | null> {\n    invariant(this.isLoaded, \"The token swap not load\");\n    owner = owner != undefined ? owner : this.payer?.publicKey;\n    invariant(owner !== undefined, \"The owner is undefined\");\n    let tokenAccounts = await getTokenAccounts(this.conn, owner);\n    let positions: PositionInfo[] = [];\n    for (let i = 0; i < tokenAccounts.length; i++) {\n      let position = this.positions.get(tokenAccounts[i].mint.toBase58());\n      if (position !== undefined) {\n        positions.push(position);\n      }\n    }\n    return positions;\n  }\n\n  /**\n   * Calculate the liquity and token A amount, when the token swap currentTick < upperTick\n   * @param tickLower The lower tick\n   * @param tickUpper the upper tick\n   * @param desiredAmountA The desired token A amount\n   * @returns\n   */\n  calculateLiquityByTokenA(\n    tickLower: number,\n    tickUpper: number,\n    desiredAmountA: Decimal\n  ): { desiredAmountB: Decimal; liquity: Decimal } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    invariant(\n      this.currentTick <= tickUpper,\n      \"The current price must less than lower price\"\n    );\n    if (this.currentTick < tickLower) {\n      return {\n        desiredAmountB: new Decimal(0),\n        liquity: calculateLiquityOnlyA(tickLower, tickUpper, desiredAmountA),\n      };\n    } else {\n      let res = calculateLiquity(\n        tickLower,\n        tickUpper,\n        desiredAmountA,\n        this.tokenSwapInfo.currentSqrtPrice,\n        0\n      );\n      return {\n        desiredAmountB: res.desiredAmountDst,\n        liquity: res.deltaLiquity,\n      };\n    }\n  }\n\n  /**\n   * Calculate the liquity and token B amount, when the token swap currentTick < upperTick\n   * @param tickLower The lower tick\n   * @param tickUpper the upper tick\n   * @param desiredAmountA The desired token B amount\n   * @returns\n   */\n  calculateLiquityByTokenB(\n    tickLower: number,\n    tickUpper: number,\n    desiredAmountB: Decimal\n  ): { desiredAmountA: Decimal; liquity: Decimal } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    invariant(\n      this.currentTick >= tickLower,\n      \"The current price must less than lower price\"\n    );\n    if (this.currentTick < tickUpper) {\n      return {\n        desiredAmountA: new Decimal(0),\n        liquity: calculateLiquityOnlyB(tickLower, tickUpper, desiredAmountB),\n      };\n    } else {\n      let res = calculateLiquity(\n        tickLower,\n        tickUpper,\n        desiredAmountB,\n        this.tokenSwapInfo.currentSqrtPrice,\n        1\n      );\n      return {\n        desiredAmountA: res.desiredAmountDst,\n        liquity: res.deltaLiquity,\n      };\n    }\n  }\n\n  /**\n   * Calculate the position current value\n   * @param positionId The position id\n   * @returns The amount of token A and token B\n   */\n  calculatePositionValue(\n    positionId: PublicKey\n  ): { liquity: Decimal; amountA: Decimal; amountB: Decimal } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    const positionInfo = this.getPositionInfo(positionId);\n    invariant(\n      positionInfo !== undefined,\n      `The position:${positionId.toBase58()} not found`\n    );\n    let { amountA, amountB } = calculateTokenAmount(\n      positionInfo.lowerTick,\n      positionInfo.upperTick,\n      positionInfo.liquity,\n      this.tokenSwapInfo.currentSqrtPrice\n    );\n    return {\n      liquity: positionInfo.liquity,\n      amountA,\n      amountB,\n    };\n  }\n\n  /**\n   * prepare calculate collect amount of token A and B\n   * @param positionId The position id\n   * @returns the amount of token A and B\n   */\n  preCollect(positionId: PublicKey): { amountA: Decimal; amountB: Decimal } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    const positionInfo = this.getPositionInfo(positionId);\n    invariant(\n      positionInfo !== undefined,\n      `The position:${positionId.toBase58()} not found`\n    );\n    let lowerTick: Tick | null = null;\n    let upperTick: Tick | null = null;\n    for (let i = 0; i < this.ticks.length; i++) {\n      if (this.ticks[i].tick == positionInfo.lowerTick) {\n        lowerTick = this.ticks[i];\n      }\n      if (this.ticks[i].tick == positionInfo.upperTick) {\n        upperTick = this.ticks[i];\n      }\n    }\n    invariant(\n      lowerTick !== null,\n      `The position lower tick:${positionInfo.lowerTick} not found`\n    );\n    invariant(\n      upperTick !== null,\n      `The position upper tick:${positionInfo.upperTick} not found`\n    );\n\n    let lowerFeeOutSideA = new Decimal(0);\n    let lowerFeeOutSideB = new Decimal(0);\n    let upperFeeOutSideA = new Decimal(0);\n    let upperFeeOutSideB = new Decimal(0);\n    let currentSqrtPrice = this.tokenSwapInfo.currentSqrtPrice;\n\n    if (lowerTick.tickPrice.lessThan(currentSqrtPrice)) {\n      lowerFeeOutSideA = lowerTick.feeGrowthOutside0;\n      lowerFeeOutSideB = lowerTick.feeGrowthOutside1;\n    } else {\n      lowerFeeOutSideA = this.tokenSwapInfo.feeGrowthGlobal0.sub(\n        lowerTick.feeGrowthOutside0\n      );\n      lowerFeeOutSideB = this.tokenSwapInfo.feeGrowthGlobal1.sub(\n        lowerTick.feeGrowthOutside1\n      );\n    }\n\n    if (upperTick.tickPrice.lessThan(currentSqrtPrice)) {\n      upperFeeOutSideA = this.tokenSwapInfo.feeGrowthGlobal0.sub(\n        upperTick.feeGrowthOutside0\n      );\n      upperFeeOutSideB = this.tokenSwapInfo.feeGrowthGlobal1.sub(\n        upperTick.feeGrowthOutside1\n      );\n    } else {\n      upperFeeOutSideA = upperTick.feeGrowthOutside0;\n      upperFeeOutSideB = upperTick.feeGrowthOutside1;\n    }\n\n    return {\n      amountA: this.tokenSwapInfo.feeGrowthGlobal0\n        .sub(lowerFeeOutSideA)\n        .sub(upperFeeOutSideA)\n        .sub(positionInfo.feeGrowthInsideALast)\n        .mul(positionInfo.liquity)\n        .add(positionInfo.tokenAFee),\n      amountB: this.tokenSwapInfo.feeGrowthGlobal1\n        .sub(lowerFeeOutSideB)\n        .sub(upperFeeOutSideB)\n        .sub(positionInfo.feeGrowthInsideBLast)\n        .mul(positionInfo.liquity)\n        .add(positionInfo.tokenBFee),\n    };\n  }\n\n  /**\n   * Prepare calculate A swap B\n   * @param amountIn The amount input of token A\n   * @returns amountOut:The amount out of token B, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate\n   */\n  preSwapA(\n    amountIn: Decimal\n  ): {\n    amountOut: Decimal;\n    amountUsed: Decimal;\n    feeUsed: Decimal;\n    afterLiquity: Decimal;\n    impactA: Decimal;\n    impactB: Decimal;\n    transactionPriceA: Decimal;\n    transactionPriceB: Decimal;\n    afterPriceA: Decimal;\n    afterPriceB: Decimal;\n  } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    const res = calculateSwapA2B(\n      this.ticks,\n      this.tokenSwapInfo.currentSqrtPrice,\n      this.tokenSwapInfo.fee,\n      this.tokenSwapInfo.currentLiquity,\n      amountIn\n    );\n    let currentPriceA = this.tokenSwapInfo.currentSqrtPrice.pow(2);\n    let currentPriceB = new Decimal(1).div(currentPriceA);\n    let transactionPriceA = res.amountOut.div(res.amountUsed);\n    let transactionPriceB = res.amountUsed.div(res.amountOut);\n    let impactA = transactionPriceA\n      .sub(currentPriceA)\n      .div(currentPriceA)\n      .abs();\n    let impactB = transactionPriceB\n      .sub(currentPriceB)\n      .div(currentPriceB)\n      .abs();\n\n    let afterPriceA = res.afterPrice.pow(2);\n    let afterPriceB = new Decimal(1).div(afterPriceA);\n\n    return {\n      amountOut: res.amountOut,\n      amountUsed: res.amountUsed,\n      feeUsed: res.feeUsed,\n      afterPriceA,\n      afterPriceB,\n      afterLiquity: res.afterLiquity,\n      impactA,\n      impactB,\n      transactionPriceA,\n      transactionPriceB,\n    };\n  }\n\n  /**\n   * Prepare calculate B swap A\n   * @param amountIn The amount input of token B\n   * @returns amountOut:The amount out of token A, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate\n   */\n  preSwapB(\n    amountIn: Decimal\n  ): {\n    amountOut: Decimal;\n    amountUsed: Decimal;\n    feeUsed: Decimal;\n    afterLiquity: Decimal;\n    impactA: Decimal;\n    impactB: Decimal;\n    transactionPriceA: Decimal;\n    transactionPriceB: Decimal;\n    afterPriceA: Decimal;\n    afterPriceB: Decimal;\n  } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    const res = calculateSwapB2A(\n      this.ticks,\n      this.tokenSwapInfo.currentSqrtPrice,\n      this.tokenSwapInfo.fee,\n      this.tokenSwapInfo.currentLiquity,\n      amountIn\n    );\n    let currentPriceA = this.tokenSwapInfo.currentSqrtPrice.pow(2);\n    let currentPriceB = new Decimal(1).div(currentPriceA);\n    let transactionPriceA = res.amountUsed.div(res.amountOut);\n    let transactionPriceB = res.amountOut.div(res.amountUsed);\n    let impactA = transactionPriceA\n      .sub(currentPriceA)\n      .div(currentPriceA)\n      .abs();\n    let impactB = transactionPriceB\n      .sub(currentPriceB)\n      .div(currentPriceB)\n      .abs();\n    let afterPriceA = res.afterPrice.pow(2);\n    let afterPriceB = new Decimal(1).div(afterPriceA);\n\n    return {\n      amountOut: res.amountOut,\n      amountUsed: res.amountUsed,\n      feeUsed: res.feeUsed,\n      afterLiquity: res.afterLiquity,\n      impactA,\n      impactB,\n      transactionPriceA,\n      transactionPriceB,\n      afterPriceA,\n      afterPriceB,\n    };\n  }\n\n  /**\n   * Get nearest tick by price\n   * @param price The price\n   * @returns The tick\n   */\n  getNearestTickByPrice(price: Decimal): number {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return getNearestTickByPrice(price, this.tokenSwapInfo.tickSpace);\n  }\n\n  /* @internal */\n  getPositionInfo(positionId: PublicKey): PositionInfo | undefined {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return this.positions.get(positionId.toBase58());\n  }\n\n  /* @internal */\n  choosePosition(): PublicKey | null {\n    invariant(this.isLoaded, \"The token swap not load\");\n    for (let [key, val] of this.positionsKeys) {\n      if (val < MAX_ACCOUNT_POSITION_LENGTH) {\n        return key;\n      }\n    }\n    return null;\n  }\n\n  /* for debug */\n  log() {\n    let payer = this.payer !== null ? this.payer.publicKey.toBase58() : \"null\";\n    console.log(\n      JSON.stringify(\n        {\n          programId: this.programId.toString(),\n          tokenSwapKey: this.tokenSwapKey.toString(),\n          payer: payer,\n          authority: this.authority.toString(),\n          currentTick: this.currentTick,\n          currentPrice: this.tokenSwapInfo.currentSqrtPrice.pow(2).toString(),\n          tokenSwapInfo: {\n            accountType: this.tokenSwapInfo.accountType,\n            version: this.tokenSwapInfo.version,\n            isInitialized: this.tokenSwapInfo.isInitialized,\n            nonce: this.tokenSwapInfo.nonce,\n            manager: this.tokenSwapInfo.manager.toString(),\n            managerTokenA: this.tokenSwapInfo.managerTokenA.toString(),\n            managerTokenB: this.tokenSwapInfo.managerTokenB.toString(),\n            swapTokenA: this.tokenSwapInfo.swapTokenA.toString(),\n            swapTokenB: this.tokenSwapInfo.swapTokenB.toString(),\n            tokenAMint: this.tokenSwapInfo.tokenAMint.toString(),\n            tokenBMint: this.tokenSwapInfo.tokenBMint.toString(),\n            ticksKey: this.tokenSwapInfo.ticksKey.toString(),\n            positionsKey: this.tokenSwapInfo.positionsKey.toString(),\n            curveType: this.tokenSwapInfo.curveType,\n            fee: this.tokenSwapInfo.fee,\n            managerFee: this.tokenSwapInfo.managerFee,\n            tickSpace: this.tokenSwapInfo.tickSpace,\n            currentSqrtPrice: this.tokenSwapInfo.currentSqrtPrice,\n            currentLiquity: this.tokenSwapInfo.currentLiquity,\n            feeGrowthGlobal0: this.tokenSwapInfo.feeGrowthGlobal0,\n            feeGrowthGlobal1: this.tokenSwapInfo.feeGrowthGlobal1,\n            managerFeeA: this.tokenSwapInfo.managerFeeA,\n            managerFeeB: this.tokenSwapInfo.managerFeeB,\n          },\n          positions: Object.fromEntries(this.positions),\n          positionsKeys: Object.fromEntries(this.positionsKeys),\n          ticks: this.ticks,\n        },\n        null,\n        4\n      )\n    );\n  }\n}\n"],"names":["runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","Decimal","config","precision","rounding","ROUND_DOWN","toExpNeg","toExpPos","TokenSwapInstruction","TEN","P64","pow","MAX_INT64","div","sub","MIN_INT64","neg","MAX_UINT64","MAX_INT128","MIN_INT128","MAX_UINT128","DecimalExt","from64Buffer","buffer","invariant","Math","abs","ss","toString","bn","BN","join","add","fromU64Buffer","from128Buffer","fromU128Buffer","to64Buffer","v","mul","round","greaterThanOrEqualTo","lessThanOrEqualTo","isNeg","toBuffer","item","index","input","toU64Buffer","to128Buffer","toU128Buffer","encodeDecode","layout","decode","bind","encode","publicKey","property","blob","publicKeyLayout","offset","src","PublicKey","decimalU64","_decode","_encode","decimalU64Layout","Buffer","from","decimal","decimal128","decimal128Layout","decimalU128","decimalU128Layout","sendAndConfirmTransaction","conn","transaction","signers","realSendAndConfirmTransaction","skipPreflight","commitment","preflightCommitment","getAssociatedTokenAddress","tokenMint","owner","Token","ASSOCIATED_TOKEN_PROGRAM_ID","TOKEN_PROGRAM_ID","createAssociatedTokenAccountInstruction","associatedAccount","payer","address","getAccountInfo","account","data","accountInfo","parseTokenAccount","getTokenAccounts","getTokenAccountsByOwner","programId","accounts","accountInfos","pubkey","AccountLayout","mint","amount","u64","fromBuffer","delegateOption","delegatedAmount","isInitialized","isFrozen","isNativeOption","rentExemptReserve","isNative","closeAuthority","closeAuthorityOption","DataLayout","struct","u8","claimInstruction","tokenSwapKey","authority","userTransferAuthority","swapTokenA","swapTokenB","userTokenA","userTokenB","nftMint","nftUser","ticksKey","positionsKey","positionIndex","alloc","span","instruction","Claim","TransactionInstruction","isSigner","isWritable","s32","depositAllTokenTypesInstruction","isNewPosition","tickLower","tickUpper","liquityAmount","maximumTokenA","maximumTokenB","DepositAllTokenTypes","u32","initializeInstruction","manager","managerTokenA","managerTokenB","nonce","curveType","fee","managerFee","tickSpace","currentSqrtPrice","Initialize","currentLiquity","feeGrowthGlobal0","feeGrowthGlobal1","managerFeeA","managerFeeB","managerClaimInstruction","ManagerClaim","swapInstruction","userSource","userDestination","swapSource","swapDestination","amountIn","minimumAmountOut","Swap","withdrawAllTokenTypesInstruction","minimumTokenA","minimumTokenB","WithdrawAllTokenTypes","simulateSwapInstruction","direction","SimulateSwap","TickLayout","TicksAccountLayout","TICKS_ACCOUNT_SIZE","isTicksAccount","parseTicksAccount","swapVersion","accountType","len","ticksBuffer","dataFlat","ticks","seq","PositionLayout","PositionsAccountLayout","POSITIONS_ACCOUNT_SIZE","MAX_ACCOUNT_POSITION_LENGTH","floor","isPositionsAccount","parsePositionsAccount","positionsBuffer","positions","TokenSwapAccountLayout","TOKEN_SWAP_ACCOUNT_SIZE","isTokenSwapAccount","parseTokenSwapAccount","PIECES","PRICE_OFFSET","MAX_PRICE","MIN_PRICE","MAX_SQRT_PRICE","MAX_TICK","MIN_SQRT_PRICE","MIN_TICK","sqrtPrice2Tick","sqrtPrice","lessThan","greaterThan","log","toDP","ROUND_HALF_UP","toNumber","tick2SqrtPrice","tick","price2Tick","price","getNearestTickBySqrtPrice","t","m","getNearestTickByPrice","calculateSwapA2B","tickPrice","liquity","out","remind","remindWithFee","feeUsed","amountUsed","equals","liquityNet","upperSqrtPrice","lowerSqrtPrice","maxAmountIn","maxAmountA","fullStepFee","swapA2B","ROUND_UP","amountOut","afterSqrtPrice","afterPrice","afterLiquity","maxAmountB","calculateSwapB2A","swapB2A","delta_increase","calculateLiquity","desiredAmountSrc","direct","one","deltaLiquity","desiredAmountDst","calculateTokenAmount","amountA","amountB","calculateLiquityOnlyA","desiredAmountA","calculateLiquityOnlyB","desiredAmountB","INIT_KEY","ROUND_HALF_DOWN","TokenSwap","version","tokenProgramId","tokenAMint","tokenBMint","Map","positionsKeys","setDefaultPayer","load","encoding","filters","memcmp","bytes","toBase58","getProgramAccounts","map","_this","tokenSwapInfo","set","p","nftTokenId","positionId","lowerTick","upperTick","feeGrowthInsideALast","feeGrowthInsideBLast","tokenAFee","tokenBFee","console","findProgramAddress","isLoaded","currentTick","createTokenSwap","initializePrice","isDebug","tokenSwapAccount","Keypair","generate","ticksAccount","positionsAccount","getMinimumBalanceForRentExemption","ticksAccountLamports","positionsAccountLarports","tokenSwapAccountLamports","Transaction","SystemProgram","createAccount","fromPubkey","newAccountPubkey","lamports","space","sqrt","tokenA","tokenB","getOrCreateAssociatedAccountInfo","tx","mintPosition","maximumAmountA","maximumAmountB","userTransferAuthroity","nftMintAccount","getMinBalanceRentForExemptAccount","accountLamports","choosePosition","MintLayout","createInitMintInstruction","increaseLiquity","positionInfo","getPositionInfo","nftToken","decreaseLiquity","minimumAmountA","minimumAmountB","swap","swapSrc","swapDst","simulateSwap","simulateTransaction","collect","managerCollect","addPositionsAccount","AddUserPosition","approve","userToken","token","getUserPositions","_this$payer","tokenAccounts","position","get","calculateLiquityByTokenA","res","calculateLiquityByTokenB","calculatePositionValue","preCollect","lowerFeeOutSideA","lowerFeeOutSideB","upperFeeOutSideA","upperFeeOutSideB","feeGrowthOutside0","feeGrowthOutside1","preSwapA","currentPriceA","currentPriceB","transactionPriceA","transactionPriceB","impactA","impactB","afterPriceA","afterPriceB","preSwapB","JSON","stringify","currentPrice","fromEntries","minLiquity","maxLiquity","liquitys","decimal64Layout","isLower"],"mappings":"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"}