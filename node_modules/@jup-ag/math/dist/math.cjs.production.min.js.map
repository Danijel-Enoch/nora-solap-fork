{"version":3,"file":"math.cjs.production.min.js","sources":["../src/utils.ts","../src/math/curve.ts","../src/amm/stable.ts","../src/amm/fees.ts","../src/amm/tokenswap-stable.ts","../src/amm/tokenswap-constant-product.ts","../src/fraction.ts"],"sourcesContent":["import JSBI from 'jsbi';\nimport Decimal from 'decimal.js';\n\nexport type SwapResult = {\n  priceImpact: Decimal;\n  fees: JSBI;\n  expectedOutputAmount: JSBI;\n};\n\nexport const ZERO = JSBI.BigInt(0);\nexport const ONE = JSBI.BigInt(1);\nexport const TWO = JSBI.BigInt(2);\n\nexport function abs(number: JSBI) {\n  if (JSBI.GE(number, ZERO)) {\n    return number;\n  }\n\n  return JSBI.unaryMinus(number);\n}\n\nexport function sumArray(numbers: JSBI[]) {\n  return numbers.reduce((prev, curr) => {\n    return JSBI.add(prev, curr);\n  }, ZERO);\n}\n\nexport function mulArray(numbers: JSBI[]) {\n  return numbers.reduce((prev, curr) => {\n    return JSBI.multiply(prev, curr);\n  }, ONE);\n}\n\nexport function ceilingDivision(dividend: JSBI, divisor: JSBI): [JSBI, JSBI] {\n  let quotient = JSBI.divide(dividend, divisor);\n  if (JSBI.equal(quotient, ZERO)) {\n    return [ZERO, ZERO];\n  }\n\n  let remainder = JSBI.remainder(dividend, divisor);\n  if (JSBI.greaterThan(remainder, ZERO)) {\n    quotient = JSBI.add(quotient, ONE);\n    divisor = JSBI.divide(dividend, quotient);\n    remainder = JSBI.remainder(dividend, quotient);\n    if (JSBI.greaterThan(remainder, ZERO)) {\n      divisor = JSBI.add(divisor, ONE);\n    }\n  }\n\n  return [quotient, divisor];\n}\n\nexport function toDecimal(input: JSBI, shift = 0) {\n  return new Decimal(input.toString()).div(new Decimal(10).pow(shift));\n}\n","import JSBI from 'jsbi';\nimport { abs, mulArray, ONE, sumArray, TWO, ZERO } from '../utils';\nimport Decimal from 'decimal.js';\n\nexport class Curve {\n  constructor(private numberOfCurrencies: JSBI, private amplificationFactor: JSBI, private targetPrices: JSBI[]) {}\n\n  public exchange(\n    tokenAmounts: JSBI[],\n    inputIndex: number,\n    outputIndex: number,\n    amount: JSBI,\n    minusOne: boolean = true,\n  ) {\n    if (tokenAmounts.length !== JSBI.toNumber(this.numberOfCurrencies)) {\n      throw new Error('Number of currencies does not match');\n    }\n\n    let xp = this.xp(tokenAmounts);\n    let dx = JSBI.multiply(amount, this.targetPrices[inputIndex]);\n    let x = JSBI.add(xp[inputIndex], dx);\n    let y = this.computeY(tokenAmounts, inputIndex, outputIndex, x);\n    let dy = JSBI.subtract(xp[outputIndex], y);\n\n    // This is a special condition on Curve stable algo. For TokenSwap, they don't seem to apply this minus one.\n    if (minusOne) {\n      dy = JSBI.subtract(dy, ONE);\n    }\n\n    return JSBI.divide(dy, this.targetPrices[outputIndex]);\n  }\n\n  public computeBaseY(tokenAmounts: JSBI[], inputIndex: number, outputIndex: number, amount: JSBI) {\n    let d = this.computeD(tokenAmounts);\n    let xp = this.xp(tokenAmounts);\n    let nn = JSBI.exponentiate(this.numberOfCurrencies, this.numberOfCurrencies);\n    let sum = sumArray(xp);\n    let product = mulArray(xp);\n    let k = JSBI.subtract(\n      JSBI.add(JSBI.multiply(JSBI.multiply(this.amplificationFactor, nn), sum), d),\n      JSBI.multiply(JSBI.multiply(this.amplificationFactor, d), nn),\n    );\n    let b = JSBI.multiply(JSBI.multiply(JSBI.multiply(this.amplificationFactor, nn), nn), product);\n    let c = JSBI.multiply(JSBI.multiply(nn, product), k);\n    let numerator = JSBI.add(b, JSBI.divide(c, xp[inputIndex]));\n    let denominator = JSBI.add(b, JSBI.divide(c, xp[outputIndex]));\n\n    // Convert to number since JSBI doesn't support log10\n    let inputFactor = Math.log10(JSBI.toNumber(this.targetPrices[inputIndex]));\n    let outputFactor = Math.log10(JSBI.toNumber(this.targetPrices[outputIndex]));\n    let factor = Math.abs(outputFactor - inputFactor);\n\n    if (inputFactor >= outputFactor) {\n      return JSBI.BigInt(\n        new Decimal(numerator.toString())\n          .mul(new Decimal(amount.toString()))\n          .div(new Decimal(denominator.toString()))\n          .mul(Math.pow(10, factor))\n          .floor()\n          .toString(),\n      );\n    } else {\n      return JSBI.BigInt(\n        new Decimal(numerator.toString())\n          .mul(new Decimal(amount.toString()))\n          .div(new Decimal(denominator.toString()))\n          .div(Math.pow(10, factor))\n          .floor()\n          .toString(),\n      );\n    }\n  }\n\n  private computeY(tokenAmounts: JSBI[], inputIndex: number, outputIndex: number, newTotalAmount: JSBI) {\n    let d = this.computeD(tokenAmounts);\n    let xx = this.xp(tokenAmounts);\n    xx[inputIndex] = newTotalAmount;\n    xx.splice(outputIndex, 1);\n\n    let ann = JSBI.multiply(this.amplificationFactor, this.numberOfCurrencies);\n    let c = d;\n\n    for (const y of xx) {\n      c = JSBI.divide(JSBI.multiply(c, d), JSBI.multiply(y, this.numberOfCurrencies));\n    }\n    c = JSBI.divide(JSBI.multiply(c, d), JSBI.multiply(this.numberOfCurrencies, ann));\n\n    let b = JSBI.subtract(JSBI.add(sumArray(xx), JSBI.divide(d, ann)), d);\n    let yPrev = ZERO;\n    let y = d;\n\n    while (JSBI.greaterThan(abs(JSBI.subtract(y, yPrev)), ONE)) {\n      yPrev = y;\n      y = JSBI.divide(JSBI.add(JSBI.exponentiate(y, TWO), c), JSBI.add(JSBI.multiply(TWO, y), b));\n    }\n\n    return y;\n  }\n\n  private computeD(tokenAmounts: JSBI[]) {\n    let dPrev = ZERO;\n    let xp = this.xp(tokenAmounts);\n    let sum = sumArray(xp);\n    let d = sum;\n    let ann = JSBI.multiply(this.amplificationFactor, this.numberOfCurrencies);\n\n    while (JSBI.greaterThan(abs(JSBI.subtract(d, dPrev)), ONE)) {\n      let dP = d;\n      for (const x of xp) {\n        dP = JSBI.divide(JSBI.multiply(dP, d), JSBI.multiply(this.numberOfCurrencies, x));\n      }\n      dPrev = d;\n      let numerator = JSBI.multiply(JSBI.add(JSBI.multiply(ann, sum), JSBI.multiply(dP, this.numberOfCurrencies)), d);\n      let denominator = JSBI.add(\n        JSBI.multiply(JSBI.subtract(ann, ONE), d),\n        JSBI.multiply(JSBI.add(this.numberOfCurrencies, ONE), dP),\n      );\n      d = JSBI.divide(numerator, denominator);\n    }\n\n    return d;\n  }\n\n  private xp(tokenAmounts: JSBI[]) {\n    return tokenAmounts.map((tokenAmount, index) => {\n      return JSBI.multiply(tokenAmount, this.targetPrices[index]);\n    });\n  }\n}\n","import JSBI from 'jsbi';\nimport { Curve } from '../math/curve';\nimport { SwapResult, toDecimal, ZERO } from '../utils';\nimport Decimal from 'decimal.js';\nimport { Fraction } from '..';\n\nexport class Stable {\n  private curve: Curve;\n\n  constructor(numberOfCurrencies: JSBI, amp: JSBI, private targetPrices: JSBI[], private traderFee: Fraction) {\n    this.curve = new Curve(numberOfCurrencies, amp, this.targetPrices);\n  }\n\n  public exchange(tokenAmounts: JSBI[], inputTradeAmount: JSBI, inputIndex: number, outputIndex: number): SwapResult {\n    let outputAmountWithoutFees = this.getOutputAmount(tokenAmounts, inputTradeAmount, inputIndex, outputIndex);\n    let fees = this.getFees(outputAmountWithoutFees);\n    let expectedOutputAmount = JSBI.subtract(outputAmountWithoutFees, fees);\n\n    return {\n      priceImpact: this.getPriceImpact(tokenAmounts, inputTradeAmount, expectedOutputAmount, inputIndex, outputIndex),\n      fees: fees,\n      expectedOutputAmount: expectedOutputAmount,\n    };\n  }\n\n  private getPriceImpact(\n    tokenAmounts: JSBI[],\n    inputTradeAmountJSBI: JSBI,\n    expectedOutputAmountJSBI: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): Decimal {\n    if (\n      JSBI.equal(inputTradeAmountJSBI, ZERO) ||\n      JSBI.equal(tokenAmounts[inputIndex], ZERO) ||\n      JSBI.equal(tokenAmounts[outputIndex], ZERO)\n    ) {\n      return new Decimal(0);\n    }\n\n    const noSlippageOutputAmount = toDecimal(\n      this.getOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmountJSBI, inputIndex, outputIndex),\n    );\n    const expectedOutputAmount = toDecimal(expectedOutputAmountJSBI);\n    const impact = noSlippageOutputAmount.sub(expectedOutputAmount).div(noSlippageOutputAmount);\n\n    return impact;\n  }\n\n  private getFees(outputAmountWithoutFees: JSBI): JSBI {\n    return JSBI.equal(this.traderFee.numerator, ZERO)\n      ? ZERO\n      : JSBI.divide(JSBI.multiply(outputAmountWithoutFees, this.traderFee.numerator), this.traderFee.denominator);\n  }\n\n  private getOutputAmount(tokenAmounts: JSBI[], inputTradeAmount: JSBI, inputIndex: number, outputIndex: number): JSBI {\n    return this.curve.exchange(tokenAmounts, inputIndex, outputIndex, inputTradeAmount);\n  }\n\n  private getOutputAmountWithNoSlippage(\n    tokenAmounts: JSBI[],\n    inputTradeAmount: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): JSBI {\n    return this.curve.computeBaseY(tokenAmounts, inputIndex, outputIndex, inputTradeAmount);\n  }\n}\n","import JSBI from 'jsbi';\nimport { Fraction } from '../fraction';\nimport { ZERO, ONE } from '../utils';\n\n/** calculates fee amount given a fee fraction, returning one when fee is set but amount is zero */\nexport function calculateFeeAmount(amount: JSBI, fee: Fraction): JSBI {\n  if (JSBI.equal(fee.numerator, ZERO) || JSBI.equal(amount, ZERO)) {\n    return ZERO;\n  } else {\n    const feeAmount = JSBI.divide(JSBI.multiply(amount, fee.numerator), fee.denominator);\n    if (JSBI.equal(feeAmount, ZERO)) {\n      return ONE;\n    }\n    return feeAmount;\n  }\n}\n","import JSBI from 'jsbi';\nimport { Curve } from '../math/curve';\nimport { ONE, SwapResult, toDecimal, ZERO, TWO } from '../utils';\nimport Decimal from 'decimal.js';\nimport { Fraction } from '../fraction';\nimport { calculateFeeAmount } from './fees';\n\nexport class TokenSwapStable {\n  private curve: Curve;\n\n  constructor(amp: JSBI, private traderFee: Fraction, private ownerFee: Fraction) {\n    this.curve = new Curve(TWO, amp, [ONE, ONE]);\n  }\n\n  public exchange(tokenAmounts: JSBI[], inputTradeAmount: JSBI, outputIndex: number): SwapResult {\n    let inputIndex = outputIndex === 0 ? 1 : 0;\n    let expectedOutputAmount = this.getExpectedOutputAmount(tokenAmounts, inputTradeAmount, inputIndex, outputIndex);\n\n    return {\n      priceImpact: this.getPriceImpact(tokenAmounts, inputTradeAmount, expectedOutputAmount, inputIndex, outputIndex),\n      fees: this.getFees(inputTradeAmount),\n      expectedOutputAmount,\n    };\n  }\n\n  private getPriceImpact(\n    tokenAmounts: JSBI[],\n    inputTradeAmountJSBI: JSBI,\n    expectedOutputAmountJSBI: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): Decimal {\n    if (\n      JSBI.equal(inputTradeAmountJSBI, ZERO) ||\n      JSBI.equal(tokenAmounts[inputIndex], ZERO) ||\n      JSBI.equal(tokenAmounts[outputIndex], ZERO)\n    ) {\n      return new Decimal(0);\n    }\n\n    const noSlippageOutputAmount = toDecimal(\n      this.getExpectedOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmountJSBI, inputIndex, outputIndex),\n    );\n\n    const expectedOutputAmount = toDecimal(expectedOutputAmountJSBI);\n    const impact = noSlippageOutputAmount.sub(expectedOutputAmount).div(noSlippageOutputAmount);\n\n    return impact;\n  }\n\n  private getFees(inputTradeAmount: JSBI): JSBI {\n    const tradingFee = calculateFeeAmount(inputTradeAmount, this.traderFee);\n    const ownerFee = calculateFeeAmount(inputTradeAmount, this.ownerFee);\n\n    return JSBI.add(tradingFee, ownerFee);\n  }\n\n  private getExpectedOutputAmount(\n    tokenAmounts: JSBI[],\n    inputTradeAmount: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): JSBI {\n    const inputTradeAmountLessFees = this.getInputAmountLessFees(inputTradeAmount);\n\n    return this.getOutputAmount(tokenAmounts, inputTradeAmountLessFees, inputIndex, outputIndex);\n  }\n\n  private getExpectedOutputAmountWithNoSlippage(\n    tokenAmounts: JSBI[],\n    inputTradeAmount: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): JSBI {\n    const inputTradeAmountLessFees = this.getInputAmountLessFees(inputTradeAmount);\n\n    return this.getOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmountLessFees, inputIndex, outputIndex);\n  }\n\n  private getInputAmountLessFees(inputTradeAmount: JSBI): JSBI {\n    return JSBI.subtract(inputTradeAmount, this.getFees(inputTradeAmount));\n  }\n\n  private getOutputAmount(\n    tokenAmounts: JSBI[],\n    inputTradeAmountLessFees: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): JSBI {\n    return this.curve.exchange(tokenAmounts, inputIndex, outputIndex, inputTradeAmountLessFees, false);\n  }\n\n  private getOutputAmountWithNoSlippage(\n    tokenAmounts: JSBI[],\n    inputTradeAmountLessFees: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): JSBI {\n    return this.curve.computeBaseY(tokenAmounts, inputIndex, outputIndex, inputTradeAmountLessFees);\n  }\n}\n","import JSBI from 'jsbi';\nimport { SwapResult, toDecimal, ZERO, ceilingDivision } from '../utils';\nimport Decimal from 'decimal.js';\nimport { Fraction } from '..';\nimport { calculateFeeAmount } from './fees';\n\nexport class TokenSwapConstantProduct {\n  constructor(private traderFee: Fraction, private ownerFee: Fraction, private feesOnInput: boolean = true) {}\n\n  public exchange(tokenAmounts: JSBI[], inputTradeAmount: JSBI, outputIndex: number): SwapResult {\n    let inputIndex = outputIndex === 0 ? 1 : 0;\n    const newInputTradeAmount = this.feesOnInput ? this.getAmountLessFees(inputTradeAmount) : inputTradeAmount;\n\n    let expectedOutputAmount = this.getExpectedOutputAmount(tokenAmounts, newInputTradeAmount, inputIndex, outputIndex);\n\n    let fees = this.getFees(this.feesOnInput ? inputTradeAmount : expectedOutputAmount);\n\n    if (!this.feesOnInput) {\n      expectedOutputAmount = this.getAmountLessFees(expectedOutputAmount);\n    }\n\n    return {\n      priceImpact: this.getPriceImpact(\n        tokenAmounts,\n        newInputTradeAmount,\n        expectedOutputAmount,\n        inputIndex,\n        outputIndex,\n      ),\n      fees,\n      expectedOutputAmount,\n    };\n  }\n\n  private getPriceImpact(\n    tokenAmounts: JSBI[],\n    inputTradeAmountJSBI: JSBI,\n    expectedOutputAmountJSBI: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): Decimal {\n    if (\n      JSBI.equal(inputTradeAmountJSBI, ZERO) ||\n      JSBI.equal(tokenAmounts[inputIndex], ZERO) ||\n      JSBI.equal(tokenAmounts[outputIndex], ZERO)\n    ) {\n      return new Decimal(0);\n    }\n\n    const noSlippageOutputAmount = toDecimal(\n      this.getExpectedOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmountJSBI, inputIndex, outputIndex),\n    );\n    const expectedOutputAmount = toDecimal(expectedOutputAmountJSBI);\n    const impact = noSlippageOutputAmount.sub(expectedOutputAmount).div(noSlippageOutputAmount);\n\n    return impact;\n  }\n\n  private getFees(inputTradeAmount: JSBI): JSBI {\n    const tradingFee = calculateFeeAmount(inputTradeAmount, this.traderFee);\n    const ownerFee = calculateFeeAmount(inputTradeAmount, this.ownerFee);\n\n    return JSBI.add(tradingFee, ownerFee);\n  }\n\n  private getExpectedOutputAmount(\n    tokenAmounts: JSBI[],\n    inputTradeAmount: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): JSBI {\n    return this.getOutputAmount(tokenAmounts, inputTradeAmount, inputIndex, outputIndex);\n  }\n\n  private getExpectedOutputAmountWithNoSlippage(\n    tokenAmounts: JSBI[],\n    inputTradeAmount: JSBI,\n    inputIndex: number,\n    outputIndex: number,\n  ): JSBI {\n    if (JSBI.equal(tokenAmounts[inputIndex], ZERO)) {\n      return tokenAmounts[outputIndex];\n    }\n\n    let expectedOutputAmountWithNoSlippage = JSBI.divide(\n      JSBI.multiply(inputTradeAmount, tokenAmounts[outputIndex]),\n      tokenAmounts[inputIndex],\n    );\n\n    if (this.feesOnInput) {\n      return expectedOutputAmountWithNoSlippage;\n    } else {\n      return this.getAmountLessFees(expectedOutputAmountWithNoSlippage);\n    }\n  }\n\n  private getAmountLessFees(tradeAmount: JSBI): JSBI {\n    return JSBI.subtract(tradeAmount, this.getFees(tradeAmount));\n  }\n\n  private getOutputAmount(tokenAmounts: JSBI[], inputTradeAmount: JSBI, inputIndex: number, outputIndex: number): JSBI {\n    const [poolInputAmount, poolOutputAmount] = [tokenAmounts[inputIndex], tokenAmounts[outputIndex]];\n\n    const invariant = this.getInvariant(tokenAmounts);\n\n    const [newPoolOutputAmount] = ceilingDivision(invariant, JSBI.add(poolInputAmount, inputTradeAmount));\n\n    return JSBI.subtract(poolOutputAmount, newPoolOutputAmount);\n  }\n\n  getInvariant(tokenAmounts: JSBI[]) {\n    return JSBI.multiply(tokenAmounts[0], tokenAmounts[1]);\n  }\n}\n","import JSBI from 'jsbi';\n\nexport class Fraction {\n  constructor(public numerator: JSBI, public denominator: JSBI) {}\n}\n\nexport const ZERO_FRACTION = new Fraction(JSBI.BigInt(0), JSBI.BigInt(1));\n"],"names":["ZERO","JSBI","BigInt","ONE","TWO","abs","number","GE","unaryMinus","sumArray","numbers","reduce","prev","curr","add","mulArray","multiply","ceilingDivision","dividend","divisor","quotient","divide","equal","remainder","greaterThan","toDecimal","input","shift","Decimal","toString","div","pow","Curve","numberOfCurrencies","amplificationFactor","targetPrices","this","_proto","prototype","exchange","tokenAmounts","inputIndex","outputIndex","amount","minusOne","length","toNumber","Error","xp","dx","x","y","computeY","dy","subtract","computeBaseY","d","computeD","nn","exponentiate","sum","product","k","b","c","numerator","denominator","inputFactor","Math","log10","outputFactor","factor","mul","floor","newTotalAmount","xx","splice","ann","_step","_iterator","_createForOfIteratorHelperLoose","done","value","yPrev","dPrev","dP","_step2","_iterator2","_this","map","tokenAmount","index","Stable","amp","traderFee","curve","inputTradeAmount","outputAmountWithoutFees","getOutputAmount","fees","getFees","expectedOutputAmount","priceImpact","getPriceImpact","inputTradeAmountJSBI","expectedOutputAmountJSBI","noSlippageOutputAmount","getOutputAmountWithNoSlippage","sub","calculateFeeAmount","fee","feeAmount","TokenSwapStable","ownerFee","getExpectedOutputAmount","getExpectedOutputAmountWithNoSlippage","tradingFee","inputTradeAmountLessFees","getInputAmountLessFees","TokenSwapConstantProduct","feesOnInput","newInputTradeAmount","getAmountLessFees","expectedOutputAmountWithNoSlippage","tradeAmount","_ref","poolInputAmount","poolOutputAmount","_ceilingDivision","getInvariant","Fraction","ZERO_FRACTION"],"mappings":"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"}