'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var JSBI = require('jsbi');
var Decimal = require('decimal.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var JSBI__default = /*#__PURE__*/_interopDefaultLegacy(JSBI);
var Decimal__default = /*#__PURE__*/_interopDefaultLegacy(Decimal);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var ZERO = /*#__PURE__*/JSBI__default["default"].BigInt(0);
var ONE = /*#__PURE__*/JSBI__default["default"].BigInt(1);
var TWO = /*#__PURE__*/JSBI__default["default"].BigInt(2);
function abs(number) {
  if (JSBI__default["default"].GE(number, ZERO)) {
    return number;
  }

  return JSBI__default["default"].unaryMinus(number);
}
function sumArray(numbers) {
  return numbers.reduce(function (prev, curr) {
    return JSBI__default["default"].add(prev, curr);
  }, ZERO);
}
function mulArray(numbers) {
  return numbers.reduce(function (prev, curr) {
    return JSBI__default["default"].multiply(prev, curr);
  }, ONE);
}
function ceilingDivision(dividend, divisor) {
  var quotient = JSBI__default["default"].divide(dividend, divisor);

  if (JSBI__default["default"].equal(quotient, ZERO)) {
    return [ZERO, ZERO];
  }

  var remainder = JSBI__default["default"].remainder(dividend, divisor);

  if (JSBI__default["default"].greaterThan(remainder, ZERO)) {
    quotient = JSBI__default["default"].add(quotient, ONE);
    divisor = JSBI__default["default"].divide(dividend, quotient);
    remainder = JSBI__default["default"].remainder(dividend, quotient);

    if (JSBI__default["default"].greaterThan(remainder, ZERO)) {
      divisor = JSBI__default["default"].add(divisor, ONE);
    }
  }

  return [quotient, divisor];
}
function toDecimal(input, shift) {
  if (shift === void 0) {
    shift = 0;
  }

  return new Decimal__default["default"](input.toString()).div(new Decimal__default["default"](10).pow(shift));
}

var Curve = /*#__PURE__*/function () {
  function Curve(numberOfCurrencies, amplificationFactor, targetPrices) {
    this.numberOfCurrencies = void 0;
    this.amplificationFactor = void 0;
    this.targetPrices = void 0;
    this.numberOfCurrencies = numberOfCurrencies;
    this.amplificationFactor = amplificationFactor;
    this.targetPrices = targetPrices;
  }

  var _proto = Curve.prototype;

  _proto.exchange = function exchange(tokenAmounts, inputIndex, outputIndex, amount, minusOne) {
    if (minusOne === void 0) {
      minusOne = true;
    }

    if (tokenAmounts.length !== JSBI__default["default"].toNumber(this.numberOfCurrencies)) {
      throw new Error('Number of currencies does not match');
    }

    var xp = this.xp(tokenAmounts);
    var dx = JSBI__default["default"].multiply(amount, this.targetPrices[inputIndex]);
    var x = JSBI__default["default"].add(xp[inputIndex], dx);
    var y = this.computeY(tokenAmounts, inputIndex, outputIndex, x);
    var dy = JSBI__default["default"].subtract(xp[outputIndex], y); // This is a special condition on Curve stable algo. For TokenSwap, they don't seem to apply this minus one.

    if (minusOne) {
      dy = JSBI__default["default"].subtract(dy, ONE);
    }

    return JSBI__default["default"].divide(dy, this.targetPrices[outputIndex]);
  };

  _proto.computeBaseY = function computeBaseY(tokenAmounts, inputIndex, outputIndex, amount) {
    var d = this.computeD(tokenAmounts);
    var xp = this.xp(tokenAmounts);
    var nn = JSBI__default["default"].exponentiate(this.numberOfCurrencies, this.numberOfCurrencies);
    var sum = sumArray(xp);
    var product = mulArray(xp);
    var k = JSBI__default["default"].subtract(JSBI__default["default"].add(JSBI__default["default"].multiply(JSBI__default["default"].multiply(this.amplificationFactor, nn), sum), d), JSBI__default["default"].multiply(JSBI__default["default"].multiply(this.amplificationFactor, d), nn));
    var b = JSBI__default["default"].multiply(JSBI__default["default"].multiply(JSBI__default["default"].multiply(this.amplificationFactor, nn), nn), product);
    var c = JSBI__default["default"].multiply(JSBI__default["default"].multiply(nn, product), k);
    var numerator = JSBI__default["default"].add(b, JSBI__default["default"].divide(c, xp[inputIndex]));
    var denominator = JSBI__default["default"].add(b, JSBI__default["default"].divide(c, xp[outputIndex])); // Convert to number since JSBI doesn't support log10

    var inputFactor = Math.log10(JSBI__default["default"].toNumber(this.targetPrices[inputIndex]));
    var outputFactor = Math.log10(JSBI__default["default"].toNumber(this.targetPrices[outputIndex]));
    var factor = Math.abs(outputFactor - inputFactor);

    if (inputFactor >= outputFactor) {
      return JSBI__default["default"].BigInt(new Decimal__default["default"](numerator.toString()).mul(new Decimal__default["default"](amount.toString())).div(new Decimal__default["default"](denominator.toString())).mul(Math.pow(10, factor)).floor().toString());
    } else {
      return JSBI__default["default"].BigInt(new Decimal__default["default"](numerator.toString()).mul(new Decimal__default["default"](amount.toString())).div(new Decimal__default["default"](denominator.toString())).div(Math.pow(10, factor)).floor().toString());
    }
  };

  _proto.computeY = function computeY(tokenAmounts, inputIndex, outputIndex, newTotalAmount) {
    var d = this.computeD(tokenAmounts);
    var xx = this.xp(tokenAmounts);
    xx[inputIndex] = newTotalAmount;
    xx.splice(outputIndex, 1);
    var ann = JSBI__default["default"].multiply(this.amplificationFactor, this.numberOfCurrencies);
    var c = d;

    for (var _iterator = _createForOfIteratorHelperLoose(xx), _step; !(_step = _iterator()).done;) {
      var _y = _step.value;
      c = JSBI__default["default"].divide(JSBI__default["default"].multiply(c, d), JSBI__default["default"].multiply(_y, this.numberOfCurrencies));
    }

    c = JSBI__default["default"].divide(JSBI__default["default"].multiply(c, d), JSBI__default["default"].multiply(this.numberOfCurrencies, ann));
    var b = JSBI__default["default"].subtract(JSBI__default["default"].add(sumArray(xx), JSBI__default["default"].divide(d, ann)), d);
    var yPrev = ZERO;
    var y = d;

    while (JSBI__default["default"].greaterThan(abs(JSBI__default["default"].subtract(y, yPrev)), ONE)) {
      yPrev = y;
      y = JSBI__default["default"].divide(JSBI__default["default"].add(JSBI__default["default"].exponentiate(y, TWO), c), JSBI__default["default"].add(JSBI__default["default"].multiply(TWO, y), b));
    }

    return y;
  };

  _proto.computeD = function computeD(tokenAmounts) {
    var dPrev = ZERO;
    var xp = this.xp(tokenAmounts);
    var sum = sumArray(xp);
    var d = sum;
    var ann = JSBI__default["default"].multiply(this.amplificationFactor, this.numberOfCurrencies);

    while (JSBI__default["default"].greaterThan(abs(JSBI__default["default"].subtract(d, dPrev)), ONE)) {
      var dP = d;

      for (var _iterator2 = _createForOfIteratorHelperLoose(xp), _step2; !(_step2 = _iterator2()).done;) {
        var x = _step2.value;
        dP = JSBI__default["default"].divide(JSBI__default["default"].multiply(dP, d), JSBI__default["default"].multiply(this.numberOfCurrencies, x));
      }

      dPrev = d;
      var numerator = JSBI__default["default"].multiply(JSBI__default["default"].add(JSBI__default["default"].multiply(ann, sum), JSBI__default["default"].multiply(dP, this.numberOfCurrencies)), d);
      var denominator = JSBI__default["default"].add(JSBI__default["default"].multiply(JSBI__default["default"].subtract(ann, ONE), d), JSBI__default["default"].multiply(JSBI__default["default"].add(this.numberOfCurrencies, ONE), dP));
      d = JSBI__default["default"].divide(numerator, denominator);
    }

    return d;
  };

  _proto.xp = function xp(tokenAmounts) {
    var _this = this;

    return tokenAmounts.map(function (tokenAmount, index) {
      return JSBI__default["default"].multiply(tokenAmount, _this.targetPrices[index]);
    });
  };

  return Curve;
}();

var Stable = /*#__PURE__*/function () {
  function Stable(numberOfCurrencies, amp, targetPrices, traderFee) {
    this.targetPrices = void 0;
    this.traderFee = void 0;
    this.curve = void 0;
    this.targetPrices = targetPrices;
    this.traderFee = traderFee;
    this.curve = new Curve(numberOfCurrencies, amp, this.targetPrices);
  }

  var _proto = Stable.prototype;

  _proto.exchange = function exchange(tokenAmounts, inputTradeAmount, inputIndex, outputIndex) {
    var outputAmountWithoutFees = this.getOutputAmount(tokenAmounts, inputTradeAmount, inputIndex, outputIndex);
    var fees = this.getFees(outputAmountWithoutFees);
    var expectedOutputAmount = JSBI__default["default"].subtract(outputAmountWithoutFees, fees);
    return {
      priceImpact: this.getPriceImpact(tokenAmounts, inputTradeAmount, expectedOutputAmount, inputIndex, outputIndex),
      fees: fees,
      expectedOutputAmount: expectedOutputAmount
    };
  };

  _proto.getPriceImpact = function getPriceImpact(tokenAmounts, inputTradeAmountJSBI, expectedOutputAmountJSBI, inputIndex, outputIndex) {
    if (JSBI__default["default"].equal(inputTradeAmountJSBI, ZERO) || JSBI__default["default"].equal(tokenAmounts[inputIndex], ZERO) || JSBI__default["default"].equal(tokenAmounts[outputIndex], ZERO)) {
      return new Decimal__default["default"](0);
    }

    var noSlippageOutputAmount = toDecimal(this.getOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmountJSBI, inputIndex, outputIndex));
    var expectedOutputAmount = toDecimal(expectedOutputAmountJSBI);
    var impact = noSlippageOutputAmount.sub(expectedOutputAmount).div(noSlippageOutputAmount);
    return impact;
  };

  _proto.getFees = function getFees(outputAmountWithoutFees) {
    return JSBI__default["default"].equal(this.traderFee.numerator, ZERO) ? ZERO : JSBI__default["default"].divide(JSBI__default["default"].multiply(outputAmountWithoutFees, this.traderFee.numerator), this.traderFee.denominator);
  };

  _proto.getOutputAmount = function getOutputAmount(tokenAmounts, inputTradeAmount, inputIndex, outputIndex) {
    return this.curve.exchange(tokenAmounts, inputIndex, outputIndex, inputTradeAmount);
  };

  _proto.getOutputAmountWithNoSlippage = function getOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmount, inputIndex, outputIndex) {
    return this.curve.computeBaseY(tokenAmounts, inputIndex, outputIndex, inputTradeAmount);
  };

  return Stable;
}();

/** calculates fee amount given a fee fraction, returning one when fee is set but amount is zero */

function calculateFeeAmount(amount, fee) {
  if (JSBI__default["default"].equal(fee.numerator, ZERO) || JSBI__default["default"].equal(amount, ZERO)) {
    return ZERO;
  } else {
    var feeAmount = JSBI__default["default"].divide(JSBI__default["default"].multiply(amount, fee.numerator), fee.denominator);

    if (JSBI__default["default"].equal(feeAmount, ZERO)) {
      return ONE;
    }

    return feeAmount;
  }
}

var TokenSwapStable = /*#__PURE__*/function () {
  function TokenSwapStable(amp, traderFee, ownerFee) {
    this.traderFee = void 0;
    this.ownerFee = void 0;
    this.curve = void 0;
    this.traderFee = traderFee;
    this.ownerFee = ownerFee;
    this.curve = new Curve(TWO, amp, [ONE, ONE]);
  }

  var _proto = TokenSwapStable.prototype;

  _proto.exchange = function exchange(tokenAmounts, inputTradeAmount, outputIndex) {
    var inputIndex = outputIndex === 0 ? 1 : 0;
    var expectedOutputAmount = this.getExpectedOutputAmount(tokenAmounts, inputTradeAmount, inputIndex, outputIndex);
    return {
      priceImpact: this.getPriceImpact(tokenAmounts, inputTradeAmount, expectedOutputAmount, inputIndex, outputIndex),
      fees: this.getFees(inputTradeAmount),
      expectedOutputAmount: expectedOutputAmount
    };
  };

  _proto.getPriceImpact = function getPriceImpact(tokenAmounts, inputTradeAmountJSBI, expectedOutputAmountJSBI, inputIndex, outputIndex) {
    if (JSBI__default["default"].equal(inputTradeAmountJSBI, ZERO) || JSBI__default["default"].equal(tokenAmounts[inputIndex], ZERO) || JSBI__default["default"].equal(tokenAmounts[outputIndex], ZERO)) {
      return new Decimal__default["default"](0);
    }

    var noSlippageOutputAmount = toDecimal(this.getExpectedOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmountJSBI, inputIndex, outputIndex));
    var expectedOutputAmount = toDecimal(expectedOutputAmountJSBI);
    var impact = noSlippageOutputAmount.sub(expectedOutputAmount).div(noSlippageOutputAmount);
    return impact;
  };

  _proto.getFees = function getFees(inputTradeAmount) {
    var tradingFee = calculateFeeAmount(inputTradeAmount, this.traderFee);
    var ownerFee = calculateFeeAmount(inputTradeAmount, this.ownerFee);
    return JSBI__default["default"].add(tradingFee, ownerFee);
  };

  _proto.getExpectedOutputAmount = function getExpectedOutputAmount(tokenAmounts, inputTradeAmount, inputIndex, outputIndex) {
    var inputTradeAmountLessFees = this.getInputAmountLessFees(inputTradeAmount);
    return this.getOutputAmount(tokenAmounts, inputTradeAmountLessFees, inputIndex, outputIndex);
  };

  _proto.getExpectedOutputAmountWithNoSlippage = function getExpectedOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmount, inputIndex, outputIndex) {
    var inputTradeAmountLessFees = this.getInputAmountLessFees(inputTradeAmount);
    return this.getOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmountLessFees, inputIndex, outputIndex);
  };

  _proto.getInputAmountLessFees = function getInputAmountLessFees(inputTradeAmount) {
    return JSBI__default["default"].subtract(inputTradeAmount, this.getFees(inputTradeAmount));
  };

  _proto.getOutputAmount = function getOutputAmount(tokenAmounts, inputTradeAmountLessFees, inputIndex, outputIndex) {
    return this.curve.exchange(tokenAmounts, inputIndex, outputIndex, inputTradeAmountLessFees, false);
  };

  _proto.getOutputAmountWithNoSlippage = function getOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmountLessFees, inputIndex, outputIndex) {
    return this.curve.computeBaseY(tokenAmounts, inputIndex, outputIndex, inputTradeAmountLessFees);
  };

  return TokenSwapStable;
}();

var TokenSwapConstantProduct = /*#__PURE__*/function () {
  function TokenSwapConstantProduct(traderFee, ownerFee, feesOnInput) {
    if (feesOnInput === void 0) {
      feesOnInput = true;
    }

    this.traderFee = void 0;
    this.ownerFee = void 0;
    this.feesOnInput = void 0;
    this.traderFee = traderFee;
    this.ownerFee = ownerFee;
    this.feesOnInput = feesOnInput;
  }

  var _proto = TokenSwapConstantProduct.prototype;

  _proto.exchange = function exchange(tokenAmounts, inputTradeAmount, outputIndex) {
    var inputIndex = outputIndex === 0 ? 1 : 0;
    var newInputTradeAmount = this.feesOnInput ? this.getAmountLessFees(inputTradeAmount) : inputTradeAmount;
    var expectedOutputAmount = this.getExpectedOutputAmount(tokenAmounts, newInputTradeAmount, inputIndex, outputIndex);
    var fees = this.getFees(this.feesOnInput ? inputTradeAmount : expectedOutputAmount);

    if (!this.feesOnInput) {
      expectedOutputAmount = this.getAmountLessFees(expectedOutputAmount);
    }

    return {
      priceImpact: this.getPriceImpact(tokenAmounts, newInputTradeAmount, expectedOutputAmount, inputIndex, outputIndex),
      fees: fees,
      expectedOutputAmount: expectedOutputAmount
    };
  };

  _proto.getPriceImpact = function getPriceImpact(tokenAmounts, inputTradeAmountJSBI, expectedOutputAmountJSBI, inputIndex, outputIndex) {
    if (JSBI__default["default"].equal(inputTradeAmountJSBI, ZERO) || JSBI__default["default"].equal(tokenAmounts[inputIndex], ZERO) || JSBI__default["default"].equal(tokenAmounts[outputIndex], ZERO)) {
      return new Decimal__default["default"](0);
    }

    var noSlippageOutputAmount = toDecimal(this.getExpectedOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmountJSBI, inputIndex, outputIndex));
    var expectedOutputAmount = toDecimal(expectedOutputAmountJSBI);
    var impact = noSlippageOutputAmount.sub(expectedOutputAmount).div(noSlippageOutputAmount);
    return impact;
  };

  _proto.getFees = function getFees(inputTradeAmount) {
    var tradingFee = calculateFeeAmount(inputTradeAmount, this.traderFee);
    var ownerFee = calculateFeeAmount(inputTradeAmount, this.ownerFee);
    return JSBI__default["default"].add(tradingFee, ownerFee);
  };

  _proto.getExpectedOutputAmount = function getExpectedOutputAmount(tokenAmounts, inputTradeAmount, inputIndex, outputIndex) {
    return this.getOutputAmount(tokenAmounts, inputTradeAmount, inputIndex, outputIndex);
  };

  _proto.getExpectedOutputAmountWithNoSlippage = function getExpectedOutputAmountWithNoSlippage(tokenAmounts, inputTradeAmount, inputIndex, outputIndex) {
    if (JSBI__default["default"].equal(tokenAmounts[inputIndex], ZERO)) {
      return tokenAmounts[outputIndex];
    }

    var expectedOutputAmountWithNoSlippage = JSBI__default["default"].divide(JSBI__default["default"].multiply(inputTradeAmount, tokenAmounts[outputIndex]), tokenAmounts[inputIndex]);

    if (this.feesOnInput) {
      return expectedOutputAmountWithNoSlippage;
    } else {
      return this.getAmountLessFees(expectedOutputAmountWithNoSlippage);
    }
  };

  _proto.getAmountLessFees = function getAmountLessFees(tradeAmount) {
    return JSBI__default["default"].subtract(tradeAmount, this.getFees(tradeAmount));
  };

  _proto.getOutputAmount = function getOutputAmount(tokenAmounts, inputTradeAmount, inputIndex, outputIndex) {
    var _ref = [tokenAmounts[inputIndex], tokenAmounts[outputIndex]],
        poolInputAmount = _ref[0],
        poolOutputAmount = _ref[1];
    var invariant = this.getInvariant(tokenAmounts);

    var _ceilingDivision = ceilingDivision(invariant, JSBI__default["default"].add(poolInputAmount, inputTradeAmount)),
        newPoolOutputAmount = _ceilingDivision[0];

    return JSBI__default["default"].subtract(poolOutputAmount, newPoolOutputAmount);
  };

  _proto.getInvariant = function getInvariant(tokenAmounts) {
    return JSBI__default["default"].multiply(tokenAmounts[0], tokenAmounts[1]);
  };

  return TokenSwapConstantProduct;
}();

var Fraction = function Fraction(numerator, denominator) {
  this.numerator = void 0;
  this.denominator = void 0;
  this.numerator = numerator;
  this.denominator = denominator;
};
var ZERO_FRACTION = /*#__PURE__*/new Fraction( /*#__PURE__*/JSBI__default["default"].BigInt(0), /*#__PURE__*/JSBI__default["default"].BigInt(1));

exports.Fraction = Fraction;
exports.ONE = ONE;
exports.Stable = Stable;
exports.TWO = TWO;
exports.TokenSwapConstantProduct = TokenSwapConstantProduct;
exports.TokenSwapStable = TokenSwapStable;
exports.ZERO = ZERO;
exports.ZERO_FRACTION = ZERO_FRACTION;
exports.abs = abs;
exports.calculateFeeAmount = calculateFeeAmount;
exports.ceilingDivision = ceilingDivision;
exports.mulArray = mulArray;
exports.sumArray = sumArray;
exports.toDecimal = toDecimal;
//# sourceMappingURL=math.cjs.development.js.map
