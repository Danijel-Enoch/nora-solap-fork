"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TickUtil = void 0;
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const address_1 = require("../address");
const whirlpool_client_sdk_1 = require("@orca-so/whirlpool-client-sdk");
var TickSearchDirection;
(function (TickSearchDirection) {
    TickSearchDirection[TickSearchDirection["Left"] = 0] = "Left";
    TickSearchDirection[TickSearchDirection["Right"] = 1] = "Right";
})(TickSearchDirection || (TickSearchDirection = {}));
class TickUtil {
    constructor() { }
    /**
     * Get the nearest (rounding down) valid tick index from the tickIndex.
     * A valid tick index is a point on the tick spacing grid line.
     */
    static toValid(tickIndex, tickSpacing) {
        return tickIndex - (tickIndex % tickSpacing);
    }
    /**
     * Get the tick from tickArray with a global tickIndex.
     */
    static getTick(tickArray, tickIndex, tickSpacing) {
        const realIndex = TickUtil.tickIndexToTickArrayIndex(tickArray, tickIndex, tickSpacing);
        const tick = tickArray.ticks[realIndex];
        (0, tiny_invariant_1.default)(!!tick, "tick realIndex out of range");
        return tick;
    }
    static getLowerAndUpperTickArrayAddresses(tickLowerIndex, tickUpperIndex, tickSpacing, whirlpool, programId) {
        return [
            TickUtil.getPdaWithTickIndex(tickLowerIndex, tickSpacing, whirlpool, programId).publicKey,
            TickUtil.getPdaWithTickIndex(tickUpperIndex, tickSpacing, whirlpool, programId).publicKey,
        ];
    }
    /**
     * Get the PDA of the tick array containing tickIndex.
     * tickArrayOffset can be used to get neighboring tick arrays.
     */
    static getPdaWithTickIndex(tickIndex, tickSpacing, whirlpool, programId, tickArrayOffset = 0) {
        const startIndex = TickUtil.getStartTickIndex(tickIndex, tickSpacing, tickArrayOffset);
        return (0, whirlpool_client_sdk_1.getTickArrayPda)((0, address_1.toPubKey)(programId), (0, address_1.toPubKey)(whirlpool), startIndex);
    }
    static getPDAWithSqrtPrice(sqrtPriceX64, tickSpacing, whirlpool, programId, tickArrayOffset = 0) {
        const tickIndex = (0, whirlpool_client_sdk_1.sqrtPriceX64ToTickIndex)(sqrtPriceX64);
        return TickUtil.getPdaWithTickIndex(tickIndex, tickSpacing, whirlpool, programId, tickArrayOffset);
    }
    /**
     * Get the startIndex of the tick array containing tickIndex.
     *
     * @param tickIndex
     * @param tickSpacing
     * @param offset can be used to get neighboring tick array startIndex.
     * @returns
     */
    static getStartTickIndex(tickIndex, tickSpacing, offset = 0) {
        const realIndex = Math.floor(tickIndex / tickSpacing / whirlpool_client_sdk_1.TICK_ARRAY_SIZE);
        const startTickIndex = (realIndex + offset) * tickSpacing * whirlpool_client_sdk_1.TICK_ARRAY_SIZE;
        const ticksInArray = whirlpool_client_sdk_1.TICK_ARRAY_SIZE * tickSpacing;
        const minTickIndex = whirlpool_client_sdk_1.MIN_TICK_INDEX - ((whirlpool_client_sdk_1.MIN_TICK_INDEX % ticksInArray) + ticksInArray);
        (0, tiny_invariant_1.default)(startTickIndex >= minTickIndex, "startTickIndex is too small");
        (0, tiny_invariant_1.default)(startTickIndex <= whirlpool_client_sdk_1.MAX_TICK_INDEX, "startTickIndex is too large");
        return startTickIndex;
    }
    /**
     * Get the previous initialized tick index within the same tick array.
     */
    static getPrevInitializedTickIndex(account, currentTickIndex, tickSpacing) {
        return TickUtil.findInitializedTick(account, currentTickIndex, tickSpacing, TickSearchDirection.Left);
    }
    /**
     * Get the next initialized tick index within the same tick array.
     */
    static getNextInitializedTickIndex(account, currentTickIndex, tickSpacing) {
        return TickUtil.findInitializedTick(account, currentTickIndex, tickSpacing, TickSearchDirection.Right);
    }
    static findInitializedTick(account, currentTickIndex, tickSpacing, searchDirection) {
        var _a;
        const currentTickArrayIndex = TickUtil.tickIndexToTickArrayIndex(account, currentTickIndex, tickSpacing);
        const increment = searchDirection === TickSearchDirection.Right ? 1 : -1;
        let stepInitializedTickArrayIndex = searchDirection === TickSearchDirection.Right
            ? currentTickArrayIndex + increment
            : currentTickArrayIndex;
        while (stepInitializedTickArrayIndex >= 0 &&
            stepInitializedTickArrayIndex < account.ticks.length) {
            if ((_a = account.ticks[stepInitializedTickArrayIndex]) === null || _a === void 0 ? void 0 : _a.initialized) {
                return TickUtil.tickArrayIndexToTickIndex(account, stepInitializedTickArrayIndex, tickSpacing);
            }
            stepInitializedTickArrayIndex += increment;
        }
        return null;
    }
    static tickIndexToTickArrayIndex({ startTickIndex }, tickIndex, tickSpacing) {
        return Math.floor((tickIndex - startTickIndex) / tickSpacing);
    }
    static tickArrayIndexToTickIndex({ startTickIndex }, tickArrayIndex, tickSpacing) {
        return startTickIndex + tickArrayIndex * tickSpacing;
    }
    static getNextInitializableTickIndex(tickIndex, tickSpacing, aToB) {
        if (!aToB) {
            return tickIndex + tickSpacing;
        }
        else {
            return tickIndex;
        }
    }
}
exports.TickUtil = TickUtil;
