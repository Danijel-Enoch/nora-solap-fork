"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNextSqrtPrice = exports.getAmountUnfixedDelta = exports.getAmountFixedDelta = exports.getTokenBFromLiquidity = exports.getTokenAFromLiquidity = exports.getLiquidityFromTokenB = exports.getLiquidityFromTokenA = exports.adjustAmountForSlippage = exports.adjustForSlippage = exports.PositionUtil = exports.PositionStatus = void 0;
const swap_quoter_1 = require("../../pool/quotes/swap-quoter");
const math_utils_1 = require("../web3/math-utils");
const swap_util_1 = require("./swap-util");
var PositionStatus;
(function (PositionStatus) {
    PositionStatus[PositionStatus["BelowRange"] = 0] = "BelowRange";
    PositionStatus[PositionStatus["InRange"] = 1] = "InRange";
    PositionStatus[PositionStatus["AboveRange"] = 2] = "AboveRange";
})(PositionStatus = exports.PositionStatus || (exports.PositionStatus = {}));
class PositionUtil {
    constructor() { }
    static getPositionStatus(tickCurrentIndex, tickLowerIndex, tickUpperIndex) {
        if (tickCurrentIndex < tickLowerIndex) {
            return PositionStatus.BelowRange;
        }
        else if (tickCurrentIndex < tickUpperIndex) {
            return PositionStatus.InRange;
        }
        else {
            return PositionStatus.AboveRange;
        }
    }
}
exports.PositionUtil = PositionUtil;
function adjustForSlippage(n, { numerator, denominator }, adjustUp) {
    if (adjustUp) {
        return n.mul(denominator.add(numerator)).div(denominator);
    }
    else {
        return n.mul(denominator).div(denominator.add(numerator));
    }
}
exports.adjustForSlippage = adjustForSlippage;
function adjustAmountForSlippage(amountIn, amountOut, { numerator, denominator }, amountSpecified) {
    if (amountSpecified === swap_quoter_1.AmountSpecified.Input) {
        return amountOut.mul(denominator).div(denominator.add(numerator));
    }
    else {
        return amountIn.mul(denominator.add(numerator)).div(denominator);
    }
}
exports.adjustAmountForSlippage = adjustAmountForSlippage;
function getLiquidityFromTokenA(amount, sqrtPriceLowerX64, sqrtPriceUpperX64, roundUp) {
    const result = amount
        .mul(sqrtPriceLowerX64)
        .mul(sqrtPriceUpperX64)
        .div(sqrtPriceUpperX64.sub(sqrtPriceLowerX64));
    if (roundUp) {
        return (0, math_utils_1.shiftRightRoundUp)(result);
    }
    else {
        return result.shrn(64);
    }
}
exports.getLiquidityFromTokenA = getLiquidityFromTokenA;
function getLiquidityFromTokenB(amount, sqrtPriceLowerX64, sqrtPriceUpperX64, roundUp) {
    const numerator = amount.shln(64);
    const denominator = sqrtPriceUpperX64.sub(sqrtPriceLowerX64);
    if (roundUp) {
        return (0, math_utils_1.divRoundUp)(numerator, denominator);
    }
    else {
        return numerator.div(denominator);
    }
}
exports.getLiquidityFromTokenB = getLiquidityFromTokenB;
function orderSqrtPrice(sqrtPrice0X64, sqrtPrice1X64) {
    if (sqrtPrice0X64.lt(sqrtPrice1X64)) {
        return [sqrtPrice0X64, sqrtPrice1X64];
    }
    else {
        return [sqrtPrice1X64, sqrtPrice0X64];
    }
}
function getTokenAFromLiquidity(liquidity, sqrtPrice0X64, sqrtPrice1X64, roundUp) {
    const [sqrtPriceLowerX64, sqrtPriceUpperX64] = orderSqrtPrice(sqrtPrice0X64, sqrtPrice1X64);
    const numerator = liquidity.mul(sqrtPriceUpperX64.sub(sqrtPriceLowerX64)).shln(64);
    const denominator = sqrtPriceUpperX64.mul(sqrtPriceLowerX64);
    if (roundUp) {
        return (0, math_utils_1.divRoundUp)(numerator, denominator);
    }
    else {
        return numerator.div(denominator);
    }
}
exports.getTokenAFromLiquidity = getTokenAFromLiquidity;
function getTokenBFromLiquidity(liquidity, sqrtPrice0X64, sqrtPrice1X64, roundUp) {
    const [sqrtPriceLowerX64, sqrtPriceUpperX64] = orderSqrtPrice(sqrtPrice0X64, sqrtPrice1X64);
    const result = liquidity.mul(sqrtPriceUpperX64.sub(sqrtPriceLowerX64));
    if (roundUp) {
        return (0, math_utils_1.shiftRightRoundUp)(result);
    }
    else {
        return result.shrn(64);
    }
}
exports.getTokenBFromLiquidity = getTokenBFromLiquidity;
function getAmountFixedDelta(currentSqrtPriceX64, targetSqrtPriceX64, liquidity, amountSpecified, swapDirection) {
    if ((amountSpecified == swap_quoter_1.AmountSpecified.Input) == (swapDirection == swap_quoter_1.SwapDirection.AtoB)) {
        return getTokenAFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified == swap_quoter_1.AmountSpecified.Input);
    }
    else {
        return getTokenBFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified == swap_quoter_1.AmountSpecified.Input);
    }
}
exports.getAmountFixedDelta = getAmountFixedDelta;
function getAmountUnfixedDelta(currentSqrtPriceX64, targetSqrtPriceX64, liquidity, amountSpecified, swapDirection) {
    if ((amountSpecified == swap_quoter_1.AmountSpecified.Input) == (swapDirection == swap_quoter_1.SwapDirection.AtoB)) {
        return getTokenBFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified == swap_quoter_1.AmountSpecified.Output);
    }
    else {
        return getTokenAFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified == swap_quoter_1.AmountSpecified.Output);
    }
}
exports.getAmountUnfixedDelta = getAmountUnfixedDelta;
function getNextSqrtPrice(sqrtPriceX64, liquidity, amount, amountSpecified, swapDirection) {
    if (amountSpecified === swap_quoter_1.AmountSpecified.Input && swapDirection === swap_quoter_1.SwapDirection.AtoB) {
        return (0, swap_util_1.getLowerSqrtPriceFromTokenA)(amount, liquidity, sqrtPriceX64);
    }
    else if (amountSpecified === swap_quoter_1.AmountSpecified.Output && swapDirection === swap_quoter_1.SwapDirection.BtoA) {
        return (0, swap_util_1.getUpperSqrtPriceFromTokenA)(amount, liquidity, sqrtPriceX64);
    }
    else if (amountSpecified === swap_quoter_1.AmountSpecified.Input && swapDirection === swap_quoter_1.SwapDirection.BtoA) {
        return (0, swap_util_1.getUpperSqrtPriceFromTokenB)(amount, liquidity, sqrtPriceX64);
    }
    else {
        return (0, swap_util_1.getLowerSqrtPriceFromTokenB)(amount, liquidity, sqrtPriceX64);
    }
}
exports.getNextSqrtPrice = getNextSqrtPrice;
