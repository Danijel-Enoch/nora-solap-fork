"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrcaWhirlpoolClient = void 0;
const spl_token_1 = require("@solana/spl-token");
const decimal_js_1 = __importDefault(require("decimal.js"));
const orca_admin_1 = require("./admin/orca-admin");
const defaults_1 = require("./constants/defaults");
const programs_1 = require("./constants/programs");
const orca_dal_1 = require("./dal/orca-dal");
const orca_pool_1 = require("./pool/orca-pool");
const orca_position_1 = require("./position/orca-position");
const token_price_1 = require("./utils/token-price");
const convert_data_1 = require("./pool/convert-data");
const convert_data_2 = require("./position/convert-data");
const orca_zp_1 = require("./offchain/orca-zp");
const address_1 = require("./utils/address");
// Global rules for Decimals
//  - 40 digits of precision for the largest number
//  - 20 digits of precision for the smallest number
//  - Always round towards 0 to mirror smart contract rules
decimal_js_1.default.set({ precision: 40, toExpPos: 40, toExpNeg: -20, rounding: 1 });
class OrcaWhirlpoolClient {
    constructor(config) {
        const network = (config === null || config === void 0 ? void 0 : config.network) || defaults_1.defaultNetwork;
        const connection = (config === null || config === void 0 ? void 0 : config.connection) || (0, defaults_1.getDefaultConnection)(network);
        const whirlpoolsConfig = (config === null || config === void 0 ? void 0 : config.whirlpoolConfig) || (0, programs_1.getWhirlpoolsConfig)(network);
        const programId = (config === null || config === void 0 ? void 0 : config.programId) || (0, programs_1.getWhirlpoolProgramId)(network);
        const offchainDataURI = (config === null || config === void 0 ? void 0 : config.offchainDataURI) || (0, defaults_1.getDefaultOffchainDataURI)(network);
        this.data = new orca_dal_1.OrcaDAL(whirlpoolsConfig, programId, connection);
        this.admin = new orca_admin_1.OrcaAdmin(this.data);
        this.pool = new orca_pool_1.OrcaPool(this.data);
        this.position = new orca_position_1.OrcaPosition(this.data);
        this.offchain = new orca_zp_1.OrcaZooplankton(offchainDataURI);
    }
    /**
     * Use on-chain dex data to derive usd prices for tokens.
     *
     * @param poolAddresses pools to be used for price discovery
     * @param baseTokenMint a token mint with known stable usd price (e.g. USDC)
     * @param baseTokenUSDPrice baseTokenMint's usd price. defaults to 1, assuming `baseTokenMint` is a USD stable coin
     * @param otherBaseTokenMints optional list of token mints to prioritize as base
     * @param refresh defaults to refreshing the cache
     */
    getTokenPrices(poolAddresses, baseTokenMint, baseTokenUSDPrice = new decimal_js_1.default(1), otherBaseTokenMints = [spl_token_1.NATIVE_MINT], refresh = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const allPools = yield this.data.listPools(poolAddresses, refresh);
            const pools = allPools.filter((pool) => pool !== null);
            return (0, token_price_1.getTokenUSDPrices)(this.data, pools, baseTokenMint, baseTokenUSDPrice, otherBaseTokenMints);
        });
    }
    /**
     * Fetch position data owned by the wallet address.
     *
     * @param walletAddress wallet address
     * @param refresh defaults to refreshing the cache
     * @returns positions owned by the wallet address
     */
    getUserPositions(walletAddress, refresh = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, convert_data_2.convertPositionDataToUserPositionData)(this.data, walletAddress, refresh);
        });
    }
    /**
     * Fetch list of pool data.
     *
     * @param poolAddresses list of pools to retrieve
     * @param refresh defaults to refreshing the cache
     * @returns list of pool data
     */
    getPools(poolAddresses, refresh = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, convert_data_1.convertWhirlpoolDataToPoolData)(this.data, poolAddresses, refresh);
        });
    }
    /**
     * Fetch pool data.
     *
     * @param poolAddress pool address
     * @param refresh defaults to refreshing the cache
     * @returns pool data
     */
    getPool(poolAddress, refresh = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const pool = (yield this.getPools([poolAddress], refresh))[(0, address_1.toPubKey)(poolAddress).toBase58()];
            return pool || null;
        });
    }
}
exports.OrcaWhirlpoolClient = OrcaWhirlpoolClient;
