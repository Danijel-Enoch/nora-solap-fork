import { Provider, BN as BN$1, Address } from '@project-serum/anchor';
import { PublicKey, Connection, Keypair } from '@solana/web3.js';
import Decimal from 'decimal.js';
import BN from 'bn.js';
import { AccountInfo, MintInfo, u64 } from '@solana/spl-token';
import { WhirlpoolData, PositionData, TickArrayData, WhirlpoolConfigAccount, TransactionBuilder, PDA, InitTickArrayParams, TickSpacing } from '@orca-so/whirlpool-client-sdk';
export { TickArrayData, WhirlpoolData, parseTickArray, parseWhirlpool } from '@orca-so/whirlpool-client-sdk';

declare enum OrcaNetwork {
    MAINNET = "mainnet",
    DEVNET = "devnet"
}

/*** Pool ***/
declare type PoolData = {
    address: PublicKey;
    tokenMintA: PublicKey;
    tokenMintB: PublicKey;
    stable: boolean;
    feeRate: number;
    protocolFeeRate: number;
    liquidity: BN;
    sqrtPrice: BN;
    tickCurrentIndex: number;
    protocolFeeOwedA: BN;
    protocolFeeOwedB: BN;
    tokenVaultAmountA: BN;
    tokenVaultAmountB: BN;
    rewards: PoolRewardInfo[];
    feeGrowthGlobalAX64: BN;
    feeGrowthGlobalBX64: BN;
    feePercentage: Decimal;
    protocolFeePercentage: Decimal;
    price: Decimal;
    decimalProtocolFeeOwedA: Decimal;
    decimalProtocolFeeOwedB: Decimal;
    decimalTokenVaultAmountA: Decimal;
    decimalTokenVaultAmountB: Decimal;
    tokenDecimalsA: number;
    tokenDecimalsB: number;
};
declare type PoolRewardInfo = {
    mint: PublicKey;
    vault: PublicKey;
    vaultAmount?: BN;
    emissionsPerSecondX64: BN;
    growthGlobalX64: BN;
    decimalVaultAmount?: Decimal;
    emissionsPerSecond?: Decimal;
};
/*** Position ***/
declare type UserPositionData = {
    address: PublicKey;
    poolAddress: PublicKey;
    positionMint: PublicKey;
    liquidity: BN;
    tickLowerIndex: number;
    tickUpperIndex: number;
    feeOwedA: BN;
    feeOwedB: BN;
    rewards: UserPositionRewardInfo[];
    priceLower: Decimal;
    priceUpper: Decimal;
    decimalFeeOwedA: Decimal;
    decimalFeeOwedB: Decimal;
};
declare type UserPositionRewardInfo = {
    mint: PublicKey;
    amountOwed?: BN;
    decimalAmountOwed?: Decimal;
};
/*** Misc ***/
declare type UserToken = {
    address: PublicKey;
    amount?: string;
    decimals?: number;
    mint?: string;
};

declare type InitPoolTxParam = {
    provider: Provider;
    initSqrtPrice: BN$1;
    tokenMintA: Address;
    tokenMintB: Address;
    stable: boolean;
};
declare type CollectProtocolFeesTxParam = {
    provider: Provider;
    poolAddress: Address;
};
declare type SetFeeAuthorityTxParam = {
    provider: Provider;
    newFeeAuthority: Address;
};
declare type SetFeeRateTxParam = {
    provider: Provider;
    poolAddress: Address;
    feeRate: number;
};
declare type SetProtocolFeeRateTxParam = {
    provider: Provider;
    poolAddress: Address;
    protocolFeeRate: number;
};
declare type SetCollectProtocolFeesAuthorityTxParam = {
    provider: Provider;
    newCollectProtocolFeesAuthority: Address;
};
declare type InitRewardTxParam = {
    provider: Provider;
    rewardAuthority: Address;
    poolAddress: Address;
    rewardMint: Address;
    rewardIndex: number;
};
declare type SetRewardAuthorityTxParam = {
    provider: Provider;
    poolAddress: Address;
    newRewardAuthority: Address;
    rewardIndex: number;
};
declare type SetRewardEmissionsTxParam = {
    provider: Provider;
    poolAddress: Address;
    rewardIndex: number;
    emissionsPerSecondX64: BN$1;
};
declare type SetRewardAuthorityBySuperAuthorityTxParam = {
    provider: Provider;
    poolAddress: Address;
    newRewardAuthority: Address;
    rewardIndex: number;
};
declare type SetRewardEmissionsBySuperAuthorityTxParam = {
    provider: Provider;
    rewardEmissionsSuperAuthority: Address;
    newRewardEmissionsSuperAuthority: Address;
};

/**
 * Data access layer for accounts used by OrcaWhirlpool and OrcaPosition.
 * The types of accounts that are being used are defined by CachedAccount.
 * Includes internal cache that can be refreshed by the client.
 */
declare class OrcaDAL {
    readonly whirlpoolsConfig: PublicKey;
    readonly programId: PublicKey;
    private readonly connection;
    private readonly _cache;
    private _userTokens;
    constructor(whirlpoolsConfig: Address, programId: Address, connection: Connection);
    /*** Public Methods ***/
    /**
     * Retrieve a cached whirlpool account. Fetch from rpc on cache miss.
     *
     * @param address whirlpool address
     * @param refresh force cache refresh
     * @returns whirlpool account
     */
    getPool(address: Address, refresh: boolean): Promise<WhirlpoolData | null>;
    /**
     * Retrieve a cached position account. Fetch from rpc on cache miss.
     *
     * @param address position address
     * @param refresh force cache refresh
     * @returns position account
     */
    getPosition(address: Address, refresh: boolean): Promise<PositionData | null>;
    /**
     * Retrieve a cached tick array account. Fetch from rpc on cache miss.
     *
     * @param address tick array address
     * @param refresh force cache refresh
     * @returns tick array account
     */
    getTickArray(address: Address, refresh: boolean): Promise<TickArrayData | null>;
    /**
     * Retrieve a cached token info account. Fetch from rpc on cache miss.
     *
     * @param address token info address
     * @param refresh force cache refresh
     * @returns token info account
     */
    getTokenInfo(address: Address, refresh: boolean): Promise<AccountInfo | null>;
    /**
     * Retrieve a cached mint info account. Fetch from rpc on cache miss.
     *
     * @param address mint info address
     * @param refresh force cache refresh
     * @returns mint info account
     */
    getMintInfo(address: Address, refresh: boolean): Promise<MintInfo | null>;
    /**
     * Retrieve a cached whirlpool config account. Fetch from rpc on cache miss.
     *
     * @param address whirlpool config address
     * @param refresh force cache refresh
     * @returns whirlpool config account
     */
    getConfig(address: Address, refresh: boolean): Promise<WhirlpoolConfigAccount | null>;
    /**
     * Retrieve a list of cached whirlpool accounts. Fetch from rpc for cache misses.
     *
     * @param addresses whirlpool addresses
     * @param refresh force cache refresh
     * @returns whirlpool accounts
     */
    listPools(addresses: Address[], refresh: boolean): Promise<(WhirlpoolData | null)[]>;
    /**
     * Retrieve a list of cached position accounts. Fetch from rpc for cache misses.
     *
     * @param addresses position addresses
     * @param refresh force cache refresh
     * @returns position accounts
     */
    listPositions(addresses: Address[], refresh: boolean): Promise<(PositionData | null)[]>;
    /**
     * Retrieve a list of cached tick array accounts. Fetch from rpc for cache misses.
     *
     * @param addresses tick array addresses
     * @param refresh force cache refresh
     * @returns tick array accounts
     */
    listTickArrays(addresses: Address[], refresh: boolean): Promise<(TickArrayData | null)[]>;
    /**
     * Retrieve a list of cached token info accounts. Fetch from rpc for cache misses.
     *
     * @param addresses token info addresses
     * @param refresh force cache refresh
     * @returns token info accounts
     */
    listTokenInfos(addresses: Address[], refresh: boolean): Promise<(AccountInfo | null)[]>;
    /**
     * Retrieve a list of cached mint info accounts. Fetch from rpc for cache misses.
     *
     * @param addresses mint info addresses
     * @param refresh force cache refresh
     * @returns mint info accounts
     */
    listMintInfos(addresses: Address[], refresh: boolean): Promise<(MintInfo | null)[]>;
    /**
     * Retrieve a list of tokens owned by the user.
     *
     * @param walletAddress user wallet address
     * @param refresh foree cache refresh
     * @returns user tokens
     */
    listUserTokens(walletAddress: Address, refresh: boolean): Promise<UserToken[]>;
    /**
     * Update the cached value of all entities currently in the cache.
     * Uses batched rpc request for network efficient fetch.
     */
    refreshAll(): Promise<void>;
    /*** Private Methods ***/
    /**
     * Retrieve from cache or fetch from rpc, an account
     */
    private get;
    /**
     * Retrieve from cache or fetch from rpc, a list of accounts
     */
    private list;
    /**
     * Make batch rpc request
     */
    private bulkRequest;
}

declare class OrcaAdmin {
    private readonly dal;
    constructor(dal: OrcaDAL);
    getInitPoolTx(param: InitPoolTxParam): {
        tx: TransactionBuilder;
        address: PublicKey;
    };
    /*** Fee ***/
    getCollectProtocolFeesTx(param: CollectProtocolFeesTxParam): Promise<TransactionBuilder>;
    getSetFeeAuthorityTx(param: SetFeeAuthorityTxParam): TransactionBuilder;
    getSetFeeRateTx(param: SetFeeRateTxParam): Promise<TransactionBuilder>;
    getSetProtocolFeeRateTx(param: SetProtocolFeeRateTxParam): Promise<TransactionBuilder>;
    getSetCollectProtocolFeesAuthorityTx(param: SetCollectProtocolFeesAuthorityTxParam): TransactionBuilder;
    /*** Reward ***/
    getInitRewardTx(param: InitRewardTxParam): {
        tx: TransactionBuilder;
        rewardVault: PublicKey;
    };
    getSetRewardAuthorityTx(param: SetRewardAuthorityTxParam): TransactionBuilder;
    getSetRewardEmissionsTx(param: SetRewardEmissionsTxParam): Promise<TransactionBuilder>;
    getSetRewardAuthorityBySuperAuthorityTx(param: SetRewardAuthorityBySuperAuthorityTxParam): TransactionBuilder;
    getSetRewardEmissionsBySuperAuthorityTx(param: SetRewardEmissionsBySuperAuthorityTxParam): TransactionBuilder;
}

declare class Percentage {
    readonly numerator: u64;
    readonly denominator: u64;
    constructor(numerator: u64, denominator: u64);
    static fromDecimal(number: Decimal): Percentage;
    static fromFraction(numerator: u64 | number, denominator: u64 | number): Percentage;
    toString: () => string;
    toDecimal(): Decimal;
    add(p2: Percentage): Percentage;
}

/*** Transactions ***/
declare type OpenPositionTxParam = {
    provider: Provider;
    quote: OpenPositionQuote;
};
declare type ClosePositionTxParam = {
    provider: Provider;
    quote: ClosePositionQuote;
};
declare type SwapTxParam = {
    provider: Provider;
    quote: SwapQuote;
};
declare type FillTickArraysParam = {
    provider: Provider;
    poolAddress: Address;
};
/*** Quotes ***/
declare type OpenPositionQuoteParam = OpenPositionQuoteByPrice | OpenPositionQuoteByTickIndex;
declare type OpenPositionQuoteByPrice = BaseOpenPositionQuoteParam & {
    priceLower: Decimal;
    priceUpper: Decimal;
};
declare type OpenPositionQuoteByTickIndex = BaseOpenPositionQuoteParam & {
    tickLowerIndex: number;
    tickUpperIndex: number;
};
declare type BaseOpenPositionQuoteParam = {
    poolAddress: Address;
    tokenMint: Address;
    tokenAmount: u64;
    refresh: boolean;
    slippageTolerance?: Percentage;
};
declare type OpenPositionQuote = {
    poolAddress: Address;
    tickLowerIndex: number;
    tickUpperIndex: number;
    maxTokenA: u64;
    maxTokenB: u64;
    liquidity: BN$1;
};
declare type ClosePositionQuoteParam = {
    positionAddress: Address;
    refresh: boolean;
    slippageTolerance?: Percentage;
};
declare type ClosePositionQuote = {
    positionAddress: Address;
    minTokenA: u64;
    minTokenB: u64;
    liquidity: BN$1;
};
declare type SwapQuoteParam$1 = {
    poolAddress: Address;
    tokenMint: Address;
    tokenAmount: u64;
    isInput: boolean;
    slippageTolerance?: Percentage;
    refresh: boolean;
};
declare type SwapQuote = {
    poolAddress: Address;
    otherAmountThreshold: u64;
    sqrtPriceLimitX64: BN$1;
    amountIn: u64;
    amountOut: u64;
    aToB: boolean;
    fixedInput: boolean;
};
/*** Type Guards ***/
declare function isQuoteByPrice(param: OpenPositionQuoteParam): param is OpenPositionQuoteByPrice;
declare function isQuoteByTickIndex(param: OpenPositionQuoteParam): param is OpenPositionQuoteByTickIndex;

/**
 * Collection of TransactionBuilders for grouping multiple transactions together for sendAll.
 */
declare class MultiTransactionBuilder {
    readonly provider: Provider;
    readonly txBuilders: TransactionBuilder[];
    constructor(provider: Provider, txBuilders: TransactionBuilder[]);
    buildAndExecute(): Promise<string[]>;
    addTxBuilder(txBuilder: TransactionBuilder): MultiTransactionBuilder;
    merge(multiTxBuilder: MultiTransactionBuilder): MultiTransactionBuilder;
    static mergeAll(multiTxBuilders: MultiTransactionBuilder[]): MultiTransactionBuilder | null;
}

declare type LiquidityDataPoint = {
    liquidity: Decimal;
    price: Decimal;
    tickIndex: number;
};
declare type LiquidityDistribution = {
    currentPrice: Decimal;
    currentTickIndex: number;
    datapoints: LiquidityDataPoint[];
};

declare class OrcaPool {
    private readonly dal;
    constructor(dal: OrcaDAL);
    /*** Utilities ***/
    /**
     * Create liquidity distribution across three tick-arrays for a pool.
     * Useful for visualizing the liquidity in the pool.
     *
     * @param poolAddress
     * @param tickLower
     * @param tickUpper
     * @param refresh
     * @returns liquidity distribution
     */
    getLiquidityDistribution(poolAddress: Address, tickLower: number, tickUpper: number, refresh?: boolean): Promise<LiquidityDistribution>;
    /**
     * Derive the pool pda given token mints and tick spacing
     *
     * @param tokenMintA
     * @param tokenMintB
     * @param stable
     * @returns
     */
    derivePDA(tokenMintA: Address, tokenMintB: Address, stable: boolean): PDA;
    /*** Transactions ***/
    /**
     * Construct a transaction for opening an new position
     */
    getOpenPositionTx(param: OpenPositionTxParam): Promise<{
        tx: MultiTransactionBuilder;
        mint: PublicKey;
    }>;
    /**
     * Construct a transaction for opening an new position
     */
    getOpenPositionWithMetadataTx(param: OpenPositionTxParam): Promise<{
        tx: MultiTransactionBuilder;
        mint: PublicKey;
    }>;
    /**
     * Construct a transaction for opening an new position with optional metadata
     */
    getOpenPositionWithOptMetadataTx(param: OpenPositionTxParam, withMetadata?: boolean): Promise<{
        tx: MultiTransactionBuilder;
        mint: PublicKey;
    }>;
    getInitTickArrayTx(provider: Provider, param: InitTickArrayParams): Promise<TransactionBuilder>;
    /**
     * Construct a transaction for closing an existing position
     */
    getClosePositionTx(param: ClosePositionTxParam): Promise<TransactionBuilder>;
    getLowestInitializedTickArrayTickIndex(poolAddress: Address, tickSpacing: number): Promise<number>;
    getHighestInitializedTickArrayTickIndex(poolAddress: Address, tickSpacing: number): Promise<number>;
    getInitializeGapTickArraysTx(param: FillTickArraysParam): Promise<MultiTransactionBuilder>;
    /**
     * Construct a transaction for a swap
     */
    getSwapTx(param: SwapTxParam): Promise<MultiTransactionBuilder>;
    private getDefaultSqrtPriceLimit;
    private getTickArrayPublicKeysForSwap;
    /*** Quotes ***/
    /**
     * Construct a quote for opening a new position
     */
    getOpenPositionQuote(param: OpenPositionQuoteParam): Promise<OpenPositionQuote>;
    /**
     * Construct a quote for closing an existing position
     */
    getClosePositionQuote(param: ClosePositionQuoteParam): Promise<ClosePositionQuote>;
    /**
     * Construct a quote for swap
     */
    getSwapQuote(param: SwapQuoteParam$1): Promise<SwapQuote>;
}

/*** Transactions ***/
declare type AddLiquidityTxParam = {
    provider: Provider;
    quote: AddLiquidityQuote;
};
declare type RemoveLiquidityTxParam = {
    provider: Provider;
    quote: RemoveLiquidityQuote;
};
declare type CollectFeesAndRewardsTxParam = {
    provider: Provider;
    positionAddress: Address;
    resolvedAssociatedTokenAddresses?: Record<string, PublicKey>;
};
declare type CollectMultipleFeesAndRewardsTxParam = {
    provider: Provider;
    positionAddresses: Address[];
    resolvedAssociatedTokenAddresses?: Record<string, PublicKey>;
};
/*** Quotes ***/
declare type AddLiquidityQuoteParam = {
    positionAddress: Address;
    tokenMint: Address;
    tokenAmount: BN$1;
    refresh: boolean;
    slippageTolerance?: Percentage;
};
declare type AddLiquidityQuote = {
    positionAddress: Address;
    maxTokenA: BN$1;
    maxTokenB: BN$1;
    liquidity: BN$1;
};
declare type RemoveLiquidityQuoteParam = {
    positionAddress: Address;
    liquidity: BN$1;
    refresh: boolean;
    slippageTolerance?: Percentage;
};
declare type RemoveLiquidityQuote = {
    positionAddress: Address;
    minTokenA: BN$1;
    minTokenB: BN$1;
    liquidity: BN$1;
};
declare type CollectFeesQuote = {
    feeOwedA: BN$1;
    feeOwedB: BN$1;
};
declare type CollectRewardsQuote = [BN$1 | undefined, BN$1 | undefined, BN$1 | undefined];

declare class OrcaPosition {
    private readonly dal;
    constructor(dal: OrcaDAL);
    /*** Utilities ***/
    /**
     * Derive the position pda given position mint
     *
     * @param positionMint
     * @returns
     */
    derivePDA(positionMint: Address): PDA;
    /*** Transactions ***/
    /**
     * Construct a transaction for adding liquidity to an existing pool
     */
    getAddLiquidityTx(param: AddLiquidityTxParam): Promise<TransactionBuilder>;
    /**
     * Construct a transaction for removing liquidity from an existing pool
     */
    getRemoveLiquidityTx(param: RemoveLiquidityTxParam): Promise<TransactionBuilder>;
    /**
     * Construct a transaction for collecting fees and rewards from an existing pool
     */
    getCollectFeesAndRewardsTx(param: CollectFeesAndRewardsTxParam): Promise<TransactionBuilder>;
    /**
     * Construct a transaction for collecting fees and rewards from a list of  existing pools
     */
    getCollectMultipleFeesAndRewardsTx(param: CollectMultipleFeesAndRewardsTxParam): Promise<MultiTransactionBuilder>;
    /*** Quotes ***/
    /**
     * Construct a quote for adding liquidity to an existing pool
     */
    getAddLiquidityQuote(param: AddLiquidityQuoteParam): Promise<AddLiquidityQuote>;
    /**
     * Construct a quote for removing liquidity from an existing pool
     */
    getRemoveLiquidityQuote(param: RemoveLiquidityQuoteParam): Promise<RemoveLiquidityQuote>;
}

declare type TokenMint = string;
declare type TokenUSDPrices = Record<TokenMint, Decimal>;

/*** Token ***/
declare type OffchainTokenData = {
    mint: string;
    name: string;
    symbol: string;
    logoURI: string;
    whitelisted: boolean;
    coingeckoId?: string;
    ftxId?: string;
};
/*** Pool ***/
declare type OffchainPoolData = {
    address: string;
    whitelisted: boolean;
    tokenMintA: string;
    tokenMintB: string;
    stable: boolean;
    price: number;
    lpsFeeRate: number;
    protocolFeeRate: number;
    priceHistory?: DayWeekMonthData<MinMax>;
    tokenAPriceUSD?: CombinedTokenPrice;
    tokenBPriceUSD?: CombinedTokenPrice;
    tvl?: number;
    volume?: DayWeekMonthData<number>;
    feeApr?: DayWeekMonthData<number>;
    reward0Apr?: DayWeekMonthData<number>;
    reward1Apr?: DayWeekMonthData<number>;
    reward2Apr?: DayWeekMonthData<number>;
};
interface DayWeekMonthData<T> {
    day: T;
    week: T;
    month: T;
}
declare type CombinedTokenPrice = {
    price?: number;
    dex?: number;
    coingecko?: number;
};
declare type MinMax = {
    min: number;
    max: number;
};

/**
 * Offchain data accessor.
 */
declare class OrcaZooplankton {
    private readonly _request;
    private readonly _cache;
    constructor(dataSourceURI: string);
    getTokens(): Promise<Record<string, OffchainTokenData> | null>;
    getPools(): Promise<Record<string, OffchainPoolData> | null>;
}

declare type OrcaWhirlpoolClientConfig = {
    network?: OrcaNetwork;
    connection?: Connection;
    whirlpoolConfig?: Address;
    programId?: Address;
    offchainDataURI?: string;
};
declare class OrcaWhirlpoolClient {
    readonly data: OrcaDAL;
    readonly admin: OrcaAdmin;
    readonly pool: OrcaPool;
    readonly position: OrcaPosition;
    readonly offchain: OrcaZooplankton;
    constructor(config?: OrcaWhirlpoolClientConfig);
    /**
     * Use on-chain dex data to derive usd prices for tokens.
     *
     * @param poolAddresses pools to be used for price discovery
     * @param baseTokenMint a token mint with known stable usd price (e.g. USDC)
     * @param baseTokenUSDPrice baseTokenMint's usd price. defaults to 1, assuming `baseTokenMint` is a USD stable coin
     * @param otherBaseTokenMints optional list of token mints to prioritize as base
     * @param refresh defaults to refreshing the cache
     */
    getTokenPrices(poolAddresses: Address[], baseTokenMint: Address, baseTokenUSDPrice?: Decimal, otherBaseTokenMints?: Address[], refresh?: boolean): Promise<TokenUSDPrices>;
    /**
     * Fetch position data owned by the wallet address.
     *
     * @param walletAddress wallet address
     * @param refresh defaults to refreshing the cache
     * @returns positions owned by the wallet address
     */
    getUserPositions(walletAddress: Address, refresh?: boolean): Promise<Record<string, UserPositionData>>;
    /**
     * Fetch list of pool data.
     *
     * @param poolAddresses list of pools to retrieve
     * @param refresh defaults to refreshing the cache
     * @returns list of pool data
     */
    getPools(poolAddresses: Address[], refresh?: boolean): Promise<Record<string, PoolData>>;
    /**
     * Fetch pool data.
     *
     * @param poolAddress pool address
     * @param refresh defaults to refreshing the cache
     * @returns pool data
     */
    getPool(poolAddress: Address, refresh?: boolean): Promise<PoolData | null>;
}

declare type InitWhirlpoolConfigsTxParam = {
    programId: Address;
    provider: Provider;
    whirlpoolConfigKeypair: Keypair;
    feeAuthority: Address;
    collectProtocolFeesAuthority: Address;
    rewardEmissionsSuperAuthority: Address;
    defaultProtocolFeeRate: number;
};
declare function getInitWhirlpoolConfigsTx({ programId, provider, whirlpoolConfigKeypair, feeAuthority, collectProtocolFeesAuthority, rewardEmissionsSuperAuthority, defaultProtocolFeeRate, }: InitWhirlpoolConfigsTxParam): TransactionBuilder;
declare type InitFeeTierConfigTxParam = {
    programId: Address;
    provider: Provider;
    whirlpoolConfigKey: Address;
    feeAuthority: Address;
    tickSpacing: TickSpacing;
    defaultFeeRate: number;
};
declare function getInitFeeTierConfigTx({ programId, provider, whirlpoolConfigKey, feeAuthority, tickSpacing, defaultFeeRate, }: InitFeeTierConfigTxParam): TransactionBuilder;

declare function getNearestValidTickIndexFromTickIndex(tickIndex: number, stable?: boolean): number;
declare function getNearestValidTickIndex(price: Decimal, decimalsA: number, decimalsB: number, stable?: boolean): number;
declare function getNextValidTickIndex(tickIndex: number, stable?: boolean): number;
declare function getPrevValidTickIndex(tickIndex: number, stable?: boolean): number;
declare function sqrtPriceX64ToPrice(sqrtPriceX64: BN$1, decimalsA: number, decimalsB: number): Decimal;
declare function priceToSqrtX64(price: Decimal, decimalsA: number, decimalsB: number): BN$1;
declare function tickIndexToPrice(tickIndex: number, decimalsA: number, decimalsB: number): Decimal;
declare function priceToTickIndex(price: Decimal, decimalsA: number, decimalsB: number): number;

declare class DecimalUtil {
    static adjustDecimals(input: Decimal, shift?: number): Decimal;
    static fromU64(input: u64, shift?: number): Decimal;
    static fromNumber(input: number, shift?: number): Decimal;
    static toU64(input: Decimal, shift?: number): u64;
}

declare enum SwapDirection {
    AtoB = "Swap A to B",
    BtoA = "Swap B to A"
}
declare enum AmountSpecified {
    Input = "Specified input amount",
    Output = "Specified output amount"
}

declare enum PositionStatus {
    BelowRange = 0,
    InRange = 1,
    AboveRange = 2
}
declare class PositionUtil {
    private constructor();
    static getPositionStatus(tickCurrentIndex: number, tickLowerIndex: number, tickUpperIndex: number): PositionStatus;
}
declare function adjustForSlippage(n: BN$1, { numerator, denominator }: Percentage, adjustUp: boolean): BN$1;
declare function adjustAmountForSlippage(amountIn: BN$1, amountOut: BN$1, { numerator, denominator }: Percentage, amountSpecified: AmountSpecified): BN$1;
declare function getLiquidityFromTokenA(amount: BN$1, sqrtPriceLowerX64: BN$1, sqrtPriceUpperX64: BN$1, roundUp: boolean): BN$1;
declare function getLiquidityFromTokenB(amount: BN$1, sqrtPriceLowerX64: BN$1, sqrtPriceUpperX64: BN$1, roundUp: boolean): BN$1;
declare function getTokenAFromLiquidity(liquidity: BN$1, sqrtPrice0X64: BN$1, sqrtPrice1X64: BN$1, roundUp: boolean): BN$1;
declare function getTokenBFromLiquidity(liquidity: BN$1, sqrtPrice0X64: BN$1, sqrtPrice1X64: BN$1, roundUp: boolean): BN$1;
declare function getAmountFixedDelta(currentSqrtPriceX64: BN$1, targetSqrtPriceX64: BN$1, liquidity: BN$1, amountSpecified: AmountSpecified, swapDirection: SwapDirection): BN$1;
declare function getAmountUnfixedDelta(currentSqrtPriceX64: BN$1, targetSqrtPriceX64: BN$1, liquidity: BN$1, amountSpecified: AmountSpecified, swapDirection: SwapDirection): BN$1;
declare function getNextSqrtPrice(sqrtPriceX64: BN$1, liquidity: BN$1, amount: BN$1, amountSpecified: AmountSpecified, swapDirection: SwapDirection): BN$1;

/**
 * A sync attempt at getSwapQuote
 */

declare type SwapQuoteParam = {
    poolAddress: PublicKey;
    whirlpool: WhirlpoolData;
    tickArrays: Map<string, TickArrayData>;
    tokenMint: PublicKey;
    tokenAmount: u64;
    isInput: boolean;
    slippageTolerance?: Percentage;
};
declare function getSwapQuote(param: SwapQuoteParam): {
    otherAmountThreshold: BN;
    sqrtPriceLimitX64: BN;
    amountIn: BN;
    amountOut: BN;
    aToB: boolean;
    fixedInput: boolean;
};
/** Provides 3 tick arrays each side given current tick index */
declare function getTickArrayPks(poolAddress: PublicKey, whirlpool: WhirlpoolData): PublicKey[];
declare function getTickArrayPublicKeysForSwap(tickCurrentIndex: number, targetSqrtPriceX64: BN, tickSpacing: number, poolAddress: PublicKey, tickArrays: Map<string, TickArrayData>, programId: PublicKey, aToB: boolean): [PublicKey, PublicKey, PublicKey];
declare function getDefaultSqrtPriceLimit(aToB: boolean): BN;

declare const defaultSlippagePercentage: Percentage;
declare const defaultNetwork: OrcaNetwork;
declare function getDefaultConnection(network: OrcaNetwork): Connection;
declare function getDefaultOffchainDataURI(network: OrcaNetwork): string;

export { AddLiquidityQuote, AddLiquidityQuoteParam, AddLiquidityTxParam, ClosePositionQuote, ClosePositionQuoteParam, ClosePositionTxParam, CollectFeesAndRewardsTxParam, CollectFeesQuote, CollectMultipleFeesAndRewardsTxParam, CollectProtocolFeesTxParam, CollectRewardsQuote, CombinedTokenPrice, DayWeekMonthData, DecimalUtil, FillTickArraysParam, InitFeeTierConfigTxParam, InitPoolTxParam, InitRewardTxParam, InitWhirlpoolConfigsTxParam, MinMax, MultiTransactionBuilder, OffchainPoolData, OffchainTokenData, OpenPositionQuote, OpenPositionQuoteByPrice, OpenPositionQuoteByTickIndex, OpenPositionQuoteParam, OpenPositionTxParam, OrcaNetwork, OrcaWhirlpoolClient, OrcaWhirlpoolClientConfig, Percentage, PoolData, PoolRewardInfo, PositionStatus, PositionUtil, RemoveLiquidityQuote, RemoveLiquidityQuoteParam, RemoveLiquidityTxParam, SetCollectProtocolFeesAuthorityTxParam, SetFeeAuthorityTxParam, SetFeeRateTxParam, SetProtocolFeeRateTxParam, SetRewardAuthorityBySuperAuthorityTxParam, SetRewardAuthorityTxParam, SetRewardEmissionsBySuperAuthorityTxParam, SetRewardEmissionsTxParam, SwapQuote, SwapQuoteParam$1 as SwapQuoteParam, SwapTxParam, UserPositionData, UserPositionRewardInfo, UserToken, adjustAmountForSlippage, adjustForSlippage, defaultNetwork, defaultSlippagePercentage, getAmountFixedDelta, getAmountUnfixedDelta, getDefaultConnection, getDefaultOffchainDataURI, getDefaultSqrtPriceLimit, getInitFeeTierConfigTx, getInitWhirlpoolConfigsTx, getLiquidityFromTokenA, getLiquidityFromTokenB, getNearestValidTickIndex, getNearestValidTickIndexFromTickIndex, getNextSqrtPrice, getNextValidTickIndex, getPrevValidTickIndex, getSwapQuote, getTickArrayPks, getTickArrayPublicKeysForSwap, getTokenAFromLiquidity, getTokenBFromLiquidity, isQuoteByPrice, isQuoteByTickIndex, priceToSqrtX64, priceToTickIndex, sqrtPriceX64ToPrice, tickIndexToPrice };
