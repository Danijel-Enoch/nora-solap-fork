"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultSqrtPriceLimit = exports.getTickArrayPublicKeysForSwap = exports.getTickArrayPks = exports.getSwapQuote = exports.parseTickArray = exports.parseWhirlpool = void 0;
/**
 * A sync attempt at getSwapQuote
 */
const whirlpool_client_sdk_1 = require("@orca-so/whirlpool-client-sdk");
Object.defineProperty(exports, "parseTickArray", { enumerable: true, get: function () { return whirlpool_client_sdk_1.parseTickArray; } });
Object.defineProperty(exports, "parseWhirlpool", { enumerable: true, get: function () { return whirlpool_client_sdk_1.parseWhirlpool; } });
const web3_js_1 = require("@solana/web3.js");
const bn_js_1 = __importDefault(require("bn.js"));
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const defaults_1 = require("../constants/defaults");
const math_utils_1 = require("../utils/web3/math-utils");
const pool_util_1 = require("../utils/whirlpool/pool-util");
const position_util_1 = require("../utils/whirlpool/position-util");
const tick_util_1 = require("../utils/whirlpool/tick-util");
const swap_quoter_1 = require("./quotes/swap-quoter");
const PROGRAM_ID = new web3_js_1.PublicKey("whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc");
function getSwapQuote(param) {
    const { poolAddress, whirlpool, tickArrays, tokenMint, tokenAmount, isInput, slippageTolerance = defaults_1.defaultSlippagePercentage, } = param;
    const swapDirection = tokenMint.equals(whirlpool.tokenMintA) === isInput ? swap_quoter_1.SwapDirection.AtoB : swap_quoter_1.SwapDirection.BtoA;
    const amountSpecified = isInput ? swap_quoter_1.AmountSpecified.Input : swap_quoter_1.AmountSpecified.Output;
    const { amountIn, amountOut, sqrtPriceLimitX64 } = simulateSwap({
        poolAddress,
        whirlpoolData: whirlpool,
        tickArrays,
        amountSpecified,
        swapDirection,
    }, {
        amount: tokenAmount,
        currentSqrtPriceX64: whirlpool.sqrtPrice,
        currentTickIndex: whirlpool.tickCurrentIndex,
        currentLiquidity: whirlpool.liquidity,
    });
    const otherAmountThreshold = (0, position_util_1.adjustAmountForSlippage)(amountIn, amountOut, slippageTolerance, // TODO: FIX
    amountSpecified);
    return {
        otherAmountThreshold,
        sqrtPriceLimitX64,
        amountIn,
        amountOut,
        aToB: swapDirection === swap_quoter_1.SwapDirection.AtoB,
        fixedInput: isInput,
    };
}
exports.getSwapQuote = getSwapQuote;
function simulateSwap(baseInput, input) {
    const { amountSpecified, swapDirection } = baseInput;
    let { currentTickIndex, currentLiquidity, amount: specifiedAmountLeft, currentSqrtPriceX64, } = input;
    (0, tiny_invariant_1.default)(!specifiedAmountLeft.eq(math_utils_1.ZERO), "amount must be nonzero");
    let otherAmountCalculated = math_utils_1.ZERO;
    let tickArraysCrossed = 0;
    let sqrtPriceLimitX64;
    while (specifiedAmountLeft.gt(math_utils_1.ZERO)) {
        if (tickArraysCrossed > swap_quoter_1.MAX_TICK_ARRAY_CROSSINGS) {
            throw Error("Crossed the maximum number of tick arrays");
        }
        const swapStepSimulationOutput = simulateSwapStep(baseInput, {
            sqrtPriceX64: currentSqrtPriceX64,
            amountRemaining: specifiedAmountLeft,
            tickIndex: currentTickIndex,
            liquidity: currentLiquidity,
            tickArraysCrossed,
        });
        const { input, output, nextSqrtPriceX64, nextTickIndex, hasReachedNextTick } = swapStepSimulationOutput;
        const [specifiedAmountUsed, otherAmount] = (0, swap_quoter_1.resolveTokenAmounts)(input, output, amountSpecified);
        specifiedAmountLeft = specifiedAmountLeft.sub(specifiedAmountUsed);
        otherAmountCalculated = otherAmountCalculated.add(otherAmount);
        if (hasReachedNextTick) {
            // get dat tick
            const nextTick = pickTick(baseInput, nextTickIndex);
            currentLiquidity = (0, swap_quoter_1.calculateNewLiquidity)(currentLiquidity, nextTick.liquidityNet, swapDirection);
            currentTickIndex = swapDirection == swap_quoter_1.SwapDirection.AtoB ? nextTickIndex - 1 : nextTickIndex;
        }
        currentSqrtPriceX64 = nextSqrtPriceX64;
        tickArraysCrossed = swapStepSimulationOutput.tickArraysCrossed;
        if (tickArraysCrossed > swap_quoter_1.MAX_TICK_ARRAY_CROSSINGS) {
            sqrtPriceLimitX64 = (0, whirlpool_client_sdk_1.tickIndexToSqrtPriceX64)(nextTickIndex);
        }
    }
    const [inputAmount, outputAmount] = (0, swap_quoter_1.resolveTokenAmounts)(input.amount.sub(specifiedAmountLeft), otherAmountCalculated, amountSpecified);
    if (!sqrtPriceLimitX64) {
        if (swapDirection === swap_quoter_1.SwapDirection.AtoB) {
            sqrtPriceLimitX64 = new bn_js_1.default(whirlpool_client_sdk_1.MIN_SQRT_PRICE);
        }
        else {
            sqrtPriceLimitX64 = new bn_js_1.default(whirlpool_client_sdk_1.MAX_SQRT_PRICE);
        }
    }
    // Return sqrtPriceLimit if 3 tick arrays crossed
    return {
        amountIn: inputAmount,
        amountOut: outputAmount,
        sqrtPriceLimitX64,
    };
}
function pickTick(baseInput, tickIndex) {
    const tickArray = pickTickArray(baseInput, tickIndex);
    const { whirlpoolData: { tickSpacing }, } = baseInput;
    return tick_util_1.TickUtil.getTick(tickArray, tickIndex, tickSpacing);
}
function pickTickArray(baseInput, tickIndex) {
    const { poolAddress, whirlpoolData: { tickSpacing }, } = baseInput;
    const tickArrayPk = tick_util_1.TickUtil.getPdaWithTickIndex(tickIndex, tickSpacing, poolAddress, PROGRAM_ID).publicKey;
    const tickArray = baseInput.tickArrays.get(tickArrayPk.toBase58());
    (0, tiny_invariant_1.default)(!!tickArray, "tickArray is null");
    return tickArray;
}
function simulateSwapStep(baseInput, input) {
    const { whirlpoolData, amountSpecified, swapDirection } = baseInput;
    const { feeRate } = whirlpoolData;
    const feeRatePercentage = pool_util_1.PoolUtil.getFeeRate(feeRate);
    const { amountRemaining, liquidity, sqrtPriceX64, tickIndex, tickArraysCrossed } = input;
    const { tickIndex: nextTickIndex, tickArraysCrossed: tickArraysCrossedUpdate } = 
    // Return last tick in tick array if max tick arrays crossed
    // Error out of this gets called for another iteration
    getNextInitializedTickIndex(baseInput, tickIndex, tickArraysCrossed);
    const targetSqrtPriceX64 = (0, whirlpool_client_sdk_1.tickIndexToSqrtPriceX64)(nextTickIndex);
    let fixedDelta = (0, position_util_1.getAmountFixedDelta)(sqrtPriceX64, targetSqrtPriceX64, liquidity, amountSpecified, swapDirection);
    let amountCalculated = amountRemaining;
    if (amountSpecified == swap_quoter_1.AmountSpecified.Input) {
        amountCalculated = (0, swap_quoter_1.calculateAmountAfterFees)(amountRemaining, feeRatePercentage);
    }
    const nextSqrtPriceX64 = amountCalculated.gte(fixedDelta)
        ? targetSqrtPriceX64 // Fully utilize liquidity till upcoming (next/prev depending on swap type) initialized tick
        : (0, position_util_1.getNextSqrtPrice)(sqrtPriceX64, liquidity, amountCalculated, amountSpecified, swapDirection);
    const hasReachedNextTick = nextSqrtPriceX64.eq(targetSqrtPriceX64);
    const unfixedDelta = (0, position_util_1.getAmountUnfixedDelta)(sqrtPriceX64, nextSqrtPriceX64, liquidity, amountSpecified, swapDirection);
    if (!hasReachedNextTick) {
        fixedDelta = (0, position_util_1.getAmountFixedDelta)(sqrtPriceX64, nextSqrtPriceX64, liquidity, amountSpecified, swapDirection);
    }
    let [inputDelta, outputDelta] = (0, swap_quoter_1.resolveTokenAmounts)(fixedDelta, unfixedDelta, amountSpecified);
    // Cap output if output specified
    if (amountSpecified == swap_quoter_1.AmountSpecified.Output && outputDelta.gt(amountRemaining)) {
        outputDelta = amountRemaining;
    }
    if (amountSpecified == swap_quoter_1.AmountSpecified.Input && !hasReachedNextTick) {
        inputDelta = amountRemaining;
    }
    else {
        inputDelta = inputDelta.add((0, swap_quoter_1.calculateFeesFromAmount)(inputDelta, feeRatePercentage));
    }
    return {
        nextTickIndex,
        nextSqrtPriceX64,
        input: inputDelta,
        output: outputDelta,
        tickArraysCrossed: tickArraysCrossedUpdate,
        hasReachedNextTick,
    };
}
function getNextInitializedTickIndex(baseInput, currentTickIndex, tickArraysCrossed) {
    const { whirlpoolData: { tickSpacing }, swapDirection, } = baseInput;
    let nextInitializedTickIndex = undefined;
    while (nextInitializedTickIndex === undefined) {
        const currentTickArray = pickTickArray(baseInput, currentTickIndex);
        let temp;
        if (swapDirection == swap_quoter_1.SwapDirection.AtoB) {
            temp = tick_util_1.TickUtil.getPrevInitializedTickIndex(currentTickArray, currentTickIndex, tickSpacing);
        }
        else {
            temp = tick_util_1.TickUtil.getNextInitializedTickIndex(currentTickArray, currentTickIndex, tickSpacing);
        }
        if (temp) {
            nextInitializedTickIndex = temp;
        }
        else if (tickArraysCrossed === swap_quoter_1.MAX_TICK_ARRAY_CROSSINGS) {
            if (swapDirection === swap_quoter_1.SwapDirection.AtoB) {
                nextInitializedTickIndex = currentTickArray.startTickIndex;
            }
            else {
                nextInitializedTickIndex = currentTickArray.startTickIndex + whirlpool_client_sdk_1.TICK_ARRAY_SIZE * tickSpacing;
            }
            tickArraysCrossed++;
        }
        else {
            if (swapDirection === swap_quoter_1.SwapDirection.AtoB) {
                currentTickIndex = currentTickArray.startTickIndex - 1;
            }
            else {
                currentTickIndex = currentTickArray.startTickIndex + whirlpool_client_sdk_1.TICK_ARRAY_SIZE * tickSpacing;
            }
            tickArraysCrossed++;
        }
    }
    return {
        tickIndex: nextInitializedTickIndex,
        tickArraysCrossed,
    };
}
/** Provides 3 tick arrays each side given current tick index */
function getTickArrayPks(poolAddress, whirlpool) {
    const tickArrayPks = [];
    // TODO: Add limits, but maybe fine for now?
    for (let tickArrayOffset = -3; tickArrayOffset <= 2; tickArrayOffset++) {
        const pk = tick_util_1.TickUtil.getPdaWithTickIndex(whirlpool.tickCurrentIndex, whirlpool.tickSpacing, poolAddress, PROGRAM_ID, tickArrayOffset).publicKey;
        console.log(pk.toBase58());
        tickArrayPks.push(pk);
    }
    return tickArrayPks;
}
exports.getTickArrayPks = getTickArrayPks;
function getTickArrayPublicKeysForSwap(tickCurrentIndex, targetSqrtPriceX64, tickSpacing, poolAddress, tickArrays, programId, aToB) {
    const nextInitializableTickIndex = tick_util_1.TickUtil.getNextInitializableTickIndex(tickCurrentIndex, tickSpacing, aToB);
    const targetTickIndex = (0, whirlpool_client_sdk_1.sqrtPriceX64ToTickIndex)(targetSqrtPriceX64);
    let currentStartTickIndex = tick_util_1.TickUtil.getStartTickIndex(nextInitializableTickIndex, tickSpacing);
    const targetStartTickIndex = tick_util_1.TickUtil.getStartTickIndex(targetTickIndex, tickSpacing);
    const offset = nextInitializableTickIndex < targetTickIndex ? 1 : -1;
    let count = 1;
    const tickArrayAddresses = [
        (0, whirlpool_client_sdk_1.getTickArrayPda)(programId, poolAddress, currentStartTickIndex).publicKey,
        web3_js_1.PublicKey.default,
        web3_js_1.PublicKey.default,
    ];
    while (currentStartTickIndex != targetStartTickIndex && count < 3) {
        const nextStartTickIndex = tick_util_1.TickUtil.getStartTickIndex(nextInitializableTickIndex, tickSpacing, offset * count);
        const nextTickArrayAddress = (0, whirlpool_client_sdk_1.getTickArrayPda)(programId, poolAddress, nextStartTickIndex).publicKey;
        const nextTickArray = tickArrays.get(nextTickArrayAddress.toBase58());
        if (!nextTickArray) {
            break;
        }
        tickArrayAddresses[count] = nextTickArrayAddress;
        count++;
        currentStartTickIndex = nextStartTickIndex;
    }
    while (count < 3) {
        tickArrayAddresses[count] = (0, whirlpool_client_sdk_1.getTickArrayPda)(programId, poolAddress, currentStartTickIndex).publicKey;
        count++;
    }
    return tickArrayAddresses;
}
exports.getTickArrayPublicKeysForSwap = getTickArrayPublicKeysForSwap;
function getDefaultSqrtPriceLimit(aToB) {
    return new bn_js_1.default(aToB ? whirlpool_client_sdk_1.MIN_SQRT_PRICE : whirlpool_client_sdk_1.MAX_SQRT_PRICE);
}
exports.getDefaultSqrtPriceLimit = getDefaultSqrtPriceLimit;
