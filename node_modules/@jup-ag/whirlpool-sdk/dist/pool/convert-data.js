"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertWhirlpoolDataToPoolData = void 0;
const web3_js_1 = require("@solana/web3.js");
const address_1 = require("../utils/address");
const decimal_utils_1 = require("../utils/public/decimal-utils");
const whirlpool_client_sdk_1 = require("@orca-so/whirlpool-client-sdk");
const tick_util_1 = require("../utils/whirlpool/tick-util");
const public_1 = require("../utils/public");
function convertWhirlpoolDataToPoolData(dal, poolAddresses, refresh) {
    var _a, _b, _c, _d, _e, _f;
    return __awaiter(this, void 0, void 0, function* () {
        if (refresh) {
            const pools = yield dal.listPools(poolAddresses, true);
            const allTokenAccounts = new Set();
            const allMintInfos = new Set();
            const allTickArrays = [];
            pools.forEach((pool, index) => {
                const poolAddress = poolAddresses[index];
                if (pool && poolAddress) {
                    allTokenAccounts.add(pool.tokenVaultA.toBase58());
                    allTokenAccounts.add(pool.tokenVaultB.toBase58());
                    allMintInfos.add(pool.tokenMintA.toBase58());
                    allMintInfos.add(pool.tokenMintB.toBase58());
                    allTickArrays.push(tick_util_1.TickUtil.getPDAWithSqrtPrice(pool.sqrtPrice, pool.tickSpacing, poolAddress, dal.programId).publicKey.toBase58());
                    pool.rewardInfos.forEach(({ vault, mint }) => {
                        if (!mint.equals(web3_js_1.PublicKey.default) && !vault.equals(web3_js_1.PublicKey.default)) {
                            allTokenAccounts.add(vault.toBase58());
                            allMintInfos.add(mint.toBase58());
                        }
                    });
                }
            });
            yield Promise.all([
                dal.listTokenInfos(Array.from(allTokenAccounts), true),
                dal.listMintInfos(Array.from(allMintInfos), false),
                dal.listTickArrays(allTickArrays, true),
            ]);
        }
        const result = {};
        for (const address of poolAddresses) {
            const poolId = (0, address_1.toPubKey)(address).toBase58();
            const pool = yield dal.getPool(address, false);
            if (!pool) {
                console.error(`error - pool not found`);
                continue;
            }
            const amountA = (_a = (yield dal.getTokenInfo(pool.tokenVaultA, false))) === null || _a === void 0 ? void 0 : _a.amount;
            const amountB = (_b = (yield dal.getTokenInfo(pool.tokenVaultB, false))) === null || _b === void 0 ? void 0 : _b.amount;
            const decimalsA = (_c = (yield dal.getMintInfo(pool.tokenMintA, false))) === null || _c === void 0 ? void 0 : _c.decimals;
            const decimalsB = (_d = (yield dal.getMintInfo(pool.tokenMintB, false))) === null || _d === void 0 ? void 0 : _d.decimals;
            if (!amountA || !amountB || decimalsA === undefined || decimalsB === undefined) {
                console.error(`error - amount or decimals not found`);
                continue;
            }
            const feePercentage = decimal_utils_1.DecimalUtil.fromNumber(pool.feeRate, 6);
            const protocolFeePercentage = decimal_utils_1.DecimalUtil.fromNumber(pool.protocolFeeRate, 4);
            const rewards = [];
            for (const { mint, vault, emissionsPerSecondX64, growthGlobalX64 } of pool.rewardInfos) {
                let amount = undefined;
                let decimals = undefined;
                if (!mint.equals(web3_js_1.PublicKey.default) && !vault.equals(web3_js_1.PublicKey.default)) {
                    amount = (_e = (yield dal.getTokenInfo(vault, false))) === null || _e === void 0 ? void 0 : _e.amount;
                    decimals = (_f = (yield dal.getMintInfo(mint, false))) === null || _f === void 0 ? void 0 : _f.decimals;
                }
                rewards.push({
                    mint,
                    vault,
                    vaultAmount: amount,
                    decimalVaultAmount: decimals && amount ? decimal_utils_1.DecimalUtil.fromU64(amount, decimals) : undefined,
                    emissionsPerSecondX64,
                    growthGlobalX64,
                    emissionsPerSecond: decimals
                        ? decimal_utils_1.DecimalUtil.adjustDecimals((0, whirlpool_client_sdk_1.fromX64)(emissionsPerSecondX64), decimals)
                        : undefined,
                });
            }
            result[poolId] = {
                address: (0, address_1.toPubKey)(address),
                tokenMintA: pool.tokenMintA,
                tokenMintB: pool.tokenMintB,
                stable: pool.tickSpacing === whirlpool_client_sdk_1.TickSpacing.Stable,
                feeRate: pool.feeRate,
                protocolFeeRate: pool.protocolFeeRate,
                liquidity: pool.liquidity,
                sqrtPrice: pool.sqrtPrice,
                tickCurrentIndex: pool.tickCurrentIndex,
                protocolFeeOwedA: pool.protocolFeeOwedA,
                protocolFeeOwedB: pool.protocolFeeOwedB,
                tokenVaultAmountA: amountA,
                tokenVaultAmountB: amountB,
                rewards,
                feeGrowthGlobalAX64: pool.feeGrowthGlobalA,
                feeGrowthGlobalBX64: pool.feeGrowthGlobalB,
                // Derived helper fields
                feePercentage,
                protocolFeePercentage,
                price: (0, public_1.sqrtPriceX64ToPrice)(pool.sqrtPrice, decimalsA, decimalsB),
                decimalProtocolFeeOwedA: decimal_utils_1.DecimalUtil.fromU64(pool.protocolFeeOwedA, decimalsA),
                decimalProtocolFeeOwedB: decimal_utils_1.DecimalUtil.fromU64(pool.protocolFeeOwedB, decimalsB),
                decimalTokenVaultAmountA: decimal_utils_1.DecimalUtil.fromU64(amountA, decimalsA),
                decimalTokenVaultAmountB: decimal_utils_1.DecimalUtil.fromU64(amountB, decimalsB),
                tokenDecimalsA: decimalsA,
                tokenDecimalsB: decimalsB,
            };
        }
        return result;
    });
}
exports.convertWhirlpoolDataToPoolData = convertWhirlpoolDataToPoolData;
