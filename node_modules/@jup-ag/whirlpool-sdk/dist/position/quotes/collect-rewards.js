"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCollectRewardsQuoteInternal = void 0;
const whirlpool_client_sdk_1 = require("@orca-so/whirlpool-client-sdk");
const anchor_1 = require("@project-serum/anchor");
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const math_utils_1 = require("../../utils/web3/math-utils");
const pool_util_1 = require("../../utils/whirlpool/pool-util");
function getCollectRewardsQuoteInternal(param) {
    var _a, _b, _c, _d, _e, _f;
    const { whirlpool, position, tickLower, tickUpper } = param;
    const { tickCurrentIndex, rewardInfos: whirlpoolRewardsInfos } = whirlpool;
    const { tickLowerIndex, tickUpperIndex, liquidity, rewardInfos } = position;
    // Calculate the reward growths inside the position
    const range = [...Array(whirlpool_client_sdk_1.NUM_REWARDS).keys()];
    const rewardGrowthsBelowX64 = range.map(() => new anchor_1.BN(0));
    const rewardGrowthsAboveX64 = range.map(() => new anchor_1.BN(0));
    for (const i of range) {
        const rewardInfo = whirlpoolRewardsInfos[i];
        (0, tiny_invariant_1.default)(!!rewardInfo, "whirlpoolRewardsInfos cannot be undefined");
        const growthGlobalX64 = rewardInfo.growthGlobalX64;
        const lowerRewardGrowthsOutside = tickLower.rewardGrowthsOutside[i];
        const upperRewardGrowthsOutside = tickUpper.rewardGrowthsOutside[i];
        (0, tiny_invariant_1.default)(!!lowerRewardGrowthsOutside, "lowerRewardGrowthsOutside cannot be undefined");
        (0, tiny_invariant_1.default)(!!upperRewardGrowthsOutside, "upperRewardGrowthsOutside cannot be undefined");
        if (tickCurrentIndex < tickLowerIndex) {
            rewardGrowthsBelowX64[i] = (0, math_utils_1.subUnderflowU128)(growthGlobalX64, lowerRewardGrowthsOutside);
        }
        else {
            rewardGrowthsBelowX64[i] = lowerRewardGrowthsOutside;
        }
        if (tickCurrentIndex < tickUpperIndex) {
            rewardGrowthsAboveX64[i] = upperRewardGrowthsOutside;
        }
        else {
            rewardGrowthsAboveX64[i] = (0, math_utils_1.subUnderflowU128)(growthGlobalX64, upperRewardGrowthsOutside);
        }
    }
    const rewardGrowthsInsideX64 = range.map(() => [new anchor_1.BN(0), false]);
    for (const i of range) {
        const rewardInfo = whirlpoolRewardsInfos[i];
        (0, tiny_invariant_1.default)(!!rewardInfo, "whirlpoolRewardsInfos cannot be undefined");
        const isRewardInitialized = pool_util_1.PoolUtil.isRewardInitialized(rewardInfo);
        if (isRewardInitialized) {
            const growthBelowX64 = rewardGrowthsBelowX64[i];
            const growthAboveX64 = rewardGrowthsAboveX64[i];
            (0, tiny_invariant_1.default)(!!growthBelowX64, "growthBelowX64 cannot be undefined");
            (0, tiny_invariant_1.default)(!!growthAboveX64, "growthAboveX64 cannot be undefined");
            const growthInsde = (0, math_utils_1.subUnderflowU128)((0, math_utils_1.subUnderflowU128)(rewardInfo.growthGlobalX64, growthBelowX64), growthAboveX64);
            rewardGrowthsInsideX64[i] = [growthInsde, true];
        }
    }
    // Calculate the updated rewards owed
    const updatedRewardInfosX64 = range.map(() => new anchor_1.BN(0));
    for (const i of range) {
        const growthInsideX64 = rewardGrowthsInsideX64[i];
        (0, tiny_invariant_1.default)(!!growthInsideX64, "growthInsideX64 cannot be undefined");
        const [rewardGrowthInsideX64, isRewardInitialized] = growthInsideX64;
        if (isRewardInitialized) {
            const rewardInfo = rewardInfos[i];
            (0, tiny_invariant_1.default)(!!rewardInfo, "rewardInfo cannot be undefined");
            const amountOwedX64 = rewardInfo.amountOwed.shln(64);
            const growthInsideCheckpointX64 = rewardInfo.growthInsideCheckpoint;
            updatedRewardInfosX64[i] = amountOwedX64.add((0, math_utils_1.subUnderflowU128)(rewardGrowthInsideX64, growthInsideCheckpointX64).mul(liquidity));
        }
    }
    (0, tiny_invariant_1.default)(rewardGrowthsInsideX64.length >= 3, "rewards length is less than 3");
    const rewardExistsA = (_a = rewardGrowthsInsideX64[0]) === null || _a === void 0 ? void 0 : _a[1];
    const rewardExistsB = (_b = rewardGrowthsInsideX64[1]) === null || _b === void 0 ? void 0 : _b[1];
    const rewardExistsC = (_c = rewardGrowthsInsideX64[2]) === null || _c === void 0 ? void 0 : _c[1];
    const rewardOwedA = rewardExistsA ? (_d = updatedRewardInfosX64[0]) === null || _d === void 0 ? void 0 : _d.shrn(64) : undefined;
    const rewardOwedB = rewardExistsB ? (_e = updatedRewardInfosX64[1]) === null || _e === void 0 ? void 0 : _e.shrn(64) : undefined;
    const rewardOwedC = rewardExistsC ? (_f = updatedRewardInfosX64[2]) === null || _f === void 0 ? void 0 : _f.shrn(64) : undefined;
    return [rewardOwedA, rewardOwedB, rewardOwedC];
}
exports.getCollectRewardsQuoteInternal = getCollectRewardsQuoteInternal;
